{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///src/main.js","webpack:///webpack/bootstrap 2b3123ceb3e8c542395e","webpack:///./src/main.ts","webpack:///./~/@dojo/widget-core/mixins/createProjectorMixin.js","webpack:///./~/@dojo/core/global.js","webpack:///./~/@dojo/compose/compose.js","webpack:///./~/@dojo/core/instrument.js","webpack:///./~/@dojo/core/has.js","webpack:///./~/@dojo/shim/support/has.js","webpack:///./~/@dojo/shim/support/global.js","webpack:///./~/@dojo/has/has.js","webpack:///./~/process/browser.js","webpack:///./~/@dojo/core/lang.js","webpack:///./~/@dojo/shim/array.js","webpack:///./~/@dojo/shim/support/util.js","webpack:///./~/@dojo/shim/iterator.js","webpack:///./~/@dojo/shim/string.js","webpack:///./~/@dojo/shim/Symbol.js","webpack:///./~/@dojo/shim/number.js","webpack:///./~/@dojo/shim/WeakMap.js","webpack:///./~/@dojo/shim/support/decorators.js","webpack:///./~/@dojo/compose/aspect.js","webpack:///./~/@dojo/shim/Promise.js","webpack:///./~/@dojo/shim/support/queue.js","webpack:///./~/timers-browserify/main.js","webpack:///./~/setimmediate/setImmediate.js","webpack:///./~/maquette/dist/maquette.js","webpack:///./~/@dojo/widget-core/d.js","webpack:///./~/@dojo/widget-core/FactoryRegistry.js","webpack:///./~/@dojo/shim/Map.js","webpack:///./~/@dojo/shim/object.js","webpack:///./src/routes.ts","webpack:///./~/@dojo/routing/createRoute.js","webpack:///./~/@dojo/core/UrlSearchParams.js","webpack:///./~/@dojo/routing/createRouter.js","webpack:///./~/@dojo/compose/bases/createEvented.js","webpack:///./~/@dojo/core/aspect.js","webpack:///./~/@dojo/compose/bases/createDestroyable.js","webpack:///./~/@dojo/core/async/Task.js","webpack:///./~/@dojo/core/async/ExtensiblePromise.js","webpack:///./~/@dojo/core/on.js","webpack:///./~/@dojo/routing/lib/path.js","webpack:///./~/@dojo/routing/history/createHashHistory.js","webpack:///./src/actions/userActions.ts","webpack:///./src/stores/widgetStore.ts","webpack:///./~/@dojo/stores/store/mixins/createObservableStoreMixin.js","webpack:///./~/@dojo/stores/store/createStore.js","webpack:///./~/@dojo/core/Observable.js","webpack:///./~/@dojo/shim/Observable.js","webpack:///./~/@dojo/stores/patch/createPatch.js","webpack:///./~/@dojo/stores/utils.js","webpack:///./~/@dojo/stores/patch/createOperation.js","webpack:///./~/@dojo/stores/patch/createJsonPointer.js","webpack:///./~/@dojo/stores/store/createStoreObservable.js","webpack:///./~/@dojo/stores/storage/createInMemoryStorage.js","webpack:///./~/@dojo/core/uuid.js","webpack:///./~/@dojo/shim/Set.js","webpack:///./~/@dojo/core/util.js","webpack:///./src/actions/todoStoreActions.ts","webpack:///./src/stores/todoStore.ts","webpack:///./src/actions/widgetStoreActions.ts","webpack:///./~/@dojo/stores/query/createFilter.js","webpack:///./src/createApp.ts","webpack:///./~/@dojo/widget-core/createWidgetBase.js","webpack:///./~/@dojo/widget-core/mixins/storeMixin.js","webpack:///./src/utils.ts","webpack:///./src/widgets/createLabel.ts","webpack:///./src/widgets/createTitle.ts","webpack:///./src/widgets/createButton.ts","webpack:///./src/widgets/createTodoItem.ts","webpack:///./src/widgets/createTodoList.ts","webpack:///./src/widgets/createTodoFilter.ts","webpack:///./src/widgets/createTodoFooter.ts","webpack:///./src/widgets/createMainSection.ts","webpack:///./src/widgets/createCheckboxInput.ts","webpack:///./src/widgets/createFocusableTextInput.ts"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Object","prototype","hasOwnProperty","_m","args","slice","fn","b","apply","concat","createProjectorMixin_1","d_1","routes_1","todoStore_1","widgetStore_1","createApp_1","createLabel_1","createTitle_1","createButton_1","createTodoItem_1","createTodoList_1","createTodoFilter_1","createTodoFooter_1","createMainSection_1","createCheckboxInput_1","createFocusableTextInput_1","registry","default","document","getElementsByTagName","app","mixin","properties","store","append","then","bindActions","start","scheduleRender","event","projector","target","projectorData","projectorDataMap","get","state","ProjectorState","Attached","emit","type","attach","instance","_a","render","__render__","bind","attachPromise","Promise_1","resolve","attachHandle","own","destroy","stop","detach","Detached","reject","afterCreate","AttachType","Append","Merge","merge","Replace","replace","global_1","compose_1","WeakMap_1","maquette_1","createProjectorMixin","options","Error","projectorState","nodeAttributes","aspectAdvice","after","result","initialize","body","_b","cssTransitions","maquetteProjectorOptions","transitions","on","invalidate","createProjector","set","defineProperty","value","global","globalObject","window","self","missingMethod","method","TypeError","assignFactoryName","assignFunctionName","Symbol_1","toStringTag","configurable","nameDescriptor","getOwnPropertyDescriptor","writable","assignProperties","overwrite","sources","_i","arguments","length","forEach","source","defineProperties","getOwnPropertyNames","reduce","descriptors","key","sourceDescriptor","sourceValue","targetDescriptor","targetValue","isArray","current","array_1","includes","push","from","objectCreate","rebase","getInitFunctionNames","initFns","privateFactoryData","map","name","factoryDescriptor","className","assignAdviceMap","createPrivateFactoryData","optionsAdvice","advice","factories","initFunction","proto","staticProperties","factoryData","base","optionsInitFns","initFn","lang_1","assign","undefined","Boolean","createFactory","constructor","SyntaxError","unshift","factoryPrototype","_loop_1","aspect","sourceMethod","aspect_1","before","around","staticMethods","DEFAULT_FACTORY_LABEL","freeze","isComposeFactory","extend","extension","instrument_1","deprecated","message","override","baseFactory","keys","overlay","overlayFunction","aspectAdviceToAdviceMap","mapAdvice","adviceTuple","adviceMap","beforeAdvice","afterAdvice","aroundAdvice","objectKeys","isComposeMixinable","toMixin","mixinDescriptor","doFrom","doBefore","doAfter","doAround","create","_static","Array","doExtend","doMixin","doOverride","doOverlay","doAspect","doStatic","doFactoryDescriptor","static","compose","warn","url","has_1","DEFAULT_DEPRECATED_MESSAGE","warning","globalWarn","console","deprecatedAdvice","deprecatedDecorator","propertyKey","descriptor","originalFn_1","setWarn","__export","add","requestAnimationFrame","ArrayBuffer","FormData","XMLHttpRequest","request","open","responseType","abort","has_2","Symbol","fill","Number","POSITIVE_INFINITY","getCallSite","callSite","substitutions","String","raw","supportsTrunc","Math","acosh","clz32","imul","Promise","Observable","Set","has","Map","values","entries","e","WeakMap","key1","key2","setImmediate","postMessage","MutationObserver","WebKitMutationObserver","Function","process","isFeatureTestThenable","isStaticFeatureFunction","load","resourceId","require","config","normalize","skip","term","tokens","match","exists","feature","normalizedFeature","toLowerCase","staticCache","testCache","testFunctions","testThenables","resolvedValue","globalScope","staticFeatures","DojoHasEnvironment","location","versions","node","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","Item","array","noop","nextTick","title","browser","env","argv","version","addListener","once","off","removeListener","removeAllListeners","binding","cwd","chdir","dir","umask","shouldDeepCopyObject","toString","copyArray","inherited","item","_mixin","deep","kwArgs","mixins","RangeError","deepAssign","deepMixin","duplicate","getPrototypeOf","isIdentical","lateBind","suppliedArgs","partial","targetFunction","createHandle","destructor","createCompositeHandle","handles","handles_1","handle","toLength","isNaN","isFinite","floor","min","max","number_1","MAX_SAFE_INTEGER","toInteger","abs","normalizeOffset","Shim","util_1","iterator_1","arrayLike","mapFunction","thisArg","Constructor","isArrayLike","isIterable","forOf","of","items","copyWithin","offset","end","count","direction","find","callback","index","findIndex","searchElement","fromIndex","currentElement","wrapNative","getValueDescriptor","enumerable","nativeFunction","iterator","iterable","ShimIterator","doBreak","broken","next","done","l","char","code","charCodeAt","string_1","HIGH_SURROGATE_MIN","HIGH_SURROGATE_MAX","staticDone","list","_nextIndex","_nativeIterator","_list","LOW_SURROGATE_MIN","LOW_SURROGATE_MAX","normalizeSubstringArgs","text","search","position","isEnd","rawStrings","numSubstitutions","length_1","fromCodePoint","codePoints","fromCharCode","MAX_SIZE","codeUnits","codePoint","isValid","highSurrogate","lowSurrogate","codePointAt","first","second","repeat","Infinity","startsWith","endsWith","endPosition","indexOf","padEnd","maxLength","fillString","strText","padding","padStart","isSymbol","validateSymbol","InternalSymbol","objPrototype","globalSymbols","getSymbolName","created","desc","postfix","description","sym","__description__","__name__","keyFor","hasInstance","for","isConcatSpreadable","observable","species","split","toPrimitive","unscopables","valueOf","Exposed","SymbolShim","wellKnown","isInteger","isSafeInteger","EPSILON","pow","MIN_SAFE_INTEGER","__decorate","decorators","d","r","Reflect","decorate","decorators_1","getUID","random","DELETED","generateName","startId","Date","now","_this","_frozenEntries","_getFrozenEntryIndex","delete","entry","_name","frozenIndex","splice","isFrozen","hasClass","trueClass","falseClass","getDispatcher","joinPoint","dispatcher","dispatchAdviceMap","previousArgs","currentArgs","previousResult","before_1","after_1","advise","AdviceType","Around","Before","After","queue_1","isThenable","executor","isChained","isResolved","callbacks","whenFinished","settle","newState","queueMicroTask","onFulfilled","onRejected","error","all","fulfill","complete","finish","populating","total","processItem","race","reason","catch","clearImmediate","executeTask","isActive","getQueueHandle","microTasks","microTaskQueued","checkMicroTaskQueue","queueTask","enqueue","addEventListener","data","stopPropagation","shift","HostMutationObserver","node_1","createElement","queue_2","observer","observe","attributes","setAttribute","Timeout","clearFn","_id","_clearFn","setInterval","clearInterval","close","unref","ref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","task","tasksByHandle","nextHandle","registerImmediate","runIfPresent","currentlyRunningATask","installNextTickImplementation","canUsePostMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","installPostMessageImplementation","messagePrefix","onGlobalMessage","attachEvent","installMessageChannelImplementation","channel","MessageChannel","port1","port2","installReadyStateChangeImplementation","html","doc","documentElement","script","onreadystatechange","removeChild","appendChild","installSetTimeoutImplementation","attachTo","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","createDom","updateDom","NAMESPACE_W3","NAMESPACE_SVG","NAMESPACE_XLINK","emptyArray","overrides","same","vnode1","vnode2","vnodeSelector","toTextVNode","children","domNode","appendChildren","parentSelector","insertions","main","missingTransition","DEFAULT_PROJECTION_OPTIONS","namespace","eventHandlerInterceptor","styleApplyer","styleName","style","enter","exit","applyDefaultProjectionOptions","projectorOptions","checkStyleValue","styleValue","setProperties","projectionOptions","propNames","propCount","propName","propValue","token","classList","classNames","classNameCount","j","styleNames","styleCount","lastIndexOf","oldPropValue","evt","setAttributeNS","updateProperties","previousProperties","propertiesUpdated","previousValue","previousOn","remove","newStyleValue","oldStyleValue","findIndexOfChild","sameAs","nodeAdded","vNode","enterAnimation","nodeToRemove","exitAnimation","pointerEvents","removeDomNode","parentNode","checkDistinguishable","childNodes","indexToCheck","parentVNode","operation","childNode","updateChildren","vnode","oldChildren","newChildren","oldChildrenLength","newChildrenLength","oldIndex","newIndex","textUpdated","oldChild","newChild","findOldIndex","addChildren","initPropertiesAndChildren","textContent","insertBefore","found","createTextNode","charAt","createElementNS","previous","updated","newVNode","replaceChild","firstChild","afterUpdate","updateAnimation","createProjection","update","updatedVnode","h","selector","childIndex","argsLength","onlyChild","child","dom","beforeNode","element","createCache","cachedInputs","cachedOutcome","inputs","calculation","createMapping","getSourceKey","createResult","updateResult","results","newSources","newKeys","oldTargets","sourceKey","searchIndex","propertyName","eventHandler","scheduled","renderCompleted","stopped","projections","renderFunctions","doRender","renderNow","cancelAnimationFrame","resume","renderMaquetteFunction","isWNode","WNODE","isHNode","HNODE","w","v","tag","propertiesOrChildren","FactoryRegistry_1","Map_1","FactoryRegistry","factoryLabel","registryItem","promise","object_1","_keys","_values","_indexOfKey","is","clear","context","length_2","getOwnPropertyDescriptorsWrapper","o","getOwnPropertySymbols","value1","value2","filter","substring","symbolAwareKeys","prop","hasGetOwnPropertySymbols","getOwnPropertyDescriptors","createRoute_1","createRouter_1","createHashHistory_1","userActions_1","filterRoute","path","params","exec","router","history","computeDefaultParams","parameters","searchParameters","fromPathname","searchParams","UrlSearchParams_1","path_1","privateStateMap","parentMap","createRoute","parent","routes","route","hasBeenAppended","add_1","link","findRouter","segments","hasTrailingSlash","computeParams","trailingSlashMustMatch","hasRemaining","trailingSlash","knownSearchParams","getAll","rawPathValues","rawSearchParams","select","fallback","guard","matchResult","guardResult","redirect","remainingSelection","handler","selected","remainingSegments_1","some","nested","nestedResult","selection","_c","test","deconstructedPath","deconstruct","parseQueryString","input","query","indexOfFirstEquals","decodeURIComponent","UrlSearchParams","encodedKey","encodeURIComponent","values_1","join","createDeferral","cancel","reportError","catchRejection","thenable","createEvented_1","Task_1","on_1","createRouter","dispatch","dispatchFromStart","canceled","deferrals","defer","success","parse","dispatched","currentSelection","result_1","roots","hierarchy","parent_1","addLeadingSlash","leadingSlash","addTrailingSlash","currentPathValues","currentSearchParams","expectedSegments","namedOffset","expectedSegments_1","segment","isNamedSegment","literal","searchParameters_1","value_1","_d","_e","pathname","prefix","replacePath","setPath","dispatchCurrent","started","contextFactory","pause","lastDispatch","redirectCount","redirecting","dispatchResult","listener","pausable","sharedContext_1","isActionable","do","resolveListener","handlesArraytoHandle","createDestroyable_1","listenersMap","createEvented","listenerMap","type_1","listeners","listenerMapArg_1","isMapLike","receiveArguments","advised","nextId","methodName","existing","executionId","newResults","destroyed","isDestroyable","handlesWeakMap","createDestroyable","isTask","__extends","__","ExtensiblePromise_1","Task","_super","canceler","superResolve","superReject","_state","_cancel","finallyTask","runFinally","_finally","finally","unwrapPromises","unwrapped","ExtensiblePromise","_promise","promiseKeys_1","promiseResults","returnValue","rejected","valueOrError","dispatchEvent","ownerDocument","createEvent","nativeEvent","initEvent","bubbles","cancelable","capture","removeEventListener","paused","pathnameTokens","searchStart","hashStart","t","isMatch","expected","consume","peek","inSearchComponent","name_1","closing","separator","next_1","createHashHistory","privateState","browserLocation","hash","toggleEditing","todos","todoId","editing","todo","todoStoreActions_1","todoInput","which","label","addTodo","completed","patch","todoEdit","todoListState","todoEditInput","todoSave","updateTodo","deleteTodo","todoRemove","todoToggleComplete","activeFilter","todoToggleAll","toggleAll","checked","clearCompleted","deleteCompleted","createObservableStoreMixin_1","createObservableStore","completedCount","activeCount","allCompleted","mergeDeltas","currentUpdate","newUpdate","takeLastItem","ids","identify","reverse","_","takeLastId","removeOutdatedItems","newDeletes","oldUpdates","deletedIds","prev","removeCancellingUpdates","oldAdds","addIds","convertReplacementToUpdate","oldDeletes","newAdds","newUpdates","deletes","updateIds","adds","updatedUpdates","shouldKeep","updates","beforeAll","afterAll","addUpdateDelete","newData","localIndex","sort","buildIndex","sendUpdates","instanceStateMap","storeDelta","queuedUpdate","localData","observers","isObserverEntry","observes","Set_1","isObserver","notifyItemObservers","notify","itemObservers","observerOrEntry","observerEntry","sendUpdatesOrFetch","fetchAroundUpdates","fetchAndSendUpdates","createObservableStoreMixin","idOrIds","self_1","state_1","ids_1","idSet_1","Observable_1","foundIds","itemUpdate","size","retrievedIdSet_1","missingItemIds","id_1","storeObservable","fetch","initialFetch","put","updatedItems","isFirstAdd","addedItems","deleted","debounce","fetchAroundUpdateDebounce","createStore_1","isPatchArray","patches","isPatch","patchObj","operations","createStoreObservable","storeResultsPromise","createStoreObservable_1","successfulData","createPatch_1","createInMemoryStorage_1","createStore","initialAddPromise","storage","patchEntries","diff","dupe","idInOptions","resolveTotalLength","rejectTotalLength","totalLength","fetchResult","dataLength","createId","instanceState","isSubscribable","object","subscribe","deferFunction","trueObservable","errorValue","completeValue","toPromise","filterFunction","toArray","mergeAll","concurrent","checkForComplete","itemIndex_1","nonEnumerable","startSubscription","unsubscribe","closed","cleanUp","subscriptionObserver","subscription","cleanUpError","observerError","errorResult","observerComplete","completeResult","ShimObservable","subscriber","_executor","observerOrNext","onError","onComplete","observableSymbol","_diff","to","startingPath","utils_1","shouldRecurseInto","createJsonPointer_1","fromKeys","toKeys","isEqual","createOperation_1","createPatch","every","keysForA","keysforB","navigatePath","currentPath","lastSegment","pathSegments","property","applyTo","copyOrMove","toDelete","moveFrom","move","copy","getPath","jsonObj","op","JSON","stringify","createOperation","oldValue","navigate","decode","encode","createJsonPointer","pop","transform","Rx","putSync","oldIndices","newIds","newItems","rejectOverwrite","uuid_1","createInMemoryStorage","itemArray","idProperty","idProperty_1","idFunction","fullData","returnPromise","returnsPromise","objects","result_2","idsToRemove","indices","indexArrayIndex","firstInvalidIndex_1","updateIndexForIds","filteredUpdates","updatedItems_1","updatedItem","isUpdate","uuid","_setData","idx","callbackfn","createTimer","delay","timerId","timer","throttle","ran","throttleAfter","createFilter_1","equalTo","todoStore","widgetStoreActions_1","putTodo","isBooleanOp","isFilter","filterOrFunction","createFilterOrReturnOp","descriptorOrOp","createComparator","filterType","createFilter","filterDescriptors","serializer","filters","descriptorChainMember","createFilterHelper","serializeFilter","comparatorFilterHelper","needsOperator","newFilters","applyFilterChain","filterChain","filterSerializer","and","newFilter","or","lessThan","lessThanOrEqualTo","greaterThan","greaterThanOrEqualTo","matches","in","contains","deepEqualTo","notEqualTo","notDeepEqualTo","custom","queryType","incremental","ordFilterSections","startOfSlice","chainMember","filterOrAnd","operator","operatorString","propertyOrItem","propertyValue","createWidgetBase_1","storeMixin_1","createApp","classes","tagName","getChildrenNodes","todoFooterProperties","focused","placeholder","onKeyUp","getFromRegistry","dNodeToVNode","dNode","internalState","widgetInternalStateMap","factory_1","initializedFactoryMap","cachedChild_1","childrenMapKey","cachedChildren","cachedChildrenMap","cachedChildWrapper","used","errorMsg","setChildren","manageDetachedChildren","filterCachedChildren","cachedChild","formatTagNameAndClasses","propertyFunctionNameRegex","createWidget","getNode","getNodeAttributes","props","newProps","dirty","diffPropertyResults","diffPropertyChangedKeys","diffPropertyFunctionMap","diffFunctionName","previousProperty","newProperty","changed","diffPropertiesResult","diffProperties","changedPropertyKeys","changedKeys","newProperties","baseIdProp","data-widget-id","styles","widgetClasses","cachedVNode","widget","attribute","replaceState","stateMap","eventObject","stateChangedEventType","onPropertiesChanged","internalStateMap","storeMixinFactory","err","setState","createLabel","onDblclick","onKeypress","innerHTML","aria-describedby","tabindex","onkeyup","ondblclick","createTitle","createButton","onClick","onclick","createTodoItem","onChange","onBlur","filterName","createTodoList","createFilterItems","filterItem","toUpperCase","href","createTodoFilter","createTodoFooter","countLabel","class","createMainSection","createCheckboxInput","onchange","createFocusableTextInput","focus","activeElement","blur","onblur"],"mappings":"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","file":"src/main.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ((function(modules) {\n\t// Check all modules for deduplicated modules\n\tfor(var i in modules) {\n\t\tif(Object.prototype.hasOwnProperty.call(modules, i)) {\n\t\t\tswitch(typeof modules[i]) {\n\t\t\tcase \"function\": break;\n\t\t\tcase \"object\":\n\t\t\t\t// Module can be created from a template\n\t\t\t\tmodules[i] = (function(_m) {\n\t\t\t\t\tvar args = _m.slice(1), fn = modules[_m[0]];\n\t\t\t\t\treturn function (a,b,c) {\n\t\t\t\t\t\tfn.apply(this, [a,b,c].concat(args));\n\t\t\t\t\t};\n\t\t\t\t}(modules[i]));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Module is a copy of another module\n\t\t\t\tmodules[i] = modules[modules[i]];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn modules;\n}([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\tmodule.exports = __webpack_require__(3);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 2 */,\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createProjectorMixin_1 = __webpack_require__(4);\n\tvar d_1 = __webpack_require__(28);\n\tvar routes_1 = __webpack_require__(32);\n\tvar todoStore_1 = __webpack_require__(60);\n\tvar widgetStore_1 = __webpack_require__(45);\n\tvar createApp_1 = __webpack_require__(63);\n\tvar createLabel_1 = __webpack_require__(67);\n\tvar createTitle_1 = __webpack_require__(68);\n\tvar createButton_1 = __webpack_require__(69);\n\tvar createTodoItem_1 = __webpack_require__(70);\n\tvar createTodoList_1 = __webpack_require__(71);\n\tvar createTodoFilter_1 = __webpack_require__(72);\n\tvar createTodoFooter_1 = __webpack_require__(73);\n\tvar createMainSection_1 = __webpack_require__(74);\n\tvar createCheckboxInput_1 = __webpack_require__(75);\n\tvar createFocusableTextInput_1 = __webpack_require__(76);\n\t__webpack_require__(77);\n\td_1.registry.define('label', createLabel_1.default);\n\td_1.registry.define('title', createTitle_1.default);\n\td_1.registry.define('button', createButton_1.default);\n\td_1.registry.define('todo-item', createTodoItem_1.default);\n\td_1.registry.define('todo-list', createTodoList_1.default);\n\td_1.registry.define('todo-filter', createTodoFilter_1.default);\n\td_1.registry.define('todo-footer', createTodoFooter_1.default);\n\td_1.registry.define('main-section', createMainSection_1.default);\n\td_1.registry.define('checkbox', createCheckboxInput_1.default);\n\td_1.registry.define('text-input', createFocusableTextInput_1.default);\n\tvar root = document.getElementsByTagName('my-app')[0];\n\tvar app = createApp_1.default.mixin(createProjectorMixin_1.default)({\n\t    properties: {\n\t        id: 'todo-app',\n\t        store: widgetStore_1.default\n\t    },\n\t    root: root\n\t});\n\tapp.append()\n\t    .then(function () { return todoStore_1.bindActions(); })\n\t    .then(function () { return routes_1.default.start(); });\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar global_1 = __webpack_require__(5);\n\tvar compose_1 = __webpack_require__(6);\n\tvar Promise_1 = __webpack_require__(23);\n\tvar WeakMap_1 = __webpack_require__(20);\n\tvar maquette_1 = __webpack_require__(27);\n\t/**\n\t * Represents the state of the projector\n\t */\n\tvar ProjectorState;\n\t(function (ProjectorState) {\n\t    ProjectorState[ProjectorState[\"Attached\"] = 1] = \"Attached\";\n\t    ProjectorState[ProjectorState[\"Detached\"] = 2] = \"Detached\";\n\t})(ProjectorState = exports.ProjectorState || (exports.ProjectorState = {}));\n\t/**\n\t * Attach type for the projector\n\t */\n\tvar AttachType;\n\t(function (AttachType) {\n\t    AttachType[AttachType[\"Append\"] = 1] = \"Append\";\n\t    AttachType[AttachType[\"Merge\"] = 2] = \"Merge\";\n\t    AttachType[AttachType[\"Replace\"] = 3] = \"Replace\";\n\t})(AttachType = exports.AttachType || (exports.AttachType = {}));\n\t/**\n\t * Private state map keyed by instance.\n\t */\n\tvar projectorDataMap = new WeakMap_1.default();\n\t/**\n\t * Schedules a render.\n\t */\n\tfunction scheduleRender(event) {\n\t    var projector = event.target;\n\t    var projectorData = projectorDataMap.get(projector);\n\t    if (projectorData.state === ProjectorState.Attached) {\n\t        projector.emit({\n\t            type: 'render:scheduled',\n\t            target: projector\n\t        });\n\t        projectorData.projector.scheduleRender();\n\t    }\n\t}\n\tfunction attach(instance, _a) {\n\t    var type = _a.type;\n\t    var projectorData = projectorDataMap.get(instance);\n\t    var render = instance.__render__.bind(instance);\n\t    if (projectorData.state === ProjectorState.Attached) {\n\t        return projectorData.attachPromise || Promise_1.default.resolve({});\n\t    }\n\t    projectorData.state = ProjectorState.Attached;\n\t    projectorData.attachHandle = instance.own({\n\t        destroy: function () {\n\t            if (projectorData.state === ProjectorState.Attached) {\n\t                projectorData.projector.stop();\n\t                projectorData.projector.detach(render);\n\t                projectorData.state = ProjectorState.Detached;\n\t            }\n\t            projectorData.attachHandle = { destroy: function () { } };\n\t        }\n\t    });\n\t    projectorData.attachPromise = new Promise_1.default(function (resolve, reject) {\n\t        projectorData.afterCreate = function () {\n\t            instance.emit({\n\t                type: 'projector:attached',\n\t                target: instance\n\t            });\n\t            resolve(projectorData.attachHandle);\n\t        };\n\t    });\n\t    switch (type) {\n\t        case AttachType.Append:\n\t            projectorData.projector.append(projectorData.root, render);\n\t            break;\n\t        case AttachType.Merge:\n\t            projectorData.projector.merge(projectorData.root, render);\n\t            break;\n\t        case AttachType.Replace:\n\t            projectorData.projector.replace(projectorData.root, render);\n\t            break;\n\t    }\n\t    return projectorData.attachPromise;\n\t}\n\tvar createProjectorMixin = compose_1.default({\n\t    append: function () {\n\t        var options = {\n\t            type: AttachType.Append\n\t        };\n\t        return attach(this, options);\n\t    },\n\t    merge: function () {\n\t        var options = {\n\t            type: AttachType.Merge\n\t        };\n\t        return attach(this, options);\n\t    },\n\t    replace: function () {\n\t        var options = {\n\t            type: AttachType.Replace\n\t        };\n\t        return attach(this, options);\n\t    },\n\t    set root(root) {\n\t        var projectorData = projectorDataMap.get(this);\n\t        if (projectorData.state === ProjectorState.Attached) {\n\t            throw new Error('Projector already attached, cannot change root element');\n\t        }\n\t        projectorData.root = root;\n\t    },\n\t    get root() {\n\t        var projectorData = projectorDataMap.get(this);\n\t        return projectorData && projectorData.root;\n\t    },\n\t    get projector() {\n\t        return projectorDataMap.get(this).projector;\n\t    },\n\t    get projectorState() {\n\t        var projectorData = projectorDataMap.get(this);\n\t        return projectorData && projectorData.state;\n\t    }\n\t}).mixin({\n\t    mixin: {\n\t        nodeAttributes: [\n\t            function () {\n\t                var afterCreate = projectorDataMap.get(this).afterCreate;\n\t                return { afterCreate: afterCreate };\n\t            }\n\t        ]\n\t    },\n\t    aspectAdvice: {\n\t        after: {\n\t            __render__: function (result) {\n\t                if (typeof result === 'string' || result === null) {\n\t                    throw new Error('Must provide a VNode at the root of a projector');\n\t                }\n\t                return result;\n\t            }\n\t        }\n\t    }\n\t}).mixin({\n\t    initialize: function (instance, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var _a = options.root, root = _a === void 0 ? document.body : _a, _b = options.cssTransitions, cssTransitions = _b === void 0 ? false : _b;\n\t        var maquetteProjectorOptions = {};\n\t        if (cssTransitions) {\n\t            if (global_1.default.cssTransitions) {\n\t                maquetteProjectorOptions.transitions = global_1.default.cssTransitions;\n\t            }\n\t            else {\n\t                throw new Error('Unable to create projector with css transitions enabled. Is the \\'css-transition.js\\' script loaded in the page?');\n\t            }\n\t        }\n\t        instance.own(instance.on('widget:children', instance.invalidate));\n\t        instance.own(instance.on('invalidated', scheduleRender));\n\t        var projector = maquette_1.createProjector(maquetteProjectorOptions);\n\t        projectorDataMap.set(instance, {\n\t            projector: projector,\n\t            root: root,\n\t            state: ProjectorState.Detached\n\t        });\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createProjectorMixin;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\tvar globalObject = (function () {\n\t    if (typeof window !== 'undefined') {\n\t        // Browsers\n\t        return window;\n\t    }\n\t    else if (typeof global !== 'undefined') {\n\t        // Node\n\t        return global;\n\t    }\n\t    else if (typeof self !== 'undefined') {\n\t        // Web workers\n\t        return self;\n\t    }\n\t    return {};\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = globalObject;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar instrument_1 = __webpack_require__(7);\n\tvar lang_1 = __webpack_require__(13);\n\tvar array_1 = __webpack_require__(14);\n\tvar WeakMap_1 = __webpack_require__(20);\n\tvar Symbol_1 = __webpack_require__(18);\n\tvar aspect_1 = __webpack_require__(22);\n\t/**\n\t * The default factory label if no label can be derived during the factory creation process\n\t */\n\tvar DEFAULT_FACTORY_LABEL = 'Compose';\n\t/* References to support minification */\n\tvar defineProperty = Object.defineProperty;\n\tvar isArray = Array.isArray;\n\tvar objectCreate = Object.create;\n\tvar objectKeys = Object.keys;\n\t/**\n\t * A weakmap that stores all the private data for a factory\n\t */\n\tvar privateFactoryData = new WeakMap_1.default();\n\t/**\n\t * An internal function which stubs out a method which, when called at runtime, throws.\n\t *\n\t * @param method The name of \"abstract\" method being called\n\t */\n\tfunction missingMethod(method) {\n\t    return function throwOnMissingMethod() {\n\t        throw new TypeError(\"Advice being applied to missing method named: \" + method);\n\t    };\n\t}\n\t/**\n\t * Internal function which can label a factory with a name and also sets\n\t * the `toString()` method on the prototype to return the approriate\n\t * name for instances.\n\t *\n\t * @param fn The name of the factory to label\n\t * @param value The name to supply for the label\n\t */\n\tfunction assignFactoryName(factory, value) {\n\t    if (typeof factory === 'function' && factory.prototype) {\n\t        assignFunctionName(factory, value);\n\t        defineProperty(factory.prototype, Symbol_1.default.toStringTag, {\n\t            get: function () {\n\t                return value;\n\t            },\n\t            configurable: true\n\t        });\n\t    }\n\t}\n\t/**\n\t * Internal function which can label a function with a name\n\t */\n\tfunction assignFunctionName(fn, value) {\n\t    var nameDescriptor = Object.getOwnPropertyDescriptor(fn, 'name');\n\t    if (typeof nameDescriptor === 'undefined' || nameDescriptor.configurable) {\n\t        defineProperty(fn, 'name', {\n\t            value: value,\n\t            writable: true,\n\t            configurable: true\n\t        });\n\t    }\n\t}\n\t/**\n\t * A helper function that copies own properties and their descriptors\n\t * from one or more sources to a target object. Includes non-enumerable properties\n\t *\n\t * @param overwrite If `true` properties, like arrays, will not be merged, instead overwritten\n\t * @param target The target that properties should be copied onto\n\t * @param sources The rest of the parameters treated as sources to apply\n\t */\n\tfunction assignProperties(overwrite, target) {\n\t    var sources = [];\n\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t        sources[_i - 2] = arguments[_i];\n\t    }\n\t    sources.forEach(function (source) {\n\t        if (!source) {\n\t            return;\n\t        }\n\t        Object.defineProperties(target, Object.getOwnPropertyNames(source).reduce(function (descriptors, key) {\n\t            if (key !== 'constructor') {\n\t                var sourceDescriptor = Object.getOwnPropertyDescriptor(source, key);\n\t                var sourceValue = sourceDescriptor && sourceDescriptor.value;\n\t                var targetDescriptor = Object.getOwnPropertyDescriptor(target, key);\n\t                var targetValue = targetDescriptor && targetDescriptor.value;\n\t                /* Special handling to merge array proprties */\n\t                if (!overwrite && isArray(sourceValue) && isArray(targetValue)) {\n\t                    sourceDescriptor.value = sourceValue.reduce(function (value, current) {\n\t                        if (!array_1.includes(target[key], current)) {\n\t                            value.push(current);\n\t                        }\n\t                        return value;\n\t                    }, array_1.from(targetValue));\n\t                }\n\t                descriptors[key] = sourceDescriptor;\n\t            }\n\t            return descriptors;\n\t        }, objectCreate(null)));\n\t    });\n\t    return target;\n\t}\n\t/**\n\t * A helper funtion to return a function that is rebased to infer that the\n\t * first argument of the passed function will be the `this` when the function\n\t * is executed.\n\t *\n\t * @param  fn The function to be rebased\n\t * @return    The rebased function\n\t */\n\tfunction rebase(fn) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return fn.apply(this, [this].concat(args));\n\t    };\n\t}\n\t/**\n\t * For a given factory, return the names of the initialization functions that will be\n\t * invoked upon construction.\n\t *\n\t * @param factory The factory that the array of function names should be returned for\n\t */\n\tfunction getInitFunctionNames(factory) {\n\t    var initFns = privateFactoryData.get(factory).initFns;\n\t    if (initFns) {\n\t        return initFns.map(function (fn) { return fn.name; });\n\t    }\n\t}\n\texports.getInitFunctionNames = getInitFunctionNames;\n\t/* The rebased functions we need to decorate compose constructors with */\n\t/**\n\t * Perform an extension of a class\n\t *\n\t * @deprecated\n\t */\n\tvar doExtend = rebase(extend);\n\t/**\n\t * Perform a mixin of a class\n\t */\n\tvar doMixin = rebase(mixin);\n\t/**\n\t * Perform a override of a class\n\t */\n\tvar doOverride = rebase(override);\n\t/**\n\t * Perform an overlay of a class\n\t */\n\tvar doOverlay = rebase(overlay);\n\t/**\n\t * Apply aspect advice to a class\n\t */\n\tvar doAspect = rebase(aspect);\n\t/**\n\t * Add static method/properties to a class\n\t */\n\tvar doStatic = rebase(_static);\n\t/**\n\t * Take a mixin and return a factory descriptor for the mixin\n\t *\n\t * @param mixin The factory to return the descriptor for\n\t * @template T The outer type of the descriptor\n\t * @template O The outer factory options of the descriptor\n\t * @template U The inner type of the descriptor\n\t * @template P The inner factory options of the descriptor\n\t */\n\tfunction factoryDescriptor(mixin) {\n\t    return {\n\t        mixin: mixin,\n\t        className: mixin.name\n\t    };\n\t}\n\t/**\n\t * Generate a factory descriptor for a class\n\t */\n\tvar doFactoryDescriptor = rebase(factoryDescriptor);\n\t/**\n\t * A set of functions that are used to decorate the compose factories\n\t */\n\tvar staticMethods = {\n\t    extend: doExtend,\n\t    mixin: doMixin,\n\t    override: doOverride,\n\t    overlay: doOverlay,\n\t    from: doFrom,\n\t    before: doBefore,\n\t    after: doAfter,\n\t    around: doAround,\n\t    aspect: doAspect,\n\t    factoryDescriptor: doFactoryDescriptor,\n\t    static: doStatic\n\t};\n\t/**\n\t * Internal function that merges (or creates) an advice map\n\t *\n\t * @param sources The advice maps to be merged into a single one\n\t */\n\tfunction assignAdviceMap() {\n\t    var sources = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        sources[_i] = arguments[_i];\n\t    }\n\t    var result = {};\n\t    sources.forEach(function (source) {\n\t        if (source) {\n\t            for (var method in source) {\n\t                result[method] = result[method] ? result[method].concat(source[method]) : source[method].slice();\n\t            }\n\t        }\n\t    });\n\t    return result;\n\t}\n\t/**\n\t * An internal function that takes a set of create widget options and returns a set of private factory data\n\t *\n\t * @param options The set of factory options to use in creating the private factory data\n\t */\n\tfunction createPrivateFactoryData(_a) {\n\t    var optionsAdvice = _a.advice, factories = _a.factories, initFunction = _a.initFunction, overwrite = _a.overwrite, proto = _a.proto, staticProperties = _a.staticProperties;\n\t    var factoryData = (factories || []).reduce(function (factoryData, factory) {\n\t        var _a = privateFactoryData.get(factory), advice = _a.advice, base = _a.base, initFns = _a.initFns;\n\t        if (advice) {\n\t            factoryData.advice = assignAdviceMap(factoryData.advice, advice);\n\t        }\n\t        if (base) {\n\t            assignProperties(false, factoryData.base, base);\n\t        }\n\t        var optionsInitFns = factoryData.initFns;\n\t        initFns.forEach(function (initFn) {\n\t            if (!array_1.includes(optionsInitFns, initFn)) {\n\t                optionsInitFns.push(initFn);\n\t            }\n\t        });\n\t        return factoryData;\n\t    }, {\n\t        base: {},\n\t        initFns: [],\n\t        staticProperties: staticProperties ? lang_1.assign({}, staticProperties) : undefined\n\t    });\n\t    if (initFunction) {\n\t        factoryData.initFns.push(initFunction);\n\t    }\n\t    if (optionsAdvice) {\n\t        factoryData.advice = assignAdviceMap(factoryData.advice, optionsAdvice);\n\t    }\n\t    assignProperties(Boolean(overwrite), factoryData.base, proto);\n\t    return factoryData;\n\t}\n\tfunction createFactory(options) {\n\t    /**\n\t     * A compose factory\n\t     */\n\t    function factory() {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        if (this && this.constructor === factory) {\n\t            throw new SyntaxError('Factories cannot be called with \"new\".');\n\t        }\n\t        var instance = objectCreate(factory.prototype);\n\t        /* clone any arrays in the instance */\n\t        for (var key in instance) {\n\t            if (isArray(Object.getOwnPropertyDescriptor(factory.prototype, key).value)) {\n\t                instance[key] = array_1.from(instance[key]);\n\t            }\n\t        }\n\t        args.unshift(instance);\n\t        privateFactoryData.get(factory).initFns.forEach(function (fn) {\n\t            fn.apply(null, args);\n\t        });\n\t        return instance;\n\t    }\n\t    var factoryData = createPrivateFactoryData(options);\n\t    privateFactoryData.set(factory, factoryData);\n\t    var factoryPrototype = factory.prototype;\n\t    /* mixin base properties into the prototype */\n\t    assignProperties(false, factoryPrototype, factoryData.base);\n\t    /* apply any advice to the prototype */\n\t    if (factoryData.advice) {\n\t        var _loop_1 = function (method) {\n\t            factoryData.advice[method].forEach(function (_a) {\n\t                var aspect = _a[0], advice = _a[1];\n\t                var sourceMethod = factoryPrototype[method] || missingMethod(method);\n\t                switch (aspect) {\n\t                    case 'before':\n\t                        factoryPrototype[method] = aspect_1.before(sourceMethod, advice);\n\t                        break;\n\t                    case 'after':\n\t                        factoryPrototype[method] = aspect_1.after(sourceMethod, advice);\n\t                        break;\n\t                    case 'around':\n\t                        factoryPrototype[method] = aspect_1.around(sourceMethod, advice);\n\t                }\n\t            });\n\t        };\n\t        for (var method in factoryData.advice) {\n\t            _loop_1(method);\n\t        }\n\t    }\n\t    /* assign a constructor to the prototype */\n\t    factoryPrototype.constructor = factory;\n\t    /* assign static methods/properties */\n\t    lang_1.assign(factory, staticMethods, factoryData.staticProperties);\n\t    /* assign factory name */\n\t    var className = options.className ||\n\t        (options.factories && options.factories[0] && options.factories[0].name) ||\n\t        DEFAULT_FACTORY_LABEL;\n\t    assignFactoryName(factory, className);\n\t    /* freeze the factory, so it cannot be accidently modified */\n\t    Object.freeze(factory);\n\t    return factory;\n\t}\n\t/**\n\t * A custom type guard that determines if the value is a ComposeFactory\n\t *\n\t * @param   value The target to check\n\t * @returns       Return true if it is a ComposeFactory, otherwise false\n\t */\n\tfunction isComposeFactory(value) {\n\t    return Boolean(value && privateFactoryData.get(value));\n\t}\n\texports.isComposeFactory = isComposeFactory;\n\tfunction extend(base, className, extension) {\n\t    instrument_1.deprecated({ message: 'This function will be removed, use \"override\" instead.', name: 'extend' });\n\t    if (typeof className !== 'string') {\n\t        extension = className;\n\t        className = undefined;\n\t    }\n\t    return createFactory({\n\t        className: className,\n\t        proto: typeof extension === 'function' ? extension.prototype : extension,\n\t        factories: [base]\n\t    });\n\t}\n\tfunction override(baseFactory, className, properties) {\n\t    if (typeof className !== 'string') {\n\t        properties = className;\n\t        className = undefined;\n\t    }\n\t    if (typeof properties !== 'object') {\n\t        throw new TypeError('Argument \"properties\" must be an object.');\n\t    }\n\t    var base = privateFactoryData.get(baseFactory).base;\n\t    /* TODO: In TypeScript 2.1 we have merge types which can then be used to provide type checking at design time\n\t     * similiar to this */\n\t    Object.keys(properties).forEach(function (key) {\n\t        if (!(key in base)) {\n\t            throw new TypeError(\"Attempting to override missing property \\\"\" + key + \"\\\"\");\n\t        }\n\t    });\n\t    return createFactory({\n\t        className: className,\n\t        overwrite: true,\n\t        proto: properties,\n\t        factories: [baseFactory]\n\t    });\n\t}\n\t/**\n\t * Internal implementation of the overlay functionality, to allow a function to modify a\n\t * compose factory prototype\n\t *\n\t * @param base The target compose factory\n\t * @param overlayFunction The callback function that will modify the prototype of the factory\n\t */\n\tfunction overlay(base, overlayFunction) {\n\t    var factory = createFactory({\n\t        factories: [base]\n\t    });\n\t    overlayFunction(factory.prototype);\n\t    return factory;\n\t}\n\t/**\n\t * Internal function that converts `AspectAdvice` into `AdviceMap` which can then be used for\n\t * creating a factory\n\t *\n\t * @param aspectAdvice The aspect advice to convert into an advice map\n\t */\n\tfunction aspectAdviceToAdviceMap(aspectAdvice) {\n\t    if (!aspectAdvice) {\n\t        return;\n\t    }\n\t    var adviceMap = {};\n\t    var beforeAdvice = aspectAdvice.before;\n\t    var afterAdvice = aspectAdvice.after;\n\t    var aroundAdvice = aspectAdvice.around;\n\t    function mapAdvice(type, key, advice) {\n\t        var adviceTuple = [type, advice[key]];\n\t        if (adviceMap[key]) {\n\t            adviceMap[key].push(adviceTuple);\n\t        }\n\t        else {\n\t            adviceMap[key] = [adviceTuple];\n\t        }\n\t    }\n\t    if (beforeAdvice) {\n\t        objectKeys(beforeAdvice).forEach(function (key) {\n\t            /* TODO: Remove ! in 2.1 */\n\t            mapAdvice('before', key, beforeAdvice);\n\t        });\n\t    }\n\t    if (afterAdvice) {\n\t        objectKeys(afterAdvice).forEach(function (key) {\n\t            /* TODO: Remove ! in 2.1 */\n\t            mapAdvice('after', key, afterAdvice);\n\t        });\n\t    }\n\t    if (aroundAdvice) {\n\t        objectKeys(aroundAdvice).forEach(function (key) {\n\t            /* TODO: Remove ! in 2.1 */\n\t            mapAdvice('around', key, aroundAdvice);\n\t        });\n\t    }\n\t    return adviceMap;\n\t}\n\t/**\n\t * A custom type guard that determines if a value is ComposeMixinable\n\t *\n\t * @param value The value to guard for\n\t */\n\tfunction isComposeMixinable(value) {\n\t    return Boolean(value && 'factoryDescriptor' in value && typeof value.factoryDescriptor === 'function');\n\t}\n\t/**\n\t * The internal implementation of mixin in values into a compose factory\n\t *\n\t * @param base The base compose factory that is the target for being mixed in\n\t * @param toMixin The value to be mixed in\n\t */\n\tfunction mixin(base, toMixin) {\n\t    /* ensure we are dealing with a mixinDescriptor */\n\t    var mixinDescriptor = isComposeMixinable(toMixin) ? toMixin.factoryDescriptor() : toMixin;\n\t    /* destructure out most of the factory creation options */\n\t    var mixin = mixinDescriptor.mixin, initFunction = mixinDescriptor.initialize, aspectAdvice = mixinDescriptor.aspectAdvice, className = mixinDescriptor.className;\n\t    /* we will at least be using the base factory to create the new one */\n\t    var factories = [base];\n\t    var proto;\n\t    /* if mixin is a compose factory, we will pass it as a factory used to create the new factory */\n\t    if (isComposeFactory(mixin)) {\n\t        factories.push(mixin);\n\t    }\n\t    else {\n\t        /* of which, we can have a constructor function/class, or an object literal (or undefined) */\n\t        proto = typeof mixin === 'function' ? mixin.prototype : mixin;\n\t    }\n\t    /* convert the advice, if any, to the format used by createFactory */\n\t    var advice = aspectAdviceToAdviceMap(aspectAdvice);\n\t    /* label the initFn */\n\t    if (initFunction) {\n\t        assignFunctionName(initFunction, \"mixin\" + (className || (isComposeFactory(mixin) && mixin.name) || base.name));\n\t    }\n\t    /* return the newly created factory */\n\t    return createFactory({\n\t        advice: advice,\n\t        factories: factories,\n\t        initFunction: initFunction,\n\t        className: className,\n\t        proto: proto\n\t    });\n\t}\n\t/**\n\t * Internal implementation of extracting methods from another object\n\t *\n\t * @param base The target that the method should be extracted from\n\t * @param method The name of the method\n\t */\n\tfunction from(base, method) {\n\t    return base.prototype[method];\n\t}\n\t/**\n\t * Internal implementation to apply from when `this` represents the base\n\t *\n\t * @param base The target that the method should be extracted from\n\t * @param method The name of the method\n\t */\n\tfunction doFrom(base, method) {\n\t    return createFactory({\n\t        factories: [this],\n\t        proto: (_a = {},\n\t            _a[method] = base.prototype[method],\n\t            _a)\n\t    });\n\t    var _a;\n\t}\n\tfunction before() {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i] = arguments[_i];\n\t    }\n\t    var base;\n\t    var method;\n\t    var advice;\n\t    if (args.length >= 3) {\n\t        base = args[0], method = args[1], advice = args[2];\n\t        method = base.prototype[method];\n\t    }\n\t    else {\n\t        method = args[0], advice = args[1];\n\t    }\n\t    return aspect_1.before(method, advice);\n\t}\n\t/**\n\t * The internal implementation to apply before advice when `this` is scoped as the base factory\n\t *\n\t * @param method The name of the method that the advice should be applied to\n\t * @param advice The advice to apply\n\t */\n\tfunction doBefore(method, advice) {\n\t    return createFactory({\n\t        factories: [this],\n\t        advice: (_a = {},\n\t            _a[method] = [['before', advice]],\n\t            _a)\n\t    });\n\t    var _a;\n\t}\n\tfunction after() {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i] = arguments[_i];\n\t    }\n\t    var base;\n\t    var method;\n\t    var advice;\n\t    if (args.length >= 3) {\n\t        base = args[0], method = args[1], advice = args[2];\n\t        method = base.prototype[method];\n\t    }\n\t    else {\n\t        method = args[0], advice = args[1];\n\t    }\n\t    return aspect_1.after(method, advice);\n\t}\n\t/**\n\t * The internal implementation to apply after advice when `this` is scoped as the base factory\n\t *\n\t * @param method The name of the method that the advice should be applied to\n\t * @param advice The advice to apply\n\t */\n\tfunction doAfter(method, advice) {\n\t    return createFactory({\n\t        factories: [this],\n\t        advice: (_a = {},\n\t            _a[method] = [['after', advice]],\n\t            _a)\n\t    });\n\t    var _a;\n\t}\n\tfunction around() {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i] = arguments[_i];\n\t    }\n\t    var base;\n\t    var method;\n\t    var advice;\n\t    if (args.length >= 3) {\n\t        base = args[0], method = args[1], advice = args[2];\n\t        method = base.prototype[method];\n\t    }\n\t    else {\n\t        method = args[0], advice = args[1];\n\t    }\n\t    return aspect_1.around(method, advice);\n\t}\n\t/**\n\t * The internal implementation to apply around advice when `this` is scoped as the base factory\n\t *\n\t * @param method The name of the method that the advice should be applied to\n\t * @param advice The advice to apply\n\t */\n\tfunction doAround(method, advice) {\n\t    return createFactory({\n\t        factories: [this],\n\t        advice: (_a = {},\n\t            _a[method] = [['around', advice]],\n\t            _a)\n\t    });\n\t    var _a;\n\t}\n\t/**\n\t * The internal implementation of applying aspect advice to a factory\n\t *\n\t * @param base The base factory the advice should be applied to\n\t * @param advice The advice map to apply to the factory\n\t */\n\tfunction aspect(base, advice) {\n\t    return createFactory({\n\t        factories: [base],\n\t        advice: aspectAdviceToAdviceMap(advice)\n\t    });\n\t}\n\tfunction create(className, base, initFunction) {\n\t    /* disambugate arguments */\n\t    if (typeof className !== 'string') {\n\t        initFunction = base;\n\t        base = className;\n\t        className = undefined;\n\t    }\n\t    /* Label the initFunction */\n\t    if (initFunction && className) {\n\t        assignFunctionName(initFunction, \"init\" + className);\n\t    }\n\t    var factories;\n\t    var proto;\n\t    /* If base is a compose factory, set it as the factory array */\n\t    if (base && isComposeFactory(base)) {\n\t        factories = [base];\n\t    }\n\t    else {\n\t        proto = typeof base === 'function' ? base.prototype : base;\n\t    }\n\t    return createFactory({\n\t        className: className,\n\t        factories: factories,\n\t        initFunction: initFunction,\n\t        proto: proto\n\t    });\n\t}\n\t/**\n\t * Internal implementation of applying static properties to a compose factory\n\t *\n\t * @param factory The factory that the static properties should be applied to\n\t * @param staticProperties The properties to be applied to the factory\n\t */\n\tfunction _static(base, staticProperties) {\n\t    return createFactory({\n\t        factories: [base],\n\t        staticProperties: staticProperties\n\t    });\n\t}\n\t/**\n\t * A factory construction utility\n\t *\n\t * @param base An ES6 Class, ComposeFactory or Object literal to use as the base for the new factory\n\t * @param initFunction An optional initialization function for the factory\n\t */\n\tvar compose = create;\n\t/* Add static methods to compose */\n\tlang_1.assign(compose, {\n\t    create: create,\n\t    static: _static,\n\t    extend: extend,\n\t    mixin: mixin,\n\t    override: override,\n\t    overlay: overlay,\n\t    from: from,\n\t    before: before,\n\t    after: after,\n\t    around: around,\n\t    aspect: aspect\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = compose;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(8);\n\t/**\n\t * The default message to warn when no other is provided\n\t */\n\tvar DEFAULT_DEPRECATED_MESSAGE = 'This function will be removed in future versions.';\n\t/**\n\t * When set, globalWarn will be used instead of `console.warn`\n\t */\n\tvar globalWarn;\n\t/**\n\t * A function that will console warn that a function has been deprecated\n\t *\n\t * @param options Provide options which change the display of the message\n\t */\n\tfunction deprecated(_a) {\n\t    var _b = _a === void 0 ? {} : _a, message = _b.message, name = _b.name, warn = _b.warn, url = _b.url;\n\t    /* istanbul ignore else: testing with debug off is difficult */\n\t    if (has_1.default('debug')) {\n\t        message = message || DEFAULT_DEPRECATED_MESSAGE;\n\t        var warning = \"DEPRECATED: \" + (name ? name + ': ' : '') + message;\n\t        if (url) {\n\t            warning += \"\\n\\n    See \" + url + \" for more details.\\n\\n\";\n\t        }\n\t        if (warn) {\n\t            warn(warning);\n\t        }\n\t        else if (globalWarn) {\n\t            globalWarn(warning);\n\t        }\n\t        else {\n\t            console.warn(warning);\n\t        }\n\t    }\n\t}\n\texports.deprecated = deprecated;\n\t/**\n\t * A function that generates before advice that can be used to warn when an API has been deprecated\n\t *\n\t * @param options Provide options which change the display of the message\n\t */\n\tfunction deprecatedAdvice(options) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        deprecated(options);\n\t        return args;\n\t    };\n\t}\n\texports.deprecatedAdvice = deprecatedAdvice;\n\t/**\n\t * A method decorator that will console warn when a method if invoked that is deprecated\n\t *\n\t * @param options Provide options which change the display of the message\n\t */\n\tfunction deprecatedDecorator(options) {\n\t    return function (target, propertyKey, descriptor) {\n\t        if (has_1.default('debug')) {\n\t            var originalFn_1 = descriptor.value;\n\t            options = options || {};\n\t            /* IE 10/11 don't have the name property on functions */\n\t            options.name = target.constructor.name ? target.constructor.name + \"#\" + propertyKey : propertyKey;\n\t            descriptor.value = function () {\n\t                var args = [];\n\t                for (var _i = 0; _i < arguments.length; _i++) {\n\t                    args[_i] = arguments[_i];\n\t                }\n\t                deprecated(options);\n\t                return originalFn_1.apply(target, args);\n\t            };\n\t        }\n\t        return descriptor;\n\t    };\n\t}\n\texports.deprecatedDecorator = deprecatedDecorator;\n\t/**\n\t * A function that will set the warn function that will be used instead of `console.warn` when\n\t * logging warning messages\n\t *\n\t * @param warn The function (or `undefined`) to use instead of `console.warn`\n\t */\n\tfunction setWarn(warn) {\n\t    globalWarn = warn;\n\t}\n\texports.setWarn = setWarn;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\tvar global_1 = __webpack_require__(5);\n\tvar has_1 = __webpack_require__(9);\n\t__export(__webpack_require__(9));\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = has_1.default;\n\thas_1.add('object-assign', typeof global_1.default.Object.assign === 'function');\n\thas_1.add('raf', typeof requestAnimationFrame === 'function');\n\thas_1.add('arraybuffer', typeof global_1.default.ArrayBuffer !== 'undefined');\n\thas_1.add('formdata', typeof global_1.default.FormData !== 'undefined');\n\thas_1.add('xhr', typeof global_1.default.XMLHttpRequest !== 'undefined');\n\thas_1.add('xhr2', has_1.default('xhr') && 'responseType' in global_1.default.XMLHttpRequest.prototype);\n\thas_1.add('xhr2-blob', function () {\n\t    if (!has_1.default('xhr2')) {\n\t        return false;\n\t    }\n\t    var request = new XMLHttpRequest();\n\t    request.open('GET', '/', true);\n\t    request.responseType = 'blob';\n\t    request.abort();\n\t    return request.responseType === 'blob';\n\t});\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\tvar global_1 = __webpack_require__(10);\n\tvar has_1 = __webpack_require__(11);\n\tvar has_2 = __webpack_require__(11);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = has_1.default;\n\t__export(__webpack_require__(11));\n\t/* ECMAScript 6 and 7 Features */\n\t/*\n\t * Determine whether or not native Symbol exists. If it doesn't, we don't want to use\n\t * a few other native implementations like Map, WeakMap, Set.  Consider a polyfill that provides Symbol,\n\t * Map, etc in the global namespace. If the polyfill's Symbol is not compatible with our Symbol, neither\n\t * will be anything that uses their iterator symbol, like Map, Set, etc.\n\t */\n\t/* Symbol */\n\thas_2.add('es6-symbol', typeof global_1.default.Symbol !== 'undefined' && typeof Symbol() === 'symbol');\n\t/* Object */\n\thas_2.add('es6-object-assign', typeof Object.assign === 'function');\n\t/* Array */\n\thas_2.add('es6-array-from', 'from' in global_1.default.Array);\n\thas_2.add('es6-array-of', 'of' in global_1.default.Array);\n\thas_2.add('es6-array-fill', function () {\n\t    if ('fill' in global_1.default.Array.prototype) {\n\t        /* Some versions of Safari do not properly implement this */\n\t        return [1].fill(9, Number.POSITIVE_INFINITY)[0] === 1;\n\t    }\n\t    return false;\n\t});\n\thas_2.add('es6-array-findindex', 'findIndex' in global_1.default.Array.prototype);\n\thas_2.add('es6-array-find', 'find' in global_1.default.Array.prototype);\n\thas_2.add('es6-array-copywithin', 'copyWithin' in global_1.default.Array.prototype);\n\thas_2.add('es7-array-includes', 'includes' in global_1.default.Array.prototype);\n\t/* String */\n\thas_2.add('es6-string-raw', function () {\n\t    function getCallSite(callSite) {\n\t        var substitutions = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            substitutions[_i - 1] = arguments[_i];\n\t        }\n\t        return callSite;\n\t    }\n\t    if ('raw' in global_1.default.String) {\n\t        var b = 1;\n\t        var callSite = (_a = [\"a\\n\", \"\"], _a.raw = [\"a\\\\n\", \"\"], getCallSite(_a, b));\n\t        callSite.raw = ['a\\\\n'];\n\t        var supportsTrunc = global_1.default.String.raw(callSite, 42) === 'a:\\\\n';\n\t        return supportsTrunc;\n\t    }\n\t    return false;\n\t    var _a;\n\t});\n\thas_2.add('es6-string-fromcodepoint', 'fromCodePoint' in global_1.default.String);\n\thas_2.add('es6-string-codepointat', 'codePointAt' in global_1.default.String.prototype);\n\thas_2.add('es6-string-normalize', 'normalize' in global_1.default.String.prototype);\n\thas_2.add('es6-string-repeat', 'repeat' in global_1.default.String.prototype);\n\thas_2.add('es6-string-startswith', 'startsWith' in global_1.default.String.prototype);\n\thas_2.add('es6-string-endswith', 'endsWith' in global_1.default.String.prototype);\n\thas_2.add('es6-string-includes', 'includes' in global_1.default.String.prototype);\n\thas_2.add('es6-string-padstart', 'padStart' in global_1.default.String.prototype);\n\thas_2.add('es6-string-padend', 'padEnd' in global_1.default.String.prototype);\n\t/* Math */\n\thas_2.add('es6-math-acosh', typeof global_1.default.Math.acosh === 'function');\n\thas_2.add('es6-math-clz32', typeof global_1.default.Math.clz32 === 'function');\n\thas_2.add('es6-math-imul', function () {\n\t    if ('imul' in global_1.default.Math) {\n\t        /* Some versions of Safari on ios do not properly implement this */\n\t        return Math.imul(0xffffffff, 5) === -5;\n\t    }\n\t    return false;\n\t});\n\t/* Promise */\n\thas_2.add('es6-promise', typeof global_1.default.Promise !== 'undefined' && has_1.default('es6-symbol'));\n\t/* Observable */\n\thas_2.add('es-observable', typeof global_1.default.Observable !== 'undefined');\n\t/* Set */\n\thas_2.add('es6-set', function () {\n\t    if (typeof global_1.default.Set === 'function') {\n\t        /* IE11 and older versions of Safari are missing critical ES6 Set functionality */\n\t        var set = new global_1.default.Set([1]);\n\t        return set.has(1) && 'keys' in set && typeof set.keys === 'function' && has_1.default('es6-symbol');\n\t    }\n\t    return false;\n\t});\n\t/* Map */\n\thas_2.add('es6-map', function () {\n\t    if (typeof global_1.default.Map === 'function') {\n\t        /*\n\t        IE11 and older versions of Safari are missing critical ES6 Map functionality\n\t        We wrap this in a try/catch because sometimes the Map constructor exists, but does not\n\t        take arguments (iOS 8.4)\n\t         */\n\t        try {\n\t            var map = new global_1.default.Map([[0, 1]]);\n\t            return map.has(0) &&\n\t                typeof map.keys === 'function' && has_1.default('es6-symbol') &&\n\t                typeof map.values === 'function' &&\n\t                typeof map.entries === 'function';\n\t        }\n\t        catch (e) {\n\t            /* istanbul ignore next: not testing on iOS at the moment */\n\t            return false;\n\t        }\n\t    }\n\t    return false;\n\t});\n\t/* WeakMap */\n\thas_2.add('es6-weakmap', function () {\n\t    if (typeof global_1.default.WeakMap !== 'undefined') {\n\t        /* IE11 and older versions of Safari are missing critical ES6 Map functionality */\n\t        var key1 = {};\n\t        var key2 = {};\n\t        var map = new global_1.default.WeakMap([[key1, 1]]);\n\t        Object.freeze(key1);\n\t        return map.get(key1) === 1 && map.set(key2, 2) === map && has_1.default('es6-symbol');\n\t    }\n\t    return false;\n\t});\n\t/* Miscellaneous features */\n\thas_2.add('float32array', 'Float32Array' in global_1.default);\n\thas_2.add('setimmediate', typeof global_1.default.setImmediate !== 'undefined');\n\thas_2.add('postmessage', typeof postMessage === 'function');\n\thas_2.add('microtasks', function () { return has_1.default('es6-promise') || has_1.default('host-node') || has_1.default('dom-mutationobserver'); });\n\t/* DOM Features */\n\thas_2.add('dom-mutationobserver', function () { return has_1.default('host-browser') && Boolean(global_1.default.MutationObserver || global_1.default.WebKitMutationObserver); });\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\tvar globalObject = (typeof global === 'undefined') ? Function('return this')() : global;\n\t// global spec defines a reference to the global object called 'global'\n\t// https://github.com/tc39/proposal-global\n\tif (!('global' in globalObject)) {\n\t    globalObject.global = globalObject;\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = globalObject;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {\"use strict\";\n\tfunction isFeatureTestThenable(value) {\n\t    return value && value.then;\n\t}\n\t/**\n\t * A cache of results of feature tests\n\t */\n\texports.testCache = {};\n\t/**\n\t * A cache of the un-resolved feature tests\n\t */\n\texports.testFunctions = {};\n\t/**\n\t * A cache of unresolved thenables (probably promises)\n\t * @type {{}}\n\t */\n\tvar testThenables = {};\n\t/**\n\t * A reference to the global scope (`window` in a browser, `global` in NodeJS)\n\t */\n\tvar globalScope = (function () {\n\t    /* istanbul ignore else */\n\t    if (typeof window !== 'undefined') {\n\t        // Browsers\n\t        return window;\n\t    }\n\t    else if (typeof global !== 'undefined') {\n\t        // Node\n\t        return global;\n\t    }\n\t    else if (typeof self !== 'undefined') {\n\t        // Web workers\n\t        return self;\n\t    }\n\t    /* istanbul ignore next */\n\t    return {};\n\t})();\n\t/* Grab the staticFeatures if there are available */\n\tvar staticFeatures = (globalScope.DojoHasEnvironment || {}).staticFeatures;\n\t/* Cleaning up the DojoHasEnviornment */\n\tif ('DojoHasEnvironment' in globalScope) {\n\t    delete globalScope.DojoHasEnvironment;\n\t}\n\t/**\n\t * Custom type guard to narrow the `staticFeatures` to either a map or a function that\n\t * returns a map.\n\t *\n\t * @param value The value to guard for\n\t */\n\tfunction isStaticFeatureFunction(value) {\n\t    return typeof value === 'function';\n\t}\n\t/**\n\t * The cache of asserted features that were available in the global scope when the\n\t * module loaded\n\t */\n\tvar staticCache = staticFeatures\n\t    ? isStaticFeatureFunction(staticFeatures)\n\t        ? staticFeatures.apply(globalScope)\n\t        : staticFeatures\n\t    : {};/* Providing an empty cache, if none was in the environment\n\t\n\t/**\n\t* AMD plugin function.\n\t*\n\t* Conditional loads modules based on a has feature test value.\n\t*\n\t* @param resourceId Gives the resolved module id to load.\n\t* @param require The loader require function with respect to the module that contained the plugin resource in its\n\t*                dependency list.\n\t* @param load Callback to loader that consumes result of plugin demand.\n\t*/\n\tfunction load(resourceId, require, load, config) {\n\t    resourceId ? require([resourceId], load) : load();\n\t}\n\texports.load = load;\n\t/**\n\t * AMD plugin function.\n\t *\n\t * Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test\n\t * value(s).\n\t *\n\t * @param resourceId The id of the module\n\t * @param normalize Resolves a relative module id into an absolute module id\n\t */\n\tfunction normalize(resourceId, normalize) {\n\t    var tokens = resourceId.match(/[\\?:]|[^:\\?]*/g) || [];\n\t    var i = 0;\n\t    function get(skip) {\n\t        var term = tokens[i++];\n\t        if (term === ':') {\n\t            // empty string module name, resolves to null\n\t            return null;\n\t        }\n\t        else {\n\t            // postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n\t            if (tokens[i++] === '?') {\n\t                if (!skip && has(term)) {\n\t                    // matched the feature, get the first value from the options\n\t                    return get();\n\t                }\n\t                else {\n\t                    // did not match, get the second value, passing over the first\n\t                    get(true);\n\t                    return get(skip);\n\t                }\n\t            }\n\t            // a module\n\t            return term;\n\t        }\n\t    }\n\t    var id = get();\n\t    return id && normalize(id);\n\t}\n\texports.normalize = normalize;\n\t/**\n\t * Check if a feature has already been registered\n\t *\n\t * @param feature the name of the feature\n\t */\n\tfunction exists(feature) {\n\t    var normalizedFeature = feature.toLowerCase();\n\t    return Boolean(normalizedFeature in staticCache || normalizedFeature in exports.testCache || exports.testFunctions[normalizedFeature]);\n\t}\n\texports.exists = exists;\n\t/**\n\t * Register a new test for a named feature.\n\t *\n\t * @example\n\t * has.add('dom-addeventlistener', !!document.addEventListener);\n\t *\n\t * @example\n\t * has.add('touch-events', function () {\n\t *    return 'ontouchstart' in document\n\t * });\n\t *\n\t * @param feature the name of the feature\n\t * @param value the value reported of the feature, or a function that will be executed once on first test\n\t * @param overwrite if an existing value should be overwritten. Defaults to false.\n\t */\n\tfunction add(feature, value, overwrite) {\n\t    if (overwrite === void 0) { overwrite = false; }\n\t    var normalizedFeature = feature.toLowerCase();\n\t    if (exists(normalizedFeature) && !overwrite && !(normalizedFeature in staticCache)) {\n\t        throw new TypeError(\"Feature \\\"\" + feature + \"\\\" exists and overwrite not true.\");\n\t    }\n\t    if (typeof value === 'function') {\n\t        exports.testFunctions[normalizedFeature] = value;\n\t    }\n\t    else if (isFeatureTestThenable(value)) {\n\t        testThenables[feature] = value.then(function (resolvedValue) {\n\t            exports.testCache[feature] = resolvedValue;\n\t            delete testThenables[feature];\n\t        }, function () {\n\t            delete testThenables[feature];\n\t        });\n\t    }\n\t    else {\n\t        exports.testCache[normalizedFeature] = value;\n\t        delete exports.testFunctions[normalizedFeature];\n\t    }\n\t}\n\texports.add = add;\n\t/**\n\t * Return the current value of a named feature.\n\t *\n\t * @param feature The name (if a string) or identifier (if an integer) of the feature to test.\n\t */\n\tfunction has(feature) {\n\t    var result;\n\t    var normalizedFeature = feature.toLowerCase();\n\t    if (normalizedFeature in staticCache) {\n\t        result = staticCache[normalizedFeature];\n\t    }\n\t    else if (exports.testFunctions[normalizedFeature]) {\n\t        result = exports.testCache[normalizedFeature] = exports.testFunctions[normalizedFeature].call(null);\n\t        delete exports.testFunctions[normalizedFeature];\n\t    }\n\t    else if (normalizedFeature in exports.testCache) {\n\t        result = exports.testCache[normalizedFeature];\n\t    }\n\t    else if (feature in testThenables) {\n\t        return false;\n\t    }\n\t    else {\n\t        throw new TypeError(\"Attempt to detect unregistered has feature \\\"\" + feature + \"\\\"\");\n\t    }\n\t    return result;\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = has;\n\t/*\n\t * Out of the box feature tests\n\t */\n\t/* Environments */\n\t/* Used as a value to provide a debug only code path */\n\tadd('debug', true);\n\t/* Detects if the environment is \"browser like\" */\n\tadd('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');\n\t/* Detects if the environment appears to be NodeJS */\n\tadd('host-node', function () {\n\t    if (typeof process === 'object' && process.versions && process.versions.node) {\n\t        return process.versions.node;\n\t    }\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(12)))\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(8);\n\tvar slice = Array.prototype.slice;\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t/**\n\t * Type guard that ensures that the value can be coerced to Object\n\t * to weed out host objects that do not derive from Object.\n\t * This function is used to check if we want to deep copy an object or not.\n\t * Note: In ES6 it is possible to modify an object's Symbol.toStringTag property, which will\n\t * change the value returned by `toString`. This is a rare edge case that is difficult to handle,\n\t * so it is not handled here.\n\t * @param  value The value to check\n\t * @return       If the value is coercible into an Object\n\t */\n\tfunction shouldDeepCopyObject(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\tfunction copyArray(array, inherited) {\n\t    return array.map(function (item) {\n\t        if (Array.isArray(item)) {\n\t            return copyArray(item, inherited);\n\t        }\n\t        return !shouldDeepCopyObject(item) ?\n\t            item :\n\t            _mixin({\n\t                deep: true,\n\t                inherited: inherited,\n\t                sources: [item],\n\t                target: {}\n\t            });\n\t    });\n\t}\n\tfunction _mixin(kwArgs) {\n\t    var deep = kwArgs.deep;\n\t    var inherited = kwArgs.inherited;\n\t    var target = kwArgs.target;\n\t    for (var _i = 0, _a = kwArgs.sources; _i < _a.length; _i++) {\n\t        var source = _a[_i];\n\t        if (source === null || source === undefined) {\n\t            continue;\n\t        }\n\t        for (var key in source) {\n\t            if (inherited || hasOwnProperty.call(source, key)) {\n\t                var value = source[key];\n\t                if (deep) {\n\t                    if (Array.isArray(value)) {\n\t                        value = copyArray(value, inherited);\n\t                    }\n\t                    else if (shouldDeepCopyObject(value)) {\n\t                        value = _mixin({\n\t                            deep: true,\n\t                            inherited: inherited,\n\t                            sources: [value],\n\t                            target: {}\n\t                        });\n\t                    }\n\t                }\n\t                target[key] = value;\n\t            }\n\t        }\n\t    }\n\t    return target;\n\t}\n\t/**\n\t * Copies the values of all enumerable own properties of one or more source objects to the target object.\n\t *\n\t * @param target The target object to receive values from source objects\n\t * @param sources Any number of objects whose enumerable own properties will be copied to the target object\n\t * @return The modified target object\n\t */\n\texports.assign = has_1.default('object-assign') ?\n\t    Object.assign :\n\t    function (target) {\n\t        var sources = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            sources[_i - 1] = arguments[_i];\n\t        }\n\t        return _mixin({\n\t            deep: false,\n\t            inherited: false,\n\t            sources: sources,\n\t            target: target\n\t        });\n\t    };\n\tfunction create(prototype) {\n\t    var mixins = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        mixins[_i - 1] = arguments[_i];\n\t    }\n\t    if (!mixins.length) {\n\t        throw new RangeError('lang.create requires at least one mixin object.');\n\t    }\n\t    var args = mixins.slice();\n\t    args.unshift(Object.create(prototype));\n\t    return exports.assign.apply(null, args);\n\t}\n\texports.create = create;\n\tfunction deepAssign(target) {\n\t    var sources = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        sources[_i - 1] = arguments[_i];\n\t    }\n\t    return _mixin({\n\t        deep: true,\n\t        inherited: false,\n\t        sources: sources,\n\t        target: target\n\t    });\n\t}\n\texports.deepAssign = deepAssign;\n\tfunction deepMixin(target) {\n\t    var sources = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        sources[_i - 1] = arguments[_i];\n\t    }\n\t    return _mixin({\n\t        deep: true,\n\t        inherited: true,\n\t        sources: sources,\n\t        target: target\n\t    });\n\t}\n\texports.deepMixin = deepMixin;\n\t/**\n\t * Creates a new object using the provided source's prototype as the prototype for the new object, and then\n\t * deep copies the provided source's values into the new target.\n\t *\n\t * @param source The object to duplicate\n\t * @return The new object\n\t */\n\tfunction duplicate(source) {\n\t    var target = Object.create(Object.getPrototypeOf(source));\n\t    return deepMixin(target, source);\n\t}\n\texports.duplicate = duplicate;\n\t/**\n\t * Determines whether two values are the same value.\n\t *\n\t * @param a First value to compare\n\t * @param b Second value to compare\n\t * @return true if the values are the same; false otherwise\n\t */\n\tfunction isIdentical(a, b) {\n\t    return a === b ||\n\t        /* both values are NaN */\n\t        (a !== a && b !== b);\n\t}\n\texports.isIdentical = isIdentical;\n\t/**\n\t * Returns a function that binds a method to the specified object at runtime. This is similar to\n\t * `Function.prototype.bind`, but instead of a function it takes the name of a method on an object.\n\t * As a result, the function returned by `lateBind` will always call the function currently assigned to\n\t * the specified property on the object as of the moment the function it returns is called.\n\t *\n\t * @param instance The context object\n\t * @param method The name of the method on the context object to bind to itself\n\t * @param suppliedArgs An optional array of values to prepend to the `instance[method]` arguments list\n\t * @return The bound function\n\t */\n\tfunction lateBind(instance, method) {\n\t    var suppliedArgs = [];\n\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t        suppliedArgs[_i - 2] = arguments[_i];\n\t    }\n\t    return suppliedArgs.length ?\n\t        function () {\n\t            var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\t            // TS7017\n\t            return instance[method].apply(instance, args);\n\t        } :\n\t        function () {\n\t            // TS7017\n\t            return instance[method].apply(instance, arguments);\n\t        };\n\t}\n\texports.lateBind = lateBind;\n\tfunction mixin(target) {\n\t    var sources = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        sources[_i - 1] = arguments[_i];\n\t    }\n\t    return _mixin({\n\t        deep: false,\n\t        inherited: true,\n\t        sources: sources,\n\t        target: target\n\t    });\n\t}\n\texports.mixin = mixin;\n\t/**\n\t * Returns a function which invokes the given function with the given arguments prepended to its argument list.\n\t * Like `Function.prototype.bind`, but does not alter execution context.\n\t *\n\t * @param targetFunction The function that needs to be bound\n\t * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list\n\t * @return The bound function\n\t */\n\tfunction partial(targetFunction) {\n\t    var suppliedArgs = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        suppliedArgs[_i - 1] = arguments[_i];\n\t    }\n\t    return function () {\n\t        var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\t        return targetFunction.apply(this, args);\n\t    };\n\t}\n\texports.partial = partial;\n\t/**\n\t * Returns an object with a destroy method that, when called, calls the passed-in destructor.\n\t * This is intended to provide a unified interface for creating \"remove\" / \"destroy\" handlers for\n\t * event listeners, timers, etc.\n\t *\n\t * @param destructor A function that will be called when the handle's `destroy` method is invoked\n\t * @return The handle object\n\t */\n\tfunction createHandle(destructor) {\n\t    return {\n\t        destroy: function () {\n\t            this.destroy = function () { };\n\t            destructor.call(this);\n\t        }\n\t    };\n\t}\n\texports.createHandle = createHandle;\n\t/**\n\t * Returns a single handle that can be used to destroy multiple handles simultaneously.\n\t *\n\t * @param handles An array of handles with `destroy` methods\n\t * @return The handle object\n\t */\n\tfunction createCompositeHandle() {\n\t    var handles = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        handles[_i] = arguments[_i];\n\t    }\n\t    return createHandle(function () {\n\t        for (var _i = 0, handles_1 = handles; _i < handles_1.length; _i++) {\n\t            var handle = handles_1[_i];\n\t            handle.destroy();\n\t        }\n\t    });\n\t}\n\texports.createCompositeHandle = createCompositeHandle;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(9);\n\tvar util_1 = __webpack_require__(15);\n\tvar iterator_1 = __webpack_require__(16);\n\tvar number_1 = __webpack_require__(19);\n\t/**\n\t * Ensures a non-negative, non-infinite, safe integer.\n\t *\n\t * @param length The number to validate\n\t * @return A proper length\n\t */\n\tfunction toLength(length) {\n\t    length = Number(length);\n\t    if (isNaN(length)) {\n\t        return 0;\n\t    }\n\t    if (isFinite(length)) {\n\t        length = Math.floor(length);\n\t    }\n\t    // Ensure a non-negative, real, safe integer\n\t    return Math.min(Math.max(length, 0), number_1.MAX_SAFE_INTEGER);\n\t}\n\t/**\n\t * From ES6 7.1.4 ToInteger()\n\t *\n\t * @param value A value to convert\n\t * @return An integer\n\t */\n\tfunction toInteger(value) {\n\t    value = Number(value);\n\t    if (isNaN(value)) {\n\t        return 0;\n\t    }\n\t    if (value === 0 || !isFinite(value)) {\n\t        return value;\n\t    }\n\t    return (value > 0 ? 1 : -1) * Math.floor(Math.abs(value));\n\t}\n\t/**\n\t * Normalizes an offset against a given length, wrapping it if negative.\n\t *\n\t * @param value The original offset\n\t * @param length The total length to normalize against\n\t * @return If negative, provide a distance from the end (length); otherwise provide a distance from 0\n\t */\n\tfunction normalizeOffset(value, length) {\n\t    return value < 0 ? Math.max(length + value, 0) : Math.min(value, length);\n\t}\n\t/**\n\t * A namespace that contains the polyfilled functionality that is then exported below, depending on if\n\t * the functionality is required or not.\n\t */\n\tvar Shim;\n\t(function (Shim) {\n\t    function from(arrayLike, mapFunction, thisArg) {\n\t        if (arrayLike == null) {\n\t            throw new TypeError('from: requires an array-like object');\n\t        }\n\t        if (mapFunction && thisArg) {\n\t            mapFunction = mapFunction.bind(thisArg);\n\t        }\n\t        /* tslint:disable-next-line:variable-name */\n\t        var Constructor = this;\n\t        var length = toLength(arrayLike.length);\n\t        // Support extension\n\t        var array = (typeof Constructor === 'function') ? Object(new Constructor(length)) : new Array(length);\n\t        if (!iterator_1.isArrayLike(arrayLike) && !iterator_1.isIterable(arrayLike)) {\n\t            return array;\n\t        }\n\t        var i = 0;\n\t        iterator_1.forOf(arrayLike, function (value) {\n\t            array[i] = mapFunction ? mapFunction(value, i) : value;\n\t            i++;\n\t        });\n\t        if (arrayLike.length !== undefined) {\n\t            array.length = length;\n\t        }\n\t        return array;\n\t    }\n\t    Shim.from = from;\n\t    function of() {\n\t        var items = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            items[_i] = arguments[_i];\n\t        }\n\t        return Array.prototype.slice.call(items);\n\t    }\n\t    Shim.of = of;\n\t    function copyWithin(target, offset, start, end) {\n\t        if (target == null) {\n\t            throw new TypeError('copyWithin: target must be an array-like object');\n\t        }\n\t        var length = toLength(target.length);\n\t        offset = normalizeOffset(toInteger(offset), length);\n\t        start = normalizeOffset(toInteger(start), length);\n\t        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n\t        var count = Math.min(end - start, length - offset);\n\t        var direction = 1;\n\t        if (offset > start && offset < (start + count)) {\n\t            direction = -1;\n\t            start += count - 1;\n\t            offset += count - 1;\n\t        }\n\t        while (count > 0) {\n\t            if (start in target) {\n\t                target[offset] = target[start];\n\t            }\n\t            else {\n\t                delete target[offset];\n\t            }\n\t            offset += direction;\n\t            start += direction;\n\t            count--;\n\t        }\n\t        return target;\n\t    }\n\t    Shim.copyWithin = copyWithin;\n\t    function fill(target, value, start, end) {\n\t        var length = toLength(target.length);\n\t        var i = normalizeOffset(toInteger(start), length);\n\t        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n\t        while (i < end) {\n\t            target[i++] = value;\n\t        }\n\t        return target;\n\t    }\n\t    Shim.fill = fill;\n\t    function find(target, callback, thisArg) {\n\t        var index = findIndex(target, callback, thisArg);\n\t        return index !== -1 ? target[index] : undefined;\n\t    }\n\t    Shim.find = find;\n\t    function findIndex(target, callback, thisArg) {\n\t        var length = toLength(target.length);\n\t        if (!callback) {\n\t            throw new TypeError('find: second argument must be a function');\n\t        }\n\t        if (thisArg) {\n\t            callback = callback.bind(thisArg);\n\t        }\n\t        for (var i = 0; i < length; i++) {\n\t            if (callback(target[i], i, target)) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t    Shim.findIndex = findIndex;\n\t    function includes(target, searchElement, fromIndex) {\n\t        if (fromIndex === void 0) { fromIndex = 0; }\n\t        var len = toLength(target.length);\n\t        for (var i = fromIndex; i < len; ++i) {\n\t            var currentElement = target[i];\n\t            if (searchElement === currentElement ||\n\t                (searchElement !== searchElement && currentElement !== currentElement)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t    Shim.includes = includes;\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\texports.from = has_1.default('es6-array-from')\n\t    ? Array.from\n\t    : Shim.from;\n\t/**\n\t * Creates a new array from the function parameters.\n\t *\n\t * @param arguments Any number of arguments for the array\n\t * @return An array from the given arguments\n\t */\n\texports.of = has_1.default('es6-array-of')\n\t    ? Array.of\n\t    : Shim.of;\n\t/* ES6 Array instance methods */\n\t/**\n\t * Copies data internally within an array or array-like object.\n\t *\n\t * @param target The target array-like object\n\t * @param offset The index to start copying values to; if negative, it counts backwards from length\n\t * @param start The first (inclusive) index to copy; if negative, it counts backwards from length\n\t * @param end The last (exclusive) index to copy; if negative, it counts backwards from length\n\t * @return The target\n\t */\n\texports.copyWithin = has_1.default('es6-array-copywithin')\n\t    ? util_1.wrapNative(Array.prototype.copyWithin)\n\t    : Shim.copyWithin;\n\t/**\n\t * Fills elements of an array-like object with the specified value.\n\t *\n\t * @param target The target to fill\n\t * @param value The value to fill each element of the target with\n\t * @param start The first index to fill\n\t * @param end The (exclusive) index at which to stop filling\n\t * @return The filled target\n\t */\n\texports.fill = has_1.default('es6-array-fill')\n\t    ? util_1.wrapNative(Array.prototype.fill)\n\t    : Shim.fill;\n\t/**\n\t * Finds and returns the first instance matching the callback or undefined if one is not found.\n\t *\n\t * @param target An array-like object\n\t * @param callback A function returning if the current value matches a criteria\n\t * @param [thisArg] The execution context for the find function\n\t * @return The first element matching the callback, or undefined if one does not exist\n\t */\n\texports.find = has_1.default('es6-array-find')\n\t    ? util_1.wrapNative(Array.prototype.find)\n\t    : Shim.find;\n\t/**\n\t * Performs a linear search and returns the first index whose value satisfies the passed callback,\n\t * or -1 if no values satisfy it.\n\t *\n\t * @param target An array-like object\n\t * @param callback A function returning true if the current value satisfies its criteria\n\t * @param [thisArg] The execution context for the find function\n\t * @return The first index whose value satisfies the passed callback, or -1 if no values satisfy it\n\t */\n\texports.findIndex = has_1.default('es6-array-findindex')\n\t    ? util_1.wrapNative(Array.prototype.findIndex)\n\t    : Shim.findIndex;\n\t/* ES7 Array instance methods */\n\t/**\n\t * Determines whether an array includes a given value\n\t *\n\t * @param target the target array-like object\n\t * @param searchElement the item to search for\n\t * @param fromIndex the starting index to search from\n\t * @return `true` if the array includes the element, otherwise `false`\n\t */\n\texports.includes = has_1.default('es7-array-includes')\n\t    ? util_1.wrapNative(Array.prototype.includes)\n\t    : Shim.includes;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * Helper function to generate a value property descriptor\n\t *\n\t * @param value        The value the property descriptor should be set to\n\t * @param enumerable   If the property should be enumberable, defaults to false\n\t * @param writable     If the property should be writable, defaults to true\n\t * @param configurable If the property should be configurable, defaults to true\n\t * @return             The property descriptor object\n\t */\n\tfunction getValueDescriptor(value, enumerable, writable, configurable) {\n\t    if (enumerable === void 0) { enumerable = false; }\n\t    if (writable === void 0) { writable = true; }\n\t    if (configurable === void 0) { configurable = true; }\n\t    return {\n\t        value: value,\n\t        enumerable: enumerable,\n\t        writable: writable,\n\t        configurable: configurable\n\t    };\n\t}\n\texports.getValueDescriptor = getValueDescriptor;\n\t/**\n\t * A helper function which wraps a function where the first argument becomes the scope\n\t * of the call\n\t *\n\t * @param nativeFunction The source function to be wrapped\n\t */\n\tfunction wrapNative(nativeFunction) {\n\t    return function (target) {\n\t        var args = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            args[_i - 1] = arguments[_i];\n\t        }\n\t        return nativeFunction.apply(target, args);\n\t    };\n\t}\n\texports.wrapNative = wrapNative;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar string_1 = __webpack_require__(17);\n\t__webpack_require__(18);\n\tvar staticDone = { done: true, value: undefined };\n\t/**\n\t * A class that provides \"shims\" an iterator interface on array like\n\t * objects.\n\t */\n\tvar ShimIterator = (function () {\n\t    function ShimIterator(list) {\n\t        this._nextIndex = -1;\n\t        if (isIterable(list)) {\n\t            this._nativeIterator = list[Symbol.iterator]();\n\t        }\n\t        else {\n\t            this._list = list;\n\t        }\n\t    }\n\t    ;\n\t    /**\n\t     * Return the next iteration result for the Iterator\n\t     */\n\t    ShimIterator.prototype.next = function () {\n\t        if (this._nativeIterator) {\n\t            return this._nativeIterator.next();\n\t        }\n\t        if (!this._list) {\n\t            return staticDone;\n\t        }\n\t        if (++this._nextIndex < this._list.length) {\n\t            return {\n\t                done: false,\n\t                value: this._list[this._nextIndex]\n\t            };\n\t        }\n\t        return staticDone;\n\t    };\n\t    ;\n\t    ShimIterator.prototype[Symbol.iterator] = function () {\n\t        return this;\n\t    };\n\t    return ShimIterator;\n\t}());\n\texports.ShimIterator = ShimIterator;\n\t/**\n\t * A type guard for checking if something has an Iterable interface\n\t *\n\t * @param value The value to type guard against\n\t */\n\tfunction isIterable(value) {\n\t    return value && typeof value[Symbol.iterator] === 'function';\n\t}\n\texports.isIterable = isIterable;\n\t/**\n\t * A type guard for checking if something is ArrayLike\n\t *\n\t * @param value The value to type guard against\n\t */\n\tfunction isArrayLike(value) {\n\t    return value && typeof value.length === 'number';\n\t}\n\texports.isArrayLike = isArrayLike;\n\t/**\n\t * Returns the iterator for an object\n\t *\n\t * @param iterable The iterable object to return the iterator for\n\t */\n\tfunction get(iterable) {\n\t    if (isIterable(iterable)) {\n\t        return iterable[Symbol.iterator]();\n\t    }\n\t    else if (isArrayLike(iterable)) {\n\t        return new ShimIterator(iterable);\n\t    }\n\t}\n\texports.get = get;\n\t/**\n\t * Shims the functionality of `for ... of` blocks\n\t *\n\t * @param iterable The object the provides an interator interface\n\t * @param callback The callback which will be called for each item of the iterable\n\t * @param thisArg Optional scope to pass the callback\n\t */\n\tfunction forOf(iterable, callback, thisArg) {\n\t    var broken = false;\n\t    function doBreak() {\n\t        broken = true;\n\t    }\n\t    /* We need to handle iteration of double byte strings properly */\n\t    if (!isIterable(iterable) && typeof iterable === 'string') {\n\t        var l = iterable.length;\n\t        for (var i = 0; i < l; ++i) {\n\t            var char = iterable[i];\n\t            if ((i + 1) < l) {\n\t                var code = char.charCodeAt(0);\n\t                if ((code >= string_1.HIGH_SURROGATE_MIN) && (code <= string_1.HIGH_SURROGATE_MAX)) {\n\t                    char += iterable[++i];\n\t                }\n\t            }\n\t            callback.call(thisArg, char, iterable, doBreak);\n\t            if (broken) {\n\t                return;\n\t            }\n\t        }\n\t    }\n\t    else {\n\t        var iterator = get(iterable);\n\t        if (iterator) {\n\t            var result = iterator.next();\n\t            while (!result.done) {\n\t                callback.call(thisArg, result.value, iterable, doBreak);\n\t                if (broken) {\n\t                    return;\n\t                }\n\t                result = iterator.next();\n\t            }\n\t        }\n\t    }\n\t}\n\texports.forOf = forOf;\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(9);\n\tvar util_1 = __webpack_require__(15);\n\t/**\n\t * The minimum location of high surrogates\n\t */\n\texports.HIGH_SURROGATE_MIN = 0xD800;\n\t/**\n\t * The maximum location of high surrogates\n\t */\n\texports.HIGH_SURROGATE_MAX = 0xDBFF;\n\t/**\n\t * The minimum location of low surrogates\n\t */\n\texports.LOW_SURROGATE_MIN = 0xDC00;\n\t/**\n\t * The maximum location of low surrogates\n\t */\n\texports.LOW_SURROGATE_MAX = 0xDFFF;\n\tvar Shim;\n\t(function (Shim) {\n\t    /**\n\t     * Validates that text is defined, and normalizes position (based on the given default if the input is NaN).\n\t     * Used by startsWith, includes, and endsWith.\n\t     *\n\t     * @return Normalized position.\n\t     */\n\t    function normalizeSubstringArgs(name, text, search, position, isEnd) {\n\t        if (isEnd === void 0) { isEnd = false; }\n\t        if (text == null) {\n\t            throw new TypeError('string.' + name + ' requires a valid string to search against.');\n\t        }\n\t        var length = text.length;\n\t        position = position !== position ? (isEnd ? length : 0) : position;\n\t        return [text, String(search), Math.min(Math.max(position, 0), length)];\n\t    }\n\t    function raw(callSite) {\n\t        var substitutions = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            substitutions[_i - 1] = arguments[_i];\n\t        }\n\t        var rawStrings = callSite.raw;\n\t        var result = '';\n\t        var numSubstitutions = substitutions.length;\n\t        if (callSite == null || callSite.raw == null) {\n\t            throw new TypeError('string.raw requires a valid callSite object with a raw value');\n\t        }\n\t        for (var i = 0, length_1 = rawStrings.length; i < length_1; i++) {\n\t            result += rawStrings[i] + (i < numSubstitutions && i < length_1 - 1 ? substitutions[i] : '');\n\t        }\n\t        return result;\n\t    }\n\t    Shim.raw = raw;\n\t    function fromCodePoint() {\n\t        var codePoints = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            codePoints[_i] = arguments[_i];\n\t        }\n\t        // Adapted from https://github.com/mathiasbynens/String.fromCodePoint\n\t        var length = arguments.length;\n\t        if (!length) {\n\t            return '';\n\t        }\n\t        var fromCharCode = String.fromCharCode;\n\t        var MAX_SIZE = 0x4000;\n\t        var codeUnits = [];\n\t        var index = -1;\n\t        var result = '';\n\t        while (++index < length) {\n\t            var codePoint = Number(arguments[index]);\n\t            // Code points must be finite integers within the valid range\n\t            var isValid = isFinite(codePoint) && Math.floor(codePoint) === codePoint &&\n\t                codePoint >= 0 && codePoint <= 0x10FFFF;\n\t            if (!isValid) {\n\t                throw RangeError('string.fromCodePoint: Invalid code point ' + codePoint);\n\t            }\n\t            if (codePoint <= 0xFFFF) {\n\t                // BMP code point\n\t                codeUnits.push(codePoint);\n\t            }\n\t            else {\n\t                // Astral code point; split in surrogate halves\n\t                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t                codePoint -= 0x10000;\n\t                var highSurrogate = (codePoint >> 10) + exports.HIGH_SURROGATE_MIN;\n\t                var lowSurrogate = (codePoint % 0x400) + exports.LOW_SURROGATE_MIN;\n\t                codeUnits.push(highSurrogate, lowSurrogate);\n\t            }\n\t            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n\t                result += fromCharCode.apply(null, codeUnits);\n\t                codeUnits.length = 0;\n\t            }\n\t        }\n\t        return result;\n\t    }\n\t    Shim.fromCodePoint = fromCodePoint;\n\t    function codePointAt(text, position) {\n\t        if (position === void 0) { position = 0; }\n\t        // Adapted from https://github.com/mathiasbynens/String.prototype.codePointAt\n\t        if (text == null) {\n\t            throw new TypeError('string.codePointAt requries a valid string.');\n\t        }\n\t        var length = text.length;\n\t        if (position !== position) {\n\t            position = 0;\n\t        }\n\t        if (position < 0 || position >= length) {\n\t            return undefined;\n\t        }\n\t        // Get the first code unit\n\t        var first = text.charCodeAt(position);\n\t        if (first >= exports.HIGH_SURROGATE_MIN && first <= exports.HIGH_SURROGATE_MAX && length > position + 1) {\n\t            // Start of a surrogate pair (high surrogate and there is a next code unit); check for low surrogate\n\t            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t            var second = text.charCodeAt(position + 1);\n\t            if (second >= exports.LOW_SURROGATE_MIN && second <= exports.LOW_SURROGATE_MAX) {\n\t                return (first - exports.HIGH_SURROGATE_MIN) * 0x400 + second - exports.LOW_SURROGATE_MIN + 0x10000;\n\t            }\n\t        }\n\t        return first;\n\t    }\n\t    Shim.codePointAt = codePointAt;\n\t    /* TODO: Missing normalize */\n\t    function repeat(text, count) {\n\t        if (count === void 0) { count = 0; }\n\t        // Adapted from https://github.com/mathiasbynens/String.prototype.repeat\n\t        if (text == null) {\n\t            throw new TypeError('string.repeat requires a valid string.');\n\t        }\n\t        if (count !== count) {\n\t            count = 0;\n\t        }\n\t        if (count < 0 || count === Infinity) {\n\t            throw new RangeError('string.repeat requires a non-negative finite count.');\n\t        }\n\t        var result = '';\n\t        while (count) {\n\t            if (count % 2) {\n\t                result += text;\n\t            }\n\t            if (count > 1) {\n\t                text += text;\n\t            }\n\t            count >>= 1;\n\t        }\n\t        return result;\n\t    }\n\t    Shim.repeat = repeat;\n\t    function startsWith(text, search, position) {\n\t        if (position === void 0) { position = 0; }\n\t        search = String(search);\n\t        _a = normalizeSubstringArgs('startsWith', text, search, position), text = _a[0], search = _a[1], position = _a[2];\n\t        var end = position + search.length;\n\t        if (end > text.length) {\n\t            return false;\n\t        }\n\t        return text.slice(position, end) === search;\n\t        var _a;\n\t    }\n\t    Shim.startsWith = startsWith;\n\t    function endsWith(text, search, endPosition) {\n\t        if (endPosition == null) {\n\t            endPosition = text.length;\n\t        }\n\t        _a = normalizeSubstringArgs('endsWith', text, search, endPosition, true), text = _a[0], search = _a[1], endPosition = _a[2];\n\t        var start = endPosition - search.length;\n\t        if (start < 0) {\n\t            return false;\n\t        }\n\t        return text.slice(start, endPosition) === search;\n\t        var _a;\n\t    }\n\t    Shim.endsWith = endsWith;\n\t    function includes(text, search, position) {\n\t        if (position === void 0) { position = 0; }\n\t        _a = normalizeSubstringArgs('includes', text, search, position), text = _a[0], search = _a[1], position = _a[2];\n\t        return text.indexOf(search, position) !== -1;\n\t        var _a;\n\t    }\n\t    Shim.includes = includes;\n\t    function padEnd(text, maxLength, fillString) {\n\t        if (fillString === void 0) { fillString = ' '; }\n\t        if (text === null || text === undefined) {\n\t            throw new TypeError('string.repeat requires a valid string.');\n\t        }\n\t        if (maxLength === Infinity) {\n\t            throw new RangeError('string.padEnd requires a non-negative finite count.');\n\t        }\n\t        if (maxLength === null || maxLength === undefined || maxLength < 0) {\n\t            maxLength = 0;\n\t        }\n\t        var strText = String(text);\n\t        var padding = maxLength - strText.length;\n\t        if (padding > 0) {\n\t            strText += repeat(fillString, Math.floor(padding / fillString.length)) + fillString.slice(0, padding % fillString.length);\n\t        }\n\t        return strText;\n\t    }\n\t    Shim.padEnd = padEnd;\n\t    function padStart(text, maxLength, fillString) {\n\t        if (fillString === void 0) { fillString = ' '; }\n\t        if (text === null || text === undefined) {\n\t            throw new TypeError('string.repeat requires a valid string.');\n\t        }\n\t        if (maxLength === Infinity) {\n\t            throw new RangeError('string.padStart requires a non-negative finite count.');\n\t        }\n\t        if (maxLength === null || maxLength === undefined || maxLength < 0) {\n\t            maxLength = 0;\n\t        }\n\t        var strText = String(text);\n\t        var padding = maxLength - strText.length;\n\t        if (padding > 0) {\n\t            strText = repeat(fillString, Math.floor(padding / fillString.length)) + fillString.slice(0, padding % fillString.length) + strText;\n\t        }\n\t        return strText;\n\t    }\n\t    Shim.padStart = padStart;\n\t    /* TODO: Provide an iterator for a string to mimic [Symbol.iterator]? */\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\t/**\n\t * A tag function for template strings to get the template string's raw string form.\n\t *\n\t * @param callSite Call site object (or a template string in TypeScript, which will transpile to one)\n\t * @param substitutions Values to substitute within the template string (TypeScript will generate these automatically)\n\t * @return String containing the raw template string with variables substituted\n\t *\n\t * @example\n\t * // Within TypeScript; logs 'The answer is:\\\\n42'\n\t * let answer = 42;\n\t * console.log(string.raw`The answer is:\\n${answer}`);\n\t *\n\t * @example\n\t * // The same example as above, but directly specifying a JavaScript object and substitution\n\t * console.log(string.raw({ raw: [ 'The answer is:\\\\n', '' ] }, 42));\n\t */\n\texports.raw = has_1.default('es6-string-raw')\n\t    ? String.raw\n\t    : Shim.raw;\n\t/**\n\t * Returns the UTF-16 encoded code point value of a given position in a string.\n\t *\n\t * @param text The string containing the element whose code point is to be determined\n\t * @param position Position of an element within the string to retrieve the code point value from\n\t * @return A non-negative integer representing the UTF-16 encoded code point value\n\t */\n\texports.fromCodePoint = has_1.default('es6-string-fromcodepoint')\n\t    ? String.fromCodePoint\n\t    : Shim.fromCodePoint;\n\t/**\n\t * Returns the UTF-16 encoded code point value of a given position in a string.\n\t *\n\t * @param text The string containing the element whose code point is to be determined\n\t * @param position Position of an element within the string to retrieve the code point value from\n\t * @return A non-negative integer representing the UTF-16 encoded code point value\n\t */\n\texports.codePointAt = has_1.default('es6-string-codepointat')\n\t    ? util_1.wrapNative(String.prototype.codePointAt)\n\t    : Shim.codePointAt;\n\t/**\n\t * Returns a string containing the given string repeated the specified number of times.\n\t *\n\t * @param text The string to repeat\n\t * @param count The number of times to repeat the string\n\t * @return A string containing the input string repeated count times\n\t */\n\texports.repeat = has_1.default('es6-string-repeat')\n\t    ? util_1.wrapNative(String.prototype.repeat)\n\t    : Shim.repeat;\n\t/**\n\t * Determines whether a string begins with the given substring (optionally starting from a given index).\n\t *\n\t * @param text The string to look for the search string within\n\t * @param search The string to search for\n\t * @param position The index to begin searching at\n\t * @return Boolean indicating if the search string was found at the beginning of the given string\n\t */\n\texports.startsWith = has_1.default('es6-string-startswith')\n\t    ? util_1.wrapNative(String.prototype.startsWith)\n\t    : Shim.startsWith;\n\t/**\n\t * Determines whether a string ends with the given substring.\n\t *\n\t * @param text The string to look for the search string within\n\t * @param search The string to search for\n\t * @param endPosition The index searching should stop before (defaults to text.length)\n\t * @return Boolean indicating if the search string was found at the end of the given string\n\t */\n\texports.endsWith = has_1.default('es6-string-endswith')\n\t    ? util_1.wrapNative(String.prototype.endsWith)\n\t    : Shim.endsWith;\n\t/**\n\t * Determines whether a string includes the given substring (optionally starting from a given index).\n\t *\n\t * @param text The string to look for the search string within\n\t * @param search The string to search for\n\t * @param position The index to begin searching at\n\t * @return Boolean indicating if the search string was found within the given string\n\t */\n\texports.includes = has_1.default('es6-string-includes')\n\t    ? util_1.wrapNative(String.prototype.includes)\n\t    : Shim.includes;\n\t/**\n\t * Pads the beginning of a string with a fill string until the string is a certain length.\n\t *\n\t * @param text          The string to pad\n\t * @param maxLength     The desired length of the string\n\t * @param fillString    The string to be repeated (fully or partially) until text is the maximum length\n\t *\n\t * @return A string that is at least the maximum length specified, padded in the front if necessary.\n\t */\n\texports.padStart = has_1.default('es6-string-padstart')\n\t    ? util_1.wrapNative(String.prototype.padStart)\n\t    : Shim.padStart;\n\t/**\n\t * Pads the end of a string with a fill string until the string is a certain length.\n\t *\n\t * @param text          The string to pad\n\t * @param maxLength     The desired length of the string\n\t * @param fillString    The string to be repeated (fully or partially) until text is the maximum length\n\t *\n\t * @return A string that is at least the maximum length specified, padded at the end if necessary.\n\t */\n\texports.padEnd = has_1.default('es6-string-padend')\n\t    ? util_1.wrapNative(String.prototype.padEnd)\n\t    : Shim.padEnd;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(9);\n\tvar global_1 = __webpack_require__(10);\n\tvar util_1 = __webpack_require__(15);\n\tvar Shim;\n\t(function (Shim) {\n\t    /* tslint:disable-next-line:variable-name */\n\t    var Symbol;\n\t    /* tslint:disable-next-line:variable-name */\n\t    var InternalSymbol;\n\t    var defineProperties = Object.defineProperties;\n\t    var defineProperty = Object.defineProperty;\n\t    var create = Object.create;\n\t    var objPrototype = Object.prototype;\n\t    var globalSymbols = {};\n\t    var getSymbolName = (function () {\n\t        var created = create(null);\n\t        return function (desc) {\n\t            var postfix = 0;\n\t            var name;\n\t            while (created[String(desc) + (postfix || '')]) {\n\t                ++postfix;\n\t            }\n\t            desc += String(postfix || '');\n\t            created[desc] = true;\n\t            name = '@@' + desc;\n\t            // FIXME: Temporary guard until the duplicate execution when testing can be\n\t            // pinned down.\n\t            if (!Object.getOwnPropertyDescriptor(objPrototype, name)) {\n\t                defineProperty(objPrototype, name, {\n\t                    set: function (value) {\n\t                        defineProperty(this, name, util_1.getValueDescriptor(value));\n\t                    }\n\t                });\n\t            }\n\t            return name;\n\t        };\n\t    }());\n\t    InternalSymbol = function Symbol(description) {\n\t        if (this instanceof InternalSymbol) {\n\t            throw new TypeError('TypeError: Symbol is not a constructor');\n\t        }\n\t        return Symbol(description);\n\t    };\n\t    Symbol = function Symbol(description) {\n\t        if (this instanceof Symbol) {\n\t            throw new TypeError('TypeError: Symbol is not a constructor');\n\t        }\n\t        var sym = Object.create(InternalSymbol.prototype);\n\t        description = (description === undefined ? '' : String(description));\n\t        return defineProperties(sym, {\n\t            __description__: util_1.getValueDescriptor(description),\n\t            __name__: util_1.getValueDescriptor(getSymbolName(description))\n\t        });\n\t    };\n\t    /**\n\t     * A custom guard function that determines if an object is a symbol or not\n\t     * @param  {any}       value The value to check to see if it is a symbol or not\n\t     * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)\n\t     */\n\t    function isSymbol(value) {\n\t        return (value && ((typeof value === 'symbol') || (value['@@toStringTag'] === 'Symbol'))) || false;\n\t    }\n\t    Shim.isSymbol = isSymbol;\n\t    /**\n\t     * Throws if the value is not a symbol, used internally within the Shim\n\t     * @param  {any}    value The value to check\n\t     * @return {symbol}       Returns the symbol or throws\n\t     */\n\t    function validateSymbol(value) {\n\t        if (!isSymbol(value)) {\n\t            throw new TypeError(value + ' is not a symbol');\n\t        }\n\t        return value;\n\t    }\n\t    /* Decorate the Symbol function with the appropriate properties */\n\t    defineProperty(Symbol, 'for', util_1.getValueDescriptor(function (key) {\n\t        if (globalSymbols[key]) {\n\t            return globalSymbols[key];\n\t        }\n\t        return (globalSymbols[key] = Symbol(String(key)));\n\t    }));\n\t    defineProperties(Symbol, {\n\t        keyFor: util_1.getValueDescriptor(function (sym) {\n\t            var key;\n\t            validateSymbol(sym);\n\t            for (key in globalSymbols) {\n\t                if (globalSymbols[key] === sym) {\n\t                    return key;\n\t                }\n\t            }\n\t        }),\n\t        hasInstance: util_1.getValueDescriptor(Symbol.for('hasInstance'), false, false),\n\t        isConcatSpreadable: util_1.getValueDescriptor(Symbol.for('isConcatSpreadable'), false, false),\n\t        iterator: util_1.getValueDescriptor(Symbol.for('iterator'), false, false),\n\t        match: util_1.getValueDescriptor(Symbol.for('match'), false, false),\n\t        observable: util_1.getValueDescriptor(Symbol.for('observable'), false, false),\n\t        replace: util_1.getValueDescriptor(Symbol.for('replace'), false, false),\n\t        search: util_1.getValueDescriptor(Symbol.for('search'), false, false),\n\t        species: util_1.getValueDescriptor(Symbol.for('species'), false, false),\n\t        split: util_1.getValueDescriptor(Symbol.for('split'), false, false),\n\t        toPrimitive: util_1.getValueDescriptor(Symbol.for('toPrimitive'), false, false),\n\t        toStringTag: util_1.getValueDescriptor(Symbol.for('toStringTag'), false, false),\n\t        unscopables: util_1.getValueDescriptor(Symbol.for('unscopables'), false, false)\n\t    });\n\t    /* Decorate the InternalSymbol object */\n\t    defineProperties(InternalSymbol.prototype, {\n\t        constructor: util_1.getValueDescriptor(Symbol),\n\t        toString: util_1.getValueDescriptor(function () { return this.__name__; }, false, false)\n\t    });\n\t    /* Decorate the Symbol.prototype */\n\t    defineProperties(Symbol.prototype, {\n\t        toString: util_1.getValueDescriptor(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),\n\t        valueOf: util_1.getValueDescriptor(function () { return validateSymbol(this); })\n\t    });\n\t    defineProperty(Symbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(function () { return validateSymbol(this); }));\n\t    defineProperty(Symbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor('Symbol', false, false, true));\n\t    defineProperty(InternalSymbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(Symbol.prototype[Symbol.toPrimitive], false, false, true));\n\t    defineProperty(InternalSymbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor(Symbol.prototype[Symbol.toStringTag], false, false, true));\n\t    /* tslint:disable-next-line:variable-name */\n\t    Shim.Exposed = Symbol;\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\t/* tslint:disable-next-line:variable-name */\n\tvar SymbolShim = has_1.default('es6-symbol') ? global_1.default.Symbol : global_1.default.Symbol = Shim.Exposed;\n\t/**\n\t * Fill any missing well known symbols if the native Symbol is missing them\n\t */\n\t['hasInstance', 'isConcatSpreadable', 'iterator', 'species', 'replace', 'search', 'split', 'match', 'toPrimitive',\n\t    'toStringTag', 'unscopables', 'observable'].forEach(function (wellKnown) {\n\t    if (!Symbol[wellKnown]) {\n\t        Object.defineProperty(Symbol, wellKnown, util_1.getValueDescriptor(Symbol.for(wellKnown), false, false));\n\t    }\n\t});\n\texports.isSymbol = Shim.isSymbol;\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = SymbolShim;\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar global_1 = __webpack_require__(10);\n\t/**\n\t * The smallest interval between two representable numbers.\n\t */\n\texports.EPSILON = 1;\n\t/**\n\t * The maximum safe integer in JavaScript\n\t */\n\texports.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t/**\n\t * The minimum safe integer in JavaScript\n\t */\n\texports.MIN_SAFE_INTEGER = -exports.MAX_SAFE_INTEGER;\n\t/**\n\t * Determines whether the passed value is NaN without coersion.\n\t *\n\t * @param value The value to test\n\t * @return true if the value is NaN, false if it is not\n\t */\n\tfunction isNaN(value) {\n\t    return typeof value === 'number' && global_1.default.isNaN(value);\n\t}\n\texports.isNaN = isNaN;\n\t/**\n\t * Determines whether the passed value is a finite number without coersion.\n\t *\n\t * @param value The value to test\n\t * @return true if the value is finite, false if it is not\n\t */\n\tfunction isFinite(value) {\n\t    return typeof value === 'number' && global_1.default.isFinite(value);\n\t}\n\texports.isFinite = isFinite;\n\t/**\n\t * Determines whether the passed value is an integer.\n\t *\n\t * @param value The value to test\n\t * @return true if the value is an integer, false if it is not\n\t */\n\tfunction isInteger(value) {\n\t    return isFinite(value) && Math.floor(value) === value;\n\t}\n\texports.isInteger = isInteger;\n\t/**\n\t * Determines whether the passed value is an integer that is 'safe,' meaning:\n\t *   1. it can be expressed as an IEEE-754 double precision number\n\t *   2. it has a one-to-one mapping to a mathematical integer, meaning its\n\t *      IEEE-754 representation cannot be the result of rounding any other\n\t *      integer to fit the IEEE-754 representation\n\t *\n\t * @param value The value to test\n\t * @return true if the value is an integer, false if it is not\n\t */\n\tfunction isSafeInteger(value) {\n\t    return isInteger(value) && Math.abs(value) <= exports.MAX_SAFE_INTEGER;\n\t}\n\texports.isSafeInteger = isSafeInteger;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar decorators_1 = __webpack_require__(21);\n\tvar global_1 = __webpack_require__(10);\n\tvar iterator_1 = __webpack_require__(16);\n\t__webpack_require__(18);\n\tvar Shim;\n\t(function (Shim) {\n\t    var DELETED = {};\n\t    function getUID() {\n\t        return Math.floor(Math.random() * 100000000);\n\t    }\n\t    var generateName = (function () {\n\t        var startId = Math.floor(Date.now() % 100000000);\n\t        return function generateName() {\n\t            return '__wm' + getUID() + (startId++ + '__');\n\t        };\n\t    })();\n\t    var WeakMap = (function () {\n\t        function WeakMap(iterable) {\n\t            var _this = this;\n\t            this[Symbol.toStringTag] = 'WeakMap';\n\t            Object.defineProperty(this, '_name', {\n\t                value: generateName()\n\t            });\n\t            this._frozenEntries = [];\n\t            if (iterable) {\n\t                iterator_1.forOf(iterable, function (_a) {\n\t                    var key = _a[0], value = _a[1];\n\t                    return _this.set(key, value);\n\t                });\n\t            }\n\t        }\n\t        WeakMap.prototype._getFrozenEntryIndex = function (key) {\n\t            for (var i = 0; i < this._frozenEntries.length; i++) {\n\t                if (this._frozenEntries[i].key === key) {\n\t                    return i;\n\t                }\n\t            }\n\t            return -1;\n\t        };\n\t        WeakMap.prototype.delete = function (key) {\n\t            if (key === undefined || key === null) {\n\t                return false;\n\t            }\n\t            var entry = key[this._name];\n\t            if (entry && entry.key === key && entry.value !== DELETED) {\n\t                entry.value = DELETED;\n\t                return true;\n\t            }\n\t            var frozenIndex = this._getFrozenEntryIndex(key);\n\t            if (frozenIndex >= 0) {\n\t                this._frozenEntries.splice(frozenIndex, 1);\n\t                return true;\n\t            }\n\t            return false;\n\t        };\n\t        WeakMap.prototype.get = function (key) {\n\t            if (key === undefined || key === null) {\n\t                return undefined;\n\t            }\n\t            var entry = key[this._name];\n\t            if (entry && entry.key === key && entry.value !== DELETED) {\n\t                return entry.value;\n\t            }\n\t            var frozenIndex = this._getFrozenEntryIndex(key);\n\t            if (frozenIndex >= 0) {\n\t                return this._frozenEntries[frozenIndex].value;\n\t            }\n\t        };\n\t        WeakMap.prototype.has = function (key) {\n\t            if (key === undefined || key === null) {\n\t                return false;\n\t            }\n\t            var entry = key[this._name];\n\t            if (Boolean(entry && entry.key === key && entry.value !== DELETED)) {\n\t                return true;\n\t            }\n\t            var frozenIndex = this._getFrozenEntryIndex(key);\n\t            if (frozenIndex >= 0) {\n\t                return true;\n\t            }\n\t            return false;\n\t        };\n\t        WeakMap.prototype.set = function (key, value) {\n\t            if (!key || (typeof key !== 'object' && typeof key !== 'function')) {\n\t                throw new TypeError('Invalid value used as weak map key');\n\t            }\n\t            var entry = key[this._name];\n\t            if (!entry || entry.key !== key) {\n\t                entry = Object.create(null, {\n\t                    key: { value: key }\n\t                });\n\t                if (Object.isFrozen(key)) {\n\t                    this._frozenEntries.push(entry);\n\t                }\n\t                else {\n\t                    Object.defineProperty(key, this._name, {\n\t                        value: entry\n\t                    });\n\t                }\n\t            }\n\t            entry.value = value;\n\t            return this;\n\t        };\n\t        return WeakMap;\n\t    }());\n\t    Shim.WeakMap = WeakMap;\n\t})(Shim || (Shim = {}));\n\tvar WeakMap = (function () {\n\t    /* istanbul ignore next */\n\t    function WeakMap(iterable) {\n\t        /* istanbul ignore next */\n\t        this[Symbol.toStringTag] = 'WeakMap';\n\t    }\n\t    /* istanbul ignore next */\n\t    WeakMap.prototype.delete = function (key) { throw new Error(); };\n\t    /* istanbul ignore next */\n\t    WeakMap.prototype.get = function (key) { throw new Error(); };\n\t    /* istanbul ignore next */\n\t    WeakMap.prototype.has = function (key) { throw new Error(); };\n\t    /* istanbul ignore next */\n\t    WeakMap.prototype.set = function (key, value) { throw new Error(); };\n\t    return WeakMap;\n\t}());\n\tWeakMap = __decorate([\n\t    decorators_1.hasClass('es6-weakmap', global_1.default.WeakMap, Shim.WeakMap)\n\t], WeakMap);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = WeakMap;\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(9);\n\t/**\n\t * A class decorator that provides either a native class or a shimmed class based on a feature\n\t * test\n\t * @param feature The has feature to check\n\t * @param trueClass The class to use if feature test returns `true`\n\t * @param falseClass The class to use if the feature test returns `false` or is not defined\n\t */\n\tfunction hasClass(feature, trueClass, falseClass) {\n\t    return function (target) {\n\t        return has_1.default(feature) ? trueClass : falseClass;\n\t    };\n\t}\n\texports.hasClass = hasClass;\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar WeakMap_1 = __webpack_require__(20);\n\t/**\n\t * Types of advice\n\t */\n\tvar AdviceType;\n\t(function (AdviceType) {\n\t    AdviceType[AdviceType[\"Before\"] = 0] = \"Before\";\n\t    AdviceType[AdviceType[\"After\"] = 1] = \"After\";\n\t    AdviceType[AdviceType[\"Around\"] = 2] = \"Around\";\n\t})(AdviceType = exports.AdviceType || (exports.AdviceType = {}));\n\t/**\n\t * A weak map of dispatchers used to apply the advice\n\t */\n\tvar dispatchAdviceMap = new WeakMap_1.default();\n\t/**\n\t * Returns the dispatcher function for a given joinPoint (method/function)\n\t *\n\t * @param joinPoint The function that is to be advised\n\t */\n\tfunction getDispatcher(joinPoint) {\n\t    function dispatcher() {\n\t        var _this = this;\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        var _a = dispatchAdviceMap.get(dispatcher), before = _a.before, after = _a.after, joinPoint = _a.joinPoint;\n\t        if (before) {\n\t            args = before.reduce(function (previousArgs, advice) {\n\t                var currentArgs = advice.apply(_this, previousArgs);\n\t                return currentArgs || previousArgs;\n\t            }, args);\n\t        }\n\t        var result = joinPoint.apply(this, args);\n\t        if (after) {\n\t            result = after.reduce(function (previousResult, advice) {\n\t                return advice.apply(_this, [previousResult].concat(args));\n\t            }, result);\n\t        }\n\t        return result;\n\t    }\n\t    /* We want to \"clone\" the advice that has been applied already, if this\n\t     * joinPoint is already advised */\n\t    if (dispatchAdviceMap.has(joinPoint)) {\n\t        var adviceMap = dispatchAdviceMap.get(joinPoint);\n\t        var before_1 = adviceMap.before, after_1 = adviceMap.after;\n\t        if (before_1) {\n\t            before_1 = before_1.slice(0);\n\t        }\n\t        if (after_1) {\n\t            after_1 = after_1.slice(0);\n\t        }\n\t        dispatchAdviceMap.set(dispatcher, {\n\t            joinPoint: adviceMap.joinPoint,\n\t            before: before_1,\n\t            after: after_1\n\t        });\n\t    }\n\t    else {\n\t        dispatchAdviceMap.set(dispatcher, { joinPoint: joinPoint });\n\t    }\n\t    return dispatcher;\n\t}\n\t/**\n\t * Advise a join point (function) with supplied advice\n\t *\n\t * @param joinPoint The function to be advised\n\t * @param type The type of advice to be applied\n\t * @param advice The advice to apply\n\t */\n\tfunction advise(joinPoint, type, advice) {\n\t    var dispatcher;\n\t    if (type === AdviceType.Around) {\n\t        dispatcher = getDispatcher(advice.apply(this, [joinPoint]));\n\t    }\n\t    else {\n\t        dispatcher = getDispatcher(joinPoint);\n\t        var adviceMap = dispatchAdviceMap.get(dispatcher);\n\t        if (type === AdviceType.Before) {\n\t            (adviceMap.before || (adviceMap.before = [])).unshift(advice);\n\t        }\n\t        else {\n\t            (adviceMap.after || (adviceMap.after = [])).push(advice);\n\t        }\n\t    }\n\t    return dispatcher;\n\t}\n\t/**\n\t * Apply advice *before* the supplied joinPoint (function)\n\t *\n\t * @param joinPoint A function that should have advice applied to\n\t * @param advice The before advice\n\t */\n\tfunction before(joinPoint, advice) {\n\t    return advise(joinPoint, AdviceType.Before, advice);\n\t}\n\texports.before = before;\n\t/**\n\t * Apply advice *after* the supplied joinPoint (function)\n\t *\n\t * @param joinPoint A function that should have advice applied to\n\t * @param advice The after advice\n\t */\n\tfunction after(joinPoint, advice) {\n\t    return advise(joinPoint, AdviceType.After, advice);\n\t}\n\texports.after = after;\n\t/**\n\t * Apply advice *around* the supplied joinPoint (function)\n\t *\n\t * @param joinPoint A function that should have advice applied to\n\t * @param advice The around advice\n\t */\n\tfunction around(joinPoint, advice) {\n\t    return advise(joinPoint, AdviceType.Around, advice);\n\t}\n\texports.around = around;\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar global_1 = __webpack_require__(10);\n\tvar queue_1 = __webpack_require__(24);\n\tvar iterator_1 = __webpack_require__(16);\n\t__webpack_require__(18);\n\tvar decorators_1 = __webpack_require__(21);\n\tvar Shim;\n\t(function (Shim) {\n\t    /**\n\t     * Returns true if a given value has a `then` method.\n\t     * @param {any} value The value to check if is Thenable\n\t     * @returns {is Thenable<T>} A type guard if the value is thenable\n\t     */\n\t    function isThenable(value) {\n\t        return value && typeof value.then === 'function';\n\t    }\n\t    Shim.isThenable = isThenable;\n\t    /**\n\t     * Promise is a partial implementation of the ES2015 Promise specification. It relies on Promise to do some safety\n\t     * checks such as verifying that a Promise isn't resolved with itself. This class is exported for testability, and is\n\t     * not intended to be used directly.\n\t     *\n\t     * @borrows Promise.all as Promise.all\n\t     * @borrows Promise.race as Promise.race\n\t     * @borrows Promise.reject as Promise.reject\n\t     * @borrows Promise.resolve as Promise.resolve\n\t     * @borrows Promise#catch as Promise#catch\n\t     * @borrows Promise#then as Promise#then\n\t     */\n\t    var Promise = (function () {\n\t        /**\n\t         * Creates a new Promise.\n\t         *\n\t         * @constructor\n\t         *\n\t         * @param executor\n\t         * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t         * starting the asynchronous operation when it is invoked.\n\t         *\n\t         * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t         * successfully, or the `reject` function when the operation fails.\n\t         */\n\t        function Promise(executor) {\n\t            var _this = this;\n\t            /**\n\t             * The current state of this promise.\n\t             */\n\t            this.state = 1 /* Pending */;\n\t            this[Symbol.toStringTag] = 'Promise';\n\t            /**\n\t             * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n\t             */\n\t            var isChained = false;\n\t            /**\n\t             * Whether or not this promise is in a resolved state.\n\t             */\n\t            var isResolved = function () {\n\t                return _this.state !== 1 /* Pending */ || isChained;\n\t            };\n\t            /**\n\t             * Callbacks that should be invoked once the asynchronous operation has completed.\n\t             */\n\t            var callbacks = [];\n\t            /**\n\t             * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n\t             * enqueues callbacks for execution on the next event loop turn.\n\t             */\n\t            var whenFinished = function (callback) {\n\t                if (callbacks) {\n\t                    callbacks.push(callback);\n\t                }\n\t            };\n\t            /**\n\t             * Settles this promise.\n\t             *\n\t             * @param newState The resolved state for this promise.\n\t             * @param {T|any} value The resolved value for this promise.\n\t             */\n\t            var settle = function (newState, value) {\n\t                // A promise can only be settled once.\n\t                if (_this.state !== 1 /* Pending */) {\n\t                    return;\n\t                }\n\t                _this.state = newState;\n\t                _this.resolvedValue = value;\n\t                whenFinished = queue_1.queueMicroTask;\n\t                // Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n\t                // wait an extra turn.\n\t                if (callbacks && callbacks.length > 0) {\n\t                    queue_1.queueMicroTask(function () {\n\t                        if (callbacks) {\n\t                            var count = callbacks.length;\n\t                            for (var i = 0; i < count; ++i) {\n\t                                callbacks[i].call(null);\n\t                            }\n\t                            callbacks = null;\n\t                        }\n\t                    });\n\t                }\n\t            };\n\t            /**\n\t             * Resolves this promise.\n\t             *\n\t             * @param newState The resolved state for this promise.\n\t             * @param {T|any} value The resolved value for this promise.\n\t             */\n\t            var resolve = function (newState, value) {\n\t                if (isResolved()) {\n\t                    return;\n\t                }\n\t                if (isThenable(value)) {\n\t                    value.then(settle.bind(null, 0 /* Fulfilled */), settle.bind(null, 2 /* Rejected */));\n\t                    isChained = true;\n\t                }\n\t                else {\n\t                    settle(newState, value);\n\t                }\n\t            };\n\t            this.then = function (onFulfilled, onRejected) {\n\t                return new Promise(function (resolve, reject) {\n\t                    // whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n\t                    // promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n\t                    // event loop.\n\t                    whenFinished(function () {\n\t                        var callback = _this.state === 2 /* Rejected */ ? onRejected : onFulfilled;\n\t                        if (typeof callback === 'function') {\n\t                            try {\n\t                                resolve(callback(_this.resolvedValue));\n\t                            }\n\t                            catch (error) {\n\t                                reject(error);\n\t                            }\n\t                        }\n\t                        else if (_this.state === 2 /* Rejected */) {\n\t                            reject(_this.resolvedValue);\n\t                        }\n\t                        else {\n\t                            resolve(_this.resolvedValue);\n\t                        }\n\t                    });\n\t                });\n\t            };\n\t            try {\n\t                executor(resolve.bind(null, 0 /* Fulfilled */), resolve.bind(null, 2 /* Rejected */));\n\t            }\n\t            catch (error) {\n\t                settle(2 /* Rejected */, error);\n\t            }\n\t        }\n\t        Promise.all = function (iterable) {\n\t            return new this(function (resolve, reject) {\n\t                var values = [];\n\t                var complete = 0;\n\t                var total = 0;\n\t                var populating = true;\n\t                function fulfill(index, value) {\n\t                    values[index] = value;\n\t                    ++complete;\n\t                    finish();\n\t                }\n\t                function finish() {\n\t                    if (populating || complete < total) {\n\t                        return;\n\t                    }\n\t                    resolve(values);\n\t                }\n\t                function processItem(index, item) {\n\t                    ++total;\n\t                    if (isThenable(item)) {\n\t                        // If an item Promise rejects, this Promise is immediately rejected with the item\n\t                        // Promise's rejection error.\n\t                        item.then(fulfill.bind(null, index), reject);\n\t                    }\n\t                    else {\n\t                        Promise.resolve(item).then(fulfill.bind(null, index));\n\t                    }\n\t                }\n\t                var i = 0;\n\t                iterator_1.forOf(iterable, function (value) {\n\t                    processItem(i, value);\n\t                    i++;\n\t                });\n\t                populating = false;\n\t                finish();\n\t            });\n\t        };\n\t        Promise.race = function (iterable) {\n\t            return new this(function (resolve, reject) {\n\t                iterator_1.forOf(iterable, function (item) {\n\t                    if (item instanceof Promise) {\n\t                        // If a Promise item rejects, this Promise is immediately rejected with the item\n\t                        // Promise's rejection error.\n\t                        item.then(resolve, reject);\n\t                    }\n\t                    else {\n\t                        Promise.resolve(item).then(resolve);\n\t                    }\n\t                });\n\t            });\n\t        };\n\t        Promise.reject = function (reason) {\n\t            return new this(function (resolve, reject) {\n\t                reject(reason);\n\t            });\n\t        };\n\t        Promise.resolve = function (value) {\n\t            return new this(function (resolve) {\n\t                resolve(value);\n\t            });\n\t        };\n\t        Promise.prototype.catch = function (onRejected) {\n\t            return this.then(undefined, onRejected);\n\t        };\n\t        return Promise;\n\t    }());\n\t    Shim.Promise = Promise;\n\t})(Shim || (Shim = {}));\n\tvar Promise = (function () {\n\t    /**\n\t     * Creates a new Promise.\n\t     *\n\t     * @constructor\n\t     *\n\t     * @param executor\n\t     * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t     * starting the asynchronous operation when it is invoked.\n\t     *\n\t     * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t     * successfully, or the `reject` function when the operation fails.\n\t     */\n\t    /* istanbul ignore next */\n\t    function Promise(executor) {\n\t    }\n\t    /**\n\t     * Converts an iterable object containing promises into a single promise that resolves to a new iterable object\n\t     * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the\n\t     * iterable. Iterable values that are not promises are converted to promises using Promise.resolve.\n\t     *\n\t     * @example\n\t     * Promise.all([ Promise.resolve('foo'), 'bar' ]).then(function (value) {\n\t     *     value[0] === 'foo'; // true\n\t     *     value[1] === 'bar'; // true\n\t     * });\n\t     *\n\t     * @example\n\t     * Promise.all({\n\t     *     foo: Promise.resolve('foo'),\n\t     *     bar: 'bar'\n\t     * }).then((value) => {\n\t     *     value.foo === 'foo'; // true\n\t     *     value.bar === 'bar'; // true\n\t     * });\n\t     */\n\t    /* istanbul ignore next */\n\t    Promise.all = function (iterable) {\n\t        throw new Error();\n\t    };\n\t    ;\n\t    /**\n\t     * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of\n\t     * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in\n\t     * the iterable that are not Promises are converted to Promises with Promise.resolve.\n\t     *\n\t     * @example\n\t     * Promise.race([ Promise.resolve('foo'), Promise.resolve('bar') ]).then((value) => {\n\t     *     value === 'foo'; // true\n\t     * });\n\t     *\n\t     * @example\n\t     * Promise.race({\n\t     *     foo: Promise.resolve('foo'),\n\t     *     bar: Promise.resolve('bar')\n\t     * }).then((value) => {\n\t     *     value === 'foo'; // true\n\t     * });\n\t     */\n\t    /* istanbul ignore next */\n\t    Promise.race = function (iterable) {\n\t        throw new Error();\n\t    };\n\t    /**\n\t     * Creates a new promise that is rejected with the given error.\n\t     */\n\t    /* istanbul ignore next */\n\t    Promise.reject = function (reason) {\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    Promise.resolve = function (value) {\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    Promise.prototype.catch = function (onRejected) {\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    Promise.prototype.then = function (onFulfilled, onRejected) {\n\t        throw new Error();\n\t    };\n\t    return Promise;\n\t}());\n\tPromise = __decorate([\n\t    decorators_1.hasClass('es6-promise', global_1.default.Promise, Shim.Promise)\n\t], Promise);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Promise;\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(clearImmediate, setImmediate, process) {\"use strict\";\n\tvar global_1 = __webpack_require__(10);\n\tvar has_1 = __webpack_require__(9);\n\t/**\n\t * Executes a task\n\t * @param item The task to execute\n\t */\n\tfunction executeTask(item) {\n\t    if (item && item.isActive) {\n\t        item.callback();\n\t    }\n\t}\n\t/**\n\t * Get a handle to be able to remove an item from the queue\n\t */\n\tfunction getQueueHandle(item, destructor) {\n\t    return {\n\t        destroy: function () {\n\t            this.destroy = function () { };\n\t            if (item) {\n\t                item.isActive = false;\n\t            }\n\t            if (destructor) {\n\t                destructor();\n\t            }\n\t        }\n\t    };\n\t}\n\tvar microTasks = [];\n\tvar microTaskQueued = false;\n\tvar checkMicroTaskQueue = function () { };\n\t/**\n\t * Schedules a callback to the macrotask queue.\n\t *\n\t * @param callback the function to be queued and later executed.\n\t * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n\t */\n\texports.queueTask = (function () {\n\t    var destructor;\n\t    var enqueue;\n\t    /* IE and Edge's setImmediate does not always resolve as a macro task, sometimes as a microtask */\n\t    if (has_1.default('postmessage')) {\n\t        var queue_1 = [];\n\t        addEventListener('message', function (event) {\n\t            // Confirm that the event was triggered by the current window and by this particular implementation.\n\t            if (event.source === global_1.default && event.data === 'dojo-queue-message') {\n\t                event.stopPropagation();\n\t                if (queue_1.length) {\n\t                    executeTask(queue_1.shift());\n\t                }\n\t            }\n\t        });\n\t        enqueue = function (item) {\n\t            queue_1.push(item);\n\t            postMessage('dojo-queue-message', '*');\n\t        };\n\t    }\n\t    else if (has_1.default('setimmediate')) {\n\t        destructor = clearImmediate;\n\t        enqueue = function (item) {\n\t            return setImmediate(executeTask.bind(null, item));\n\t        };\n\t    }\n\t    else {\n\t        destructor = clearTimeout;\n\t        enqueue = function (item) {\n\t            return setTimeout(executeTask.bind(null, item), 0);\n\t        };\n\t    }\n\t    function queueTask(callback) {\n\t        var item = {\n\t            isActive: true,\n\t            callback: callback\n\t        };\n\t        var id = enqueue(item);\n\t        return getQueueHandle(item, destructor && function () {\n\t            destructor(id);\n\t        });\n\t    }\n\t    ;\n\t    // TODO: Use aspect.before when it is available.\n\t    return has_1.default('microtasks') ? queueTask : function (callback) {\n\t        checkMicroTaskQueue();\n\t        return queueTask(callback);\n\t    };\n\t})();\n\tcheckMicroTaskQueue = !has_1.default('microtasks')\n\t    ? function () {\n\t        if (!microTaskQueued) {\n\t            microTaskQueued = true;\n\t            exports.queueTask(function () {\n\t                microTaskQueued = false;\n\t                if (microTasks.length) {\n\t                    var item = void 0;\n\t                    while (item = microTasks.shift()) {\n\t                        executeTask(item);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t    } : checkMicroTaskQueue;\n\t/**\n\t * Schedules a callback to the microtask queue.\n\t *\n\t * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native\n\t * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask\n\t * registered with `queueTask` or `queueAnimationTask`.\n\t *\n\t * @param callback the function to be queued and later executed.\n\t * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n\t */\n\texports.queueMicroTask = (function () {\n\t    var enqueue;\n\t    if (has_1.default('host-node')) {\n\t        enqueue = function (item) {\n\t            process.nextTick(executeTask.bind(null, item));\n\t        };\n\t    }\n\t    else if (has_1.default('es6-promise') && !has_1.default('setimmediate') && !has_1.default('host-node')) {\n\t        enqueue = function (item) {\n\t            global_1.default.Promise.resolve(item).then(executeTask);\n\t        };\n\t    }\n\t    else if (has_1.default('dom-mutationobserver')) {\n\t        /* tslint:disable-next-line:variable-name */\n\t        var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;\n\t        var node_1 = document.createElement('div');\n\t        var queue_2 = [];\n\t        var observer = new HostMutationObserver(function () {\n\t            while (queue_2.length > 0) {\n\t                var item = queue_2.shift();\n\t                if (item && item.isActive) {\n\t                    item.callback();\n\t                }\n\t            }\n\t        });\n\t        observer.observe(node_1, { attributes: true });\n\t        enqueue = function (item) {\n\t            queue_2.push(item);\n\t            node_1.setAttribute('queueStatus', '1');\n\t        };\n\t    }\n\t    else {\n\t        enqueue = function (item) {\n\t            checkMicroTaskQueue();\n\t            microTasks.push(item);\n\t        };\n\t    }\n\t    return function (callback) {\n\t        var item = {\n\t            isActive: true,\n\t            callback: callback\n\t        };\n\t        enqueue(item);\n\t        return getQueueHandle(item);\n\t    };\n\t})();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25).clearImmediate, __webpack_require__(25).setImmediate, __webpack_require__(12)))\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar apply = Function.prototype.apply;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) {\n\t  if (timeout) {\n\t    timeout.close();\n\t  }\n\t};\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// setimmediate attaches itself to the global object\n\t__webpack_require__(26);\n\texports.setImmediate = setImmediate;\n\texports.clearImmediate = clearImmediate;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n\t    \"use strict\";\n\t\n\t    if (global.setImmediate) {\n\t        return;\n\t    }\n\t\n\t    var nextHandle = 1; // Spec says greater than zero\n\t    var tasksByHandle = {};\n\t    var currentlyRunningATask = false;\n\t    var doc = global.document;\n\t    var registerImmediate;\n\t\n\t    function setImmediate(callback) {\n\t      // Callback can either be a function or a string\n\t      if (typeof callback !== \"function\") {\n\t        callback = new Function(\"\" + callback);\n\t      }\n\t      // Copy function arguments\n\t      var args = new Array(arguments.length - 1);\n\t      for (var i = 0; i < args.length; i++) {\n\t          args[i] = arguments[i + 1];\n\t      }\n\t      // Store and register the task\n\t      var task = { callback: callback, args: args };\n\t      tasksByHandle[nextHandle] = task;\n\t      registerImmediate(nextHandle);\n\t      return nextHandle++;\n\t    }\n\t\n\t    function clearImmediate(handle) {\n\t        delete tasksByHandle[handle];\n\t    }\n\t\n\t    function run(task) {\n\t        var callback = task.callback;\n\t        var args = task.args;\n\t        switch (args.length) {\n\t        case 0:\n\t            callback();\n\t            break;\n\t        case 1:\n\t            callback(args[0]);\n\t            break;\n\t        case 2:\n\t            callback(args[0], args[1]);\n\t            break;\n\t        case 3:\n\t            callback(args[0], args[1], args[2]);\n\t            break;\n\t        default:\n\t            callback.apply(undefined, args);\n\t            break;\n\t        }\n\t    }\n\t\n\t    function runIfPresent(handle) {\n\t        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n\t        // So if we're currently running a task, we'll need to delay this invocation.\n\t        if (currentlyRunningATask) {\n\t            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n\t            // \"too much recursion\" error.\n\t            setTimeout(runIfPresent, 0, handle);\n\t        } else {\n\t            var task = tasksByHandle[handle];\n\t            if (task) {\n\t                currentlyRunningATask = true;\n\t                try {\n\t                    run(task);\n\t                } finally {\n\t                    clearImmediate(handle);\n\t                    currentlyRunningATask = false;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function installNextTickImplementation() {\n\t        registerImmediate = function(handle) {\n\t            process.nextTick(function () { runIfPresent(handle); });\n\t        };\n\t    }\n\t\n\t    function canUsePostMessage() {\n\t        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n\t        // where `global.postMessage` means something completely different and can't be used for this purpose.\n\t        if (global.postMessage && !global.importScripts) {\n\t            var postMessageIsAsynchronous = true;\n\t            var oldOnMessage = global.onmessage;\n\t            global.onmessage = function() {\n\t                postMessageIsAsynchronous = false;\n\t            };\n\t            global.postMessage(\"\", \"*\");\n\t            global.onmessage = oldOnMessage;\n\t            return postMessageIsAsynchronous;\n\t        }\n\t    }\n\t\n\t    function installPostMessageImplementation() {\n\t        // Installs an event handler on `global` for the `message` event: see\n\t        // * https://developer.mozilla.org/en/DOM/window.postMessage\n\t        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\t\n\t        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\t        var onGlobalMessage = function(event) {\n\t            if (event.source === global &&\n\t                typeof event.data === \"string\" &&\n\t                event.data.indexOf(messagePrefix) === 0) {\n\t                runIfPresent(+event.data.slice(messagePrefix.length));\n\t            }\n\t        };\n\t\n\t        if (global.addEventListener) {\n\t            global.addEventListener(\"message\", onGlobalMessage, false);\n\t        } else {\n\t            global.attachEvent(\"onmessage\", onGlobalMessage);\n\t        }\n\t\n\t        registerImmediate = function(handle) {\n\t            global.postMessage(messagePrefix + handle, \"*\");\n\t        };\n\t    }\n\t\n\t    function installMessageChannelImplementation() {\n\t        var channel = new MessageChannel();\n\t        channel.port1.onmessage = function(event) {\n\t            var handle = event.data;\n\t            runIfPresent(handle);\n\t        };\n\t\n\t        registerImmediate = function(handle) {\n\t            channel.port2.postMessage(handle);\n\t        };\n\t    }\n\t\n\t    function installReadyStateChangeImplementation() {\n\t        var html = doc.documentElement;\n\t        registerImmediate = function(handle) {\n\t            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t            var script = doc.createElement(\"script\");\n\t            script.onreadystatechange = function () {\n\t                runIfPresent(handle);\n\t                script.onreadystatechange = null;\n\t                html.removeChild(script);\n\t                script = null;\n\t            };\n\t            html.appendChild(script);\n\t        };\n\t    }\n\t\n\t    function installSetTimeoutImplementation() {\n\t        registerImmediate = function(handle) {\n\t            setTimeout(runIfPresent, 0, handle);\n\t        };\n\t    }\n\t\n\t    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\t    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n\t    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\t\n\t    // Don't get fooled by e.g. browserify environments.\n\t    if ({}.toString.call(global.process) === \"[object process]\") {\n\t        // For Node.js before 0.9\n\t        installNextTickImplementation();\n\t\n\t    } else if (canUsePostMessage()) {\n\t        // For non-IE10 modern browsers\n\t        installPostMessageImplementation();\n\t\n\t    } else if (global.MessageChannel) {\n\t        // For web workers, where supported\n\t        installMessageChannelImplementation();\n\t\n\t    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n\t        // For IE 6–8\n\t        installReadyStateChangeImplementation();\n\t\n\t    } else {\n\t        // For older browsers\n\t        installSetTimeoutImplementation();\n\t    }\n\t\n\t    attachTo.setImmediate = setImmediate;\n\t    attachTo.clearImmediate = clearImmediate;\n\t}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(12)))\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n\t        // CommonJS\n\t        factory(exports);\n\t    } else {\n\t        // Browser globals\n\t        factory(root.maquette = {});\n\t    }\n\t}(this, function (exports) {\n\t    'use strict';\n\t    ;\n\t    ;\n\t    ;\n\t    ;\n\t    var NAMESPACE_W3 = 'http://www.w3.org/';\n\t    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\n\t    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n\t    // Utilities\n\t    var emptyArray = [];\n\t    var extend = function (base, overrides) {\n\t        var result = {};\n\t        Object.keys(base).forEach(function (key) {\n\t            result[key] = base[key];\n\t        });\n\t        if (overrides) {\n\t            Object.keys(overrides).forEach(function (key) {\n\t                result[key] = overrides[key];\n\t            });\n\t        }\n\t        return result;\n\t    };\n\t    // Hyperscript helper functions\n\t    var same = function (vnode1, vnode2) {\n\t        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n\t            return false;\n\t        }\n\t        if (vnode1.properties && vnode2.properties) {\n\t            if (vnode1.properties.key !== vnode2.properties.key) {\n\t                return false;\n\t            }\n\t            return vnode1.properties.bind === vnode2.properties.bind;\n\t        }\n\t        return !vnode1.properties && !vnode2.properties;\n\t    };\n\t    var toTextVNode = function (data) {\n\t        return {\n\t            vnodeSelector: '',\n\t            properties: undefined,\n\t            children: undefined,\n\t            text: data.toString(),\n\t            domNode: null\n\t        };\n\t    };\n\t    var appendChildren = function (parentSelector, insertions, main) {\n\t        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\n\t            var item = insertions[i];\n\t            if (Array.isArray(item)) {\n\t                appendChildren(parentSelector, item, main);\n\t            } else {\n\t                if (item !== null && item !== undefined) {\n\t                    if (!item.hasOwnProperty('vnodeSelector')) {\n\t                        item = toTextVNode(item);\n\t                    }\n\t                    main.push(item);\n\t                }\n\t            }\n\t        }\n\t    };\n\t    // Render helper functions\n\t    var missingTransition = function () {\n\t        throw new Error('Provide a transitions object to the projectionOptions to do animations');\n\t    };\n\t    var DEFAULT_PROJECTION_OPTIONS = {\n\t        namespace: undefined,\n\t        eventHandlerInterceptor: undefined,\n\t        styleApplyer: function (domNode, styleName, value) {\n\t            // Provides a hook to add vendor prefixes for browsers that still need it.\n\t            domNode.style[styleName] = value;\n\t        },\n\t        transitions: {\n\t            enter: missingTransition,\n\t            exit: missingTransition\n\t        }\n\t    };\n\t    var applyDefaultProjectionOptions = function (projectorOptions) {\n\t        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n\t    };\n\t    var checkStyleValue = function (styleValue) {\n\t        if (typeof styleValue !== 'string') {\n\t            throw new Error('Style values must be strings');\n\t        }\n\t    };\n\t    var setProperties = function (domNode, properties, projectionOptions) {\n\t        if (!properties) {\n\t            return;\n\t        }\n\t        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n\t        var propNames = Object.keys(properties);\n\t        var propCount = propNames.length;\n\t        for (var i = 0; i < propCount; i++) {\n\t            var propName = propNames[i];\n\t            /* tslint:disable:no-var-keyword: edge case */\n\t            var propValue = properties[propName];\n\t            /* tslint:enable:no-var-keyword */\n\t            if (propName === 'className') {\n\t                throw new Error('Property \"className\" is not supported, use \"class\".');\n\t            } else if (propName === 'class') {\n\t                propValue.split(/\\s+/).forEach(function (token) {\n\t                    return domNode.classList.add(token);\n\t                });\n\t            } else if (propName === 'classes') {\n\t                // object with string keys and boolean values\n\t                var classNames = Object.keys(propValue);\n\t                var classNameCount = classNames.length;\n\t                for (var j = 0; j < classNameCount; j++) {\n\t                    var className = classNames[j];\n\t                    if (propValue[className]) {\n\t                        domNode.classList.add(className);\n\t                    }\n\t                }\n\t            } else if (propName === 'styles') {\n\t                // object with string keys and string (!) values\n\t                var styleNames = Object.keys(propValue);\n\t                var styleCount = styleNames.length;\n\t                for (var j = 0; j < styleCount; j++) {\n\t                    var styleName = styleNames[j];\n\t                    var styleValue = propValue[styleName];\n\t                    if (styleValue) {\n\t                        checkStyleValue(styleValue);\n\t                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n\t                    }\n\t                }\n\t            } else if (propName === 'key') {\n\t                continue;\n\t            } else if (propValue === null || propValue === undefined) {\n\t                continue;\n\t            } else {\n\t                var type = typeof propValue;\n\t                if (type === 'function') {\n\t                    if (propName.lastIndexOf('on', 0) === 0) {\n\t                        if (eventHandlerInterceptor) {\n\t                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers\n\t                        }\n\t                        if (propName === 'oninput') {\n\t                            (function () {\n\t                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n\t                                var oldPropValue = propValue;\n\t                                propValue = function (evt) {\n\t                                    evt.target['oninput-value'] = evt.target.value;\n\t                                    // may be HTMLTextAreaElement as well\n\t                                    oldPropValue.apply(this, [evt]);\n\t                                };\n\t                            }());\n\t                        }\n\t                        domNode[propName] = propValue;\n\t                    }\n\t                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n\t                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n\t                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n\t                    } else {\n\t                        domNode.setAttribute(propName, propValue);\n\t                    }\n\t                } else {\n\t                    domNode[propName] = propValue;\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n\t        if (!properties) {\n\t            return;\n\t        }\n\t        var propertiesUpdated = false;\n\t        var propNames = Object.keys(properties);\n\t        var propCount = propNames.length;\n\t        for (var i = 0; i < propCount; i++) {\n\t            var propName = propNames[i];\n\t            // assuming that properties will be nullified instead of missing is by design\n\t            var propValue = properties[propName];\n\t            var previousValue = previousProperties[propName];\n\t            if (propName === 'class') {\n\t                if (previousValue !== propValue) {\n\t                    throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n\t                }\n\t            } else if (propName === 'classes') {\n\t                var classList = domNode.classList;\n\t                var classNames = Object.keys(propValue);\n\t                var classNameCount = classNames.length;\n\t                for (var j = 0; j < classNameCount; j++) {\n\t                    var className = classNames[j];\n\t                    var on = !!propValue[className];\n\t                    var previousOn = !!previousValue[className];\n\t                    if (on === previousOn) {\n\t                        continue;\n\t                    }\n\t                    propertiesUpdated = true;\n\t                    if (on) {\n\t                        classList.add(className);\n\t                    } else {\n\t                        classList.remove(className);\n\t                    }\n\t                }\n\t            } else if (propName === 'styles') {\n\t                var styleNames = Object.keys(propValue);\n\t                var styleCount = styleNames.length;\n\t                for (var j = 0; j < styleCount; j++) {\n\t                    var styleName = styleNames[j];\n\t                    var newStyleValue = propValue[styleName];\n\t                    var oldStyleValue = previousValue[styleName];\n\t                    if (newStyleValue === oldStyleValue) {\n\t                        continue;\n\t                    }\n\t                    propertiesUpdated = true;\n\t                    if (newStyleValue) {\n\t                        checkStyleValue(newStyleValue);\n\t                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n\t                    } else {\n\t                        projectionOptions.styleApplyer(domNode, styleName, '');\n\t                    }\n\t                }\n\t            } else {\n\t                if (!propValue && typeof previousValue === 'string') {\n\t                    propValue = '';\n\t                }\n\t                if (propName === 'value') {\n\t                    if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n\t                        domNode[propName] = propValue;\n\t                        // Reset the value, even if the virtual DOM did not change\n\t                        domNode['oninput-value'] = undefined;\n\t                    }\n\t                    // else do not update the domNode, otherwise the cursor position would be changed\n\t                    if (propValue !== previousValue) {\n\t                        propertiesUpdated = true;\n\t                    }\n\t                } else if (propValue !== previousValue) {\n\t                    var type = typeof propValue;\n\t                    if (type === 'function') {\n\t                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');\n\t                    }\n\t                    if (type === 'string' && propName !== 'innerHTML') {\n\t                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n\t                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n\t                        } else {\n\t                            domNode.setAttribute(propName, propValue);\n\t                        }\n\t                    } else {\n\t                        if (domNode[propName] !== propValue) {\n\t                            domNode[propName] = propValue;\n\t                        }\n\t                    }\n\t                    propertiesUpdated = true;\n\t                }\n\t            }\n\t        }\n\t        return propertiesUpdated;\n\t    };\n\t    var findIndexOfChild = function (children, sameAs, start) {\n\t        if (sameAs.vnodeSelector !== '') {\n\t            // Never scan for text-nodes\n\t            for (var i = start; i < children.length; i++) {\n\t                if (same(children[i], sameAs)) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    var nodeAdded = function (vNode, transitions) {\n\t        if (vNode.properties) {\n\t            var enterAnimation = vNode.properties.enterAnimation;\n\t            if (enterAnimation) {\n\t                if (typeof enterAnimation === 'function') {\n\t                    enterAnimation(vNode.domNode, vNode.properties);\n\t                } else {\n\t                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var nodeToRemove = function (vNode, transitions) {\n\t        var domNode = vNode.domNode;\n\t        if (vNode.properties) {\n\t            var exitAnimation = vNode.properties.exitAnimation;\n\t            if (exitAnimation) {\n\t                domNode.style.pointerEvents = 'none';\n\t                var removeDomNode = function () {\n\t                    if (domNode.parentNode) {\n\t                        domNode.parentNode.removeChild(domNode);\n\t                    }\n\t                };\n\t                if (typeof exitAnimation === 'function') {\n\t                    exitAnimation(domNode, removeDomNode, vNode.properties);\n\t                    return;\n\t                } else {\n\t                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n\t                    return;\n\t                }\n\t            }\n\t        }\n\t        if (domNode.parentNode) {\n\t            domNode.parentNode.removeChild(domNode);\n\t        }\n\t    };\n\t    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n\t        var childNode = childNodes[indexToCheck];\n\t        if (childNode.vnodeSelector === '') {\n\t            return;    // Text nodes need not be distinguishable\n\t        }\n\t        var properties = childNode.properties;\n\t        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;\n\t        if (!key) {\n\t            for (var i = 0; i < childNodes.length; i++) {\n\t                if (i !== indexToCheck) {\n\t                    var node = childNodes[i];\n\t                    if (same(node, childNode)) {\n\t                        if (operation === 'added') {\n\t                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n\t                        } else {\n\t                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var createDom;\n\t    var updateDom;\n\t    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n\t        if (oldChildren === newChildren) {\n\t            return false;\n\t        }\n\t        oldChildren = oldChildren || emptyArray;\n\t        newChildren = newChildren || emptyArray;\n\t        var oldChildrenLength = oldChildren.length;\n\t        var newChildrenLength = newChildren.length;\n\t        var transitions = projectionOptions.transitions;\n\t        var oldIndex = 0;\n\t        var newIndex = 0;\n\t        var i;\n\t        var textUpdated = false;\n\t        while (newIndex < newChildrenLength) {\n\t            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n\t            var newChild = newChildren[newIndex];\n\t            if (oldChild !== undefined && same(oldChild, newChild)) {\n\t                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n\t                oldIndex++;\n\t            } else {\n\t                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n\t                if (findOldIndex >= 0) {\n\t                    // Remove preceding missing children\n\t                    for (i = oldIndex; i < findOldIndex; i++) {\n\t                        nodeToRemove(oldChildren[i], transitions);\n\t                        checkDistinguishable(oldChildren, i, vnode, 'removed');\n\t                    }\n\t                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n\t                    oldIndex = findOldIndex + 1;\n\t                } else {\n\t                    // New child\n\t                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n\t                    nodeAdded(newChild, transitions);\n\t                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\n\t                }\n\t            }\n\t            newIndex++;\n\t        }\n\t        if (oldChildrenLength > oldIndex) {\n\t            // Remove child fragments\n\t            for (i = oldIndex; i < oldChildrenLength; i++) {\n\t                nodeToRemove(oldChildren[i], transitions);\n\t                checkDistinguishable(oldChildren, i, vnode, 'removed');\n\t            }\n\t        }\n\t        return textUpdated;\n\t    };\n\t    var addChildren = function (domNode, children, projectionOptions) {\n\t        if (!children) {\n\t            return;\n\t        }\n\t        for (var i = 0; i < children.length; i++) {\n\t            createDom(children[i], domNode, undefined, projectionOptions);\n\t        }\n\t    };\n\t    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n\t        addChildren(domNode, vnode.children, projectionOptions);\n\t        // children before properties, needed for value property of <select>.\n\t        if (vnode.text) {\n\t            domNode.textContent = vnode.text;\n\t        }\n\t        setProperties(domNode, vnode.properties, projectionOptions);\n\t        if (vnode.properties && vnode.properties.afterCreate) {\n\t            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [\n\t                domNode,\n\t                projectionOptions,\n\t                vnode.vnodeSelector,\n\t                vnode.properties,\n\t                vnode.children\n\t            ]);\n\t        }\n\t    };\n\t    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n\t        var domNode, i, c, start = 0, type, found;\n\t        var vnodeSelector = vnode.vnodeSelector;\n\t        if (vnodeSelector === '') {\n\t            domNode = vnode.domNode = document.createTextNode(vnode.text);\n\t            if (insertBefore !== undefined) {\n\t                parentNode.insertBefore(domNode, insertBefore);\n\t            } else {\n\t                parentNode.appendChild(domNode);\n\t            }\n\t        } else {\n\t            for (i = 0; i <= vnodeSelector.length; ++i) {\n\t                c = vnodeSelector.charAt(i);\n\t                if (i === vnodeSelector.length || c === '.' || c === '#') {\n\t                    type = vnodeSelector.charAt(start - 1);\n\t                    found = vnodeSelector.slice(start, i);\n\t                    if (type === '.') {\n\t                        domNode.classList.add(found);\n\t                    } else if (type === '#') {\n\t                        domNode.id = found;\n\t                    } else {\n\t                        if (found === 'svg') {\n\t                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n\t                        }\n\t                        if (projectionOptions.namespace !== undefined) {\n\t                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n\t                        } else {\n\t                            domNode = vnode.domNode = document.createElement(found);\n\t                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {\n\t                                // IE8 and older don't support setting input type after the DOM Node has been added to the document\n\t                                domNode.setAttribute('type', vnode.properties.type);\n\t                            }\n\t                        }\n\t                        if (insertBefore !== undefined) {\n\t                            parentNode.insertBefore(domNode, insertBefore);\n\t                        } else {\n\t                            parentNode.appendChild(domNode);\n\t                        }\n\t                    }\n\t                    start = i + 1;\n\t                }\n\t            }\n\t            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n\t        }\n\t    };\n\t    updateDom = function (previous, vnode, projectionOptions) {\n\t        var domNode = previous.domNode;\n\t        var textUpdated = false;\n\t        if (previous === vnode) {\n\t            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette\n\t        }\n\t        var updated = false;\n\t        if (vnode.vnodeSelector === '') {\n\t            if (vnode.text !== previous.text) {\n\t                var newVNode = document.createTextNode(vnode.text);\n\t                domNode.parentNode.replaceChild(newVNode, domNode);\n\t                vnode.domNode = newVNode;\n\t                textUpdated = true;\n\t                return textUpdated;\n\t            }\n\t        } else {\n\t            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n\t                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n\t            }\n\t            if (previous.text !== vnode.text) {\n\t                updated = true;\n\t                if (vnode.text === undefined) {\n\t                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably\n\t                } else {\n\t                    domNode.textContent = vnode.text;\n\t                }\n\t            }\n\t            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n\t            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n\t            if (vnode.properties && vnode.properties.afterUpdate) {\n\t                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [\n\t                    domNode,\n\t                    projectionOptions,\n\t                    vnode.vnodeSelector,\n\t                    vnode.properties,\n\t                    vnode.children\n\t                ]);\n\t            }\n\t        }\n\t        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n\t            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n\t        }\n\t        vnode.domNode = previous.domNode;\n\t        return textUpdated;\n\t    };\n\t    var createProjection = function (vnode, projectionOptions) {\n\t        return {\n\t            update: function (updatedVnode) {\n\t                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n\t                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n\t                }\n\t                updateDom(vnode, updatedVnode, projectionOptions);\n\t                vnode = updatedVnode;\n\t            },\n\t            domNode: vnode.domNode\n\t        };\n\t    };\n\t    ;\n\t    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.\n\t    exports.h = function (selector) {\n\t        var properties = arguments[1];\n\t        if (typeof selector !== 'string') {\n\t            throw new Error();\n\t        }\n\t        var childIndex = 1;\n\t        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n\t            childIndex = 2;\n\t        } else {\n\t            // Optional properties argument was omitted\n\t            properties = undefined;\n\t        }\n\t        var text = undefined;\n\t        var children = undefined;\n\t        var argsLength = arguments.length;\n\t        // Recognize a common special case where there is only a single text node\n\t        if (argsLength === childIndex + 1) {\n\t            var onlyChild = arguments[childIndex];\n\t            if (typeof onlyChild === 'string') {\n\t                text = onlyChild;\n\t            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n\t                text = onlyChild[0];\n\t            }\n\t        }\n\t        if (text === undefined) {\n\t            children = [];\n\t            for (; childIndex < argsLength; childIndex++) {\n\t                var child = arguments[childIndex];\n\t                if (child === null || child === undefined) {\n\t                    continue;\n\t                } else if (Array.isArray(child)) {\n\t                    appendChildren(selector, child, children);\n\t                } else if (child.hasOwnProperty('vnodeSelector')) {\n\t                    children.push(child);\n\t                } else {\n\t                    children.push(toTextVNode(child));\n\t                }\n\t            }\n\t        }\n\t        return {\n\t            vnodeSelector: selector,\n\t            properties: properties,\n\t            children: children,\n\t            text: text === '' ? undefined : text,\n\t            domNode: null\n\t        };\n\t    };\n\t    /**\n\t * Contains simple low-level utility functions to manipulate the real DOM.\n\t */\n\t    exports.dom = {\n\t        /**\n\t     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n\t     * its [[Projection.domNode|domNode]] property.\n\t     * This is a low-level method. Users will typically use a [[Projector]] instead.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n\t     * objects may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the projection.\n\t     * @returns The [[Projection]] which also contains the DOM Node that was created.\n\t     */\n\t        create: function (vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        },\n\t        /**\n\t     * Appends a new childnode to the DOM which is generated from a [[VNode]].\n\t     * This is a low-level method. Users will typically use a [[Projector]] instead.\n\t     * @param parentNode - The parent node for the new childNode.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n\t     * objects may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n\t     * @returns The [[Projection]] that was created.\n\t     */\n\t        append: function (parentNode, vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            createDom(vnode, parentNode, undefined, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        },\n\t        /**\n\t     * Inserts a new DOM node which is generated from a [[VNode]].\n\t     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n\t     * @param beforeNode - The node that the DOM Node is inserted before.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n\t     * NOTE: [[VNode]] objects may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n\t     * @returns The [[Projection]] that was created.\n\t     */\n\t        insertBefore: function (beforeNode, vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        },\n\t        /**\n\t     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n\t     * This means that the virtual DOM and the real DOM will have one overlapping element.\n\t     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n\t     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n\t     * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n\t     * may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n\t     * @returns The [[Projection]] that was created.\n\t     */\n\t        merge: function (element, vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            vnode.domNode = element;\n\t            initPropertiesAndChildren(element, vnode, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        }\n\t    };\n\t    /**\n\t * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n\t * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n\t * For more information, see [[CalculationCache]].\n\t *\n\t * @param <Result> The type of the value that is cached.\n\t */\n\t    exports.createCache = function () {\n\t        var cachedInputs = undefined;\n\t        var cachedOutcome = undefined;\n\t        var result = {\n\t            invalidate: function () {\n\t                cachedOutcome = undefined;\n\t                cachedInputs = undefined;\n\t            },\n\t            result: function (inputs, calculation) {\n\t                if (cachedInputs) {\n\t                    for (var i = 0; i < inputs.length; i++) {\n\t                        if (cachedInputs[i] !== inputs[i]) {\n\t                            cachedOutcome = undefined;\n\t                        }\n\t                    }\n\t                }\n\t                if (!cachedOutcome) {\n\t                    cachedOutcome = calculation();\n\t                    cachedInputs = inputs;\n\t                }\n\t                return cachedOutcome;\n\t            }\n\t        };\n\t        return result;\n\t    };\n\t    /**\n\t * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n\t * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n\t *\n\t * @param <Source>       The type of source items. A database-record for instance.\n\t * @param <Target>       The type of target items. A [[Component]] for instance.\n\t * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n\t * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n\t *                       to the `callback` argument in `Array.map(callback)`.\n\t * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n\t */\n\t    exports.createMapping = function (getSourceKey, createResult, updateResult) {\n\t        var keys = [];\n\t        var results = [];\n\t        return {\n\t            results: results,\n\t            map: function (newSources) {\n\t                var newKeys = newSources.map(getSourceKey);\n\t                var oldTargets = results.slice();\n\t                var oldIndex = 0;\n\t                for (var i = 0; i < newSources.length; i++) {\n\t                    var source = newSources[i];\n\t                    var sourceKey = newKeys[i];\n\t                    if (sourceKey === keys[oldIndex]) {\n\t                        results[i] = oldTargets[oldIndex];\n\t                        updateResult(source, oldTargets[oldIndex], i);\n\t                        oldIndex++;\n\t                    } else {\n\t                        var found = false;\n\t                        for (var j = 1; j < keys.length + 1; j++) {\n\t                            var searchIndex = (oldIndex + j) % keys.length;\n\t                            if (keys[searchIndex] === sourceKey) {\n\t                                results[i] = oldTargets[searchIndex];\n\t                                updateResult(newSources[i], oldTargets[searchIndex], i);\n\t                                oldIndex = searchIndex + 1;\n\t                                found = true;\n\t                                break;\n\t                            }\n\t                        }\n\t                        if (!found) {\n\t                            results[i] = createResult(source, i);\n\t                        }\n\t                    }\n\t                }\n\t                results.length = newSources.length;\n\t                keys = newKeys;\n\t            }\n\t        };\n\t    };\n\t    /**\n\t * Creates a [[Projector]] instance using the provided projectionOptions.\n\t *\n\t * For more information, see [[Projector]].\n\t *\n\t * @param projectionOptions   Options that influence how the DOM is rendered and updated.\n\t */\n\t    exports.createProjector = function (projectorOptions) {\n\t        var projector;\n\t        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n\t        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n\t            return function () {\n\t                // intercept function calls (event handlers) to do a render afterwards.\n\t                projector.scheduleRender();\n\t                return eventHandler.apply(properties.bind || this, arguments);\n\t            };\n\t        };\n\t        var renderCompleted = true;\n\t        var scheduled;\n\t        var stopped = false;\n\t        var projections = [];\n\t        var renderFunctions = [];\n\t        // matches the projections array\n\t        var doRender = function () {\n\t            scheduled = undefined;\n\t            if (!renderCompleted) {\n\t                return;    // The last render threw an error, it should be logged in the browser console.\n\t            }\n\t            renderCompleted = false;\n\t            for (var i = 0; i < projections.length; i++) {\n\t                var updatedVnode = renderFunctions[i]();\n\t                projections[i].update(updatedVnode);\n\t            }\n\t            renderCompleted = true;\n\t        };\n\t        projector = {\n\t            renderNow: doRender,\n\t            scheduleRender: function () {\n\t                if (!scheduled && !stopped) {\n\t                    scheduled = requestAnimationFrame(doRender);\n\t                }\n\t            },\n\t            stop: function () {\n\t                if (scheduled) {\n\t                    cancelAnimationFrame(scheduled);\n\t                    scheduled = undefined;\n\t                }\n\t                stopped = true;\n\t            },\n\t            resume: function () {\n\t                stopped = false;\n\t                renderCompleted = true;\n\t                projector.scheduleRender();\n\t            },\n\t            append: function (parentNode, renderMaquetteFunction) {\n\t                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            insertBefore: function (beforeNode, renderMaquetteFunction) {\n\t                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            merge: function (domNode, renderMaquetteFunction) {\n\t                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            replace: function (domNode, renderMaquetteFunction) {\n\t                var vnode = renderMaquetteFunction();\n\t                createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n\t                domNode.parentNode.removeChild(domNode);\n\t                projections.push(createProjection(vnode, projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            detach: function (renderMaquetteFunction) {\n\t                for (var i = 0; i < renderFunctions.length; i++) {\n\t                    if (renderFunctions[i] === renderMaquetteFunction) {\n\t                        renderFunctions.splice(i, 1);\n\t                        return projections.splice(i, 1)[0];\n\t                    }\n\t                }\n\t                throw new Error('renderMaquetteFunction was not found');\n\t            }\n\t        };\n\t        return projector;\n\t    };\n\t}));\n\t//# sourceMappingURL=maquette.js.map\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(13);\n\tvar Symbol_1 = __webpack_require__(18);\n\tvar maquette_1 = __webpack_require__(27);\n\tvar FactoryRegistry_1 = __webpack_require__(29);\n\t/**\n\t * The symbol intifier for a WNode type\n\t */\n\texports.WNODE = Symbol_1.default('Identifier for a WNode.');\n\t/**\n\t * The symbol intifier for a HNode type\n\t */\n\texports.HNODE = Symbol_1.default('Identifier for a HNode.');\n\t/**\n\t * Helper function that returns true if the `DNode` is a `WNode` using the `type` property\n\t */\n\tfunction isWNode(child) {\n\t    return Boolean(child && (typeof child !== 'string') && child.type === exports.WNODE);\n\t}\n\texports.isWNode = isWNode;\n\t/**\n\t * Helper function that returns true if the `DNode` is a `Node` using the `type` property\n\t */\n\tfunction isHNode(child) {\n\t    return Boolean(child && (typeof child !== 'string') && child.type === exports.HNODE);\n\t}\n\texports.isHNode = isHNode;\n\texports.registry = new FactoryRegistry_1.default();\n\tfunction w(factory, properties, children) {\n\t    if (children === void 0) { children = []; }\n\t    return {\n\t        children: children,\n\t        factory: factory,\n\t        properties: properties,\n\t        type: exports.WNODE\n\t    };\n\t}\n\texports.w = w;\n\tfunction v(tag, propertiesOrChildren, children) {\n\t    if (propertiesOrChildren === void 0) { propertiesOrChildren = {}; }\n\t    if (children === void 0) { children = []; }\n\t    if (Array.isArray(propertiesOrChildren)) {\n\t        children = propertiesOrChildren;\n\t        propertiesOrChildren = {};\n\t    }\n\t    return {\n\t        children: children,\n\t        render: function (options) {\n\t            if (options === void 0) { options = {}; }\n\t            return maquette_1.h(tag, lang_1.assign(options, propertiesOrChildren), this.children);\n\t        },\n\t        type: exports.HNODE\n\t    };\n\t}\n\texports.v = v;\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(6);\n\tvar Promise_1 = __webpack_require__(23);\n\tvar Map_1 = __webpack_require__(30);\n\tvar FactoryRegistry = (function () {\n\t    function FactoryRegistry() {\n\t        this.registry = new Map_1.default();\n\t    }\n\t    FactoryRegistry.prototype.has = function (factoryLabel) {\n\t        return this.registry.has(factoryLabel);\n\t    };\n\t    FactoryRegistry.prototype.define = function (factoryLabel, registryItem) {\n\t        if (this.registry.has(factoryLabel)) {\n\t            throw new Error(\"factory has already been registered for '\" + factoryLabel + \"'\");\n\t        }\n\t        this.registry.set(factoryLabel, registryItem);\n\t    };\n\t    FactoryRegistry.prototype.get = function (factoryLabel) {\n\t        var _this = this;\n\t        if (!this.has(factoryLabel)) {\n\t            return null;\n\t        }\n\t        var item = this.registry.get(factoryLabel);\n\t        if (compose_1.isComposeFactory(item) || item instanceof Promise_1.default) {\n\t            return item;\n\t        }\n\t        var promise = item();\n\t        this.registry.set(factoryLabel, promise);\n\t        return promise.then(function (factory) {\n\t            _this.registry.set(factoryLabel, factory);\n\t            return factory;\n\t        }, function (error) {\n\t            throw error;\n\t        });\n\t    };\n\t    return FactoryRegistry;\n\t}());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = FactoryRegistry;\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar decorators_1 = __webpack_require__(21);\n\tvar global_1 = __webpack_require__(10);\n\tvar iterator_1 = __webpack_require__(16);\n\tvar object_1 = __webpack_require__(31);\n\t__webpack_require__(18);\n\tvar Shim;\n\t(function (Shim) {\n\t    /**\n\t     * An implementation analogous to the Map specification in ES2015.\n\t     */\n\t    var Map = (function () {\n\t        /**\n\t         * Creates a new Map\n\t         *\n\t         * @constructor\n\t         *\n\t         * @param iterator\n\t         * Array or iterator containing two-item tuples used to initially populate the map.\n\t         * The first item in each tuple corresponds to the key of the map entry.\n\t         * The second item corresponds to the value of the map entry.\n\t         */\n\t        function Map(iterable) {\n\t            var _this = this;\n\t            this._keys = [];\n\t            this._values = [];\n\t            this[Symbol.toStringTag] = 'Map';\n\t            if (iterable) {\n\t                iterator_1.forOf(iterable, function (value) {\n\t                    _this.set(value[0], value[1]);\n\t                });\n\t            }\n\t        }\n\t        /**\n\t         * An alternative to Array.prototype.indexOf using Object.is\n\t         * to check for equality. See http://mzl.la/1zuKO2V\n\t         */\n\t        Map.prototype._indexOfKey = function (keys, key) {\n\t            for (var i = 0, length_1 = keys.length; i < length_1; i++) {\n\t                if (object_1.is(keys[i], key)) {\n\t                    return i;\n\t                }\n\t            }\n\t            return -1;\n\t        };\n\t        Object.defineProperty(Map.prototype, \"size\", {\n\t            /**\n\t             * Returns the number of key / value pairs in the Map.\n\t             *\n\t             * @return the number of key / value pairs in the Map\n\t             */\n\t            get: function () {\n\t                return this._keys.length;\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * Deletes all keys and their associated values.\n\t         */\n\t        Map.prototype.clear = function () {\n\t            this._keys.length = this._values.length = 0;\n\t        };\n\t        /**\n\t         * Deletes a given key and its associated value.\n\t         *\n\t         * @param key The key to delete\n\t         * @return true if the key exists, false if it does not\n\t         */\n\t        Map.prototype.delete = function (key) {\n\t            var index = this._indexOfKey(this._keys, key);\n\t            if (index < 0) {\n\t                return false;\n\t            }\n\t            this._keys.splice(index, 1);\n\t            this._values.splice(index, 1);\n\t            return true;\n\t        };\n\t        /**\n\t         * Returns an iterator that yields each key/value pair as an array.\n\t         *\n\t         * @return An iterator for each key/value pair in the instance.\n\t         */\n\t        Map.prototype.entries = function () {\n\t            var _this = this;\n\t            var values = this._keys.map(function (key, i) {\n\t                return [key, _this._values[i]];\n\t            });\n\t            return new iterator_1.ShimIterator(values);\n\t        };\n\t        /**\n\t         * Executes a given function for each map entry. The function\n\t         * is invoked with three arguments: the element value, the\n\t         * element key, and the associated Map instance.\n\t         *\n\t         * @param callback The function to execute for each map entry,\n\t         * @param context The value to use for `this` for each execution of the calback\n\t         */\n\t        Map.prototype.forEach = function (callback, context) {\n\t            var keys = this._keys;\n\t            var values = this._values;\n\t            for (var i = 0, length_2 = keys.length; i < length_2; i++) {\n\t                callback.call(context, values[i], keys[i], this);\n\t            }\n\t        };\n\t        /**\n\t         * Returns the value associated with a given key.\n\t         *\n\t         * @param key The key to look up\n\t         * @return The value if one exists or undefined\n\t         */\n\t        Map.prototype.get = function (key) {\n\t            var index = this._indexOfKey(this._keys, key);\n\t            return index < 0 ? undefined : this._values[index];\n\t        };\n\t        /**\n\t         * Checks for the presence of a given key.\n\t         *\n\t         * @param key The key to check for\n\t         * @return true if the key exists, false if it does not\n\t         */\n\t        Map.prototype.has = function (key) {\n\t            return this._indexOfKey(this._keys, key) > -1;\n\t        };\n\t        /**\n\t         * Returns an iterator that yields each key in the map.\n\t         *\n\t         * @return An iterator containing the instance's keys.\n\t         */\n\t        Map.prototype.keys = function () {\n\t            return new iterator_1.ShimIterator(this._keys);\n\t        };\n\t        /**\n\t         * Sets the value associated with a given key.\n\t         *\n\t         * @param key The key to define a value to\n\t         * @param value The value to assign\n\t         * @return The Map instance\n\t         */\n\t        Map.prototype.set = function (key, value) {\n\t            var index = this._indexOfKey(this._keys, key);\n\t            index = index < 0 ? this._keys.length : index;\n\t            this._keys[index] = key;\n\t            this._values[index] = value;\n\t            return this;\n\t        };\n\t        /**\n\t         * Returns an iterator that yields each value in the map.\n\t         *\n\t         * @return An iterator containing the instance's values.\n\t         */\n\t        Map.prototype.values = function () {\n\t            return new iterator_1.ShimIterator(this._values);\n\t        };\n\t        Map.prototype[Symbol.iterator] = function () {\n\t            return this.entries();\n\t        };\n\t        return Map;\n\t    }());\n\t    Shim.Map = Map;\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\tvar Map = (function () {\n\t    /* istanbul ignore next */\n\t    function Map(iterable) {\n\t        /* istanbul ignore next */\n\t        this[Symbol.toStringTag] = 'Map';\n\t    }\n\t    ;\n\t    Object.defineProperty(Map.prototype, \"size\", {\n\t        /* istanbul ignore next */\n\t        get: function () { throw new Error('Abstract method'); },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.clear = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.delete = function (key) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.entries = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.forEach = function (callback, context) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.get = function (key) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.has = function (key) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.keys = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.set = function (key, value) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.values = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype[Symbol.iterator] = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    return Map;\n\t}());\n\tMap = __decorate([\n\t    decorators_1.hasClass('es6-map', global_1.default.Map, Shim.Map)\n\t], Map);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Map;\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(9);\n\tvar Symbol_1 = __webpack_require__(18);\n\tvar Shim;\n\t(function (Shim) {\n\t    function is(value1, value2) {\n\t        if (value1 === value2) {\n\t            return value1 !== 0 || 1 / value1 === 1 / value2; // -0\n\t        }\n\t        return value1 !== value1 && value2 !== value2; // NaN\n\t    }\n\t    Shim.is = is;\n\t    function getOwnPropertySymbols(o) {\n\t        return Object.getOwnPropertyNames(o).filter(function (key) { return Boolean(key.match(/^@@.+/)); })\n\t            .map(function (key) { return Symbol.for(key.substring(2)); });\n\t    }\n\t    Shim.getOwnPropertySymbols = getOwnPropertySymbols;\n\t    function getOwnPropertyNames(o) {\n\t        return Object.getOwnPropertyNames(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });\n\t    }\n\t    Shim.getOwnPropertyNames = getOwnPropertyNames;\n\t    function symbolAwareKeys(o) {\n\t        return Object.keys(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });\n\t    }\n\t    Shim.symbolAwareKeys = symbolAwareKeys;\n\t    function getOwnPropertyDescriptor(o, prop) {\n\t        if (Symbol_1.isSymbol(prop)) {\n\t            return Object.getOwnPropertyDescriptor(o, prop);\n\t        }\n\t        else {\n\t            return Object.getOwnPropertyDescriptor(o, prop);\n\t        }\n\t    }\n\t    Shim.getOwnPropertyDescriptor = getOwnPropertyDescriptor;\n\t    function values(o) {\n\t        return exports.keys(o).map(function (key) { return o[key]; });\n\t    }\n\t    Shim.values = values;\n\t    function entries(o) {\n\t        return exports.keys(o).map(function (key) { return [key, o[key]]; });\n\t    }\n\t    Shim.entries = entries;\n\t})(Shim || (Shim = {}));\n\t/**\n\t * Determines whether two values are the same value.\n\t *\n\t * @param value1 The first value to compare\n\t * @param value2 The second value to compare\n\t * @return true if the values are the same; false otherwise\n\t */\n\texports.is = 'is' in Object\n\t    ? Object.is\n\t    : Shim.is;\n\t/**\n\t * Detect if there is native support for Symbol properties in Object\n\t */\n\tvar hasGetOwnPropertySymbols = has_1.default('es6-symbol') && 'getOwnPropertySymbols' in Object;\n\t/**\n\t * Returns an array of own properties who key is a symbol\n\t *\n\t * @param o The object to return the properties for\n\t */\n\texports.getOwnPropertySymbols = hasGetOwnPropertySymbols\n\t    ? Object.getOwnPropertySymbols\n\t    : Shim.getOwnPropertySymbols;\n\t/**\n\t * Returns an array of own properties who key is a string\n\t *\n\t * @param o The object to return the properties for\n\t */\n\t/* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n\t * when there is no support for symbols */\n\texports.getOwnPropertyNames = hasGetOwnPropertySymbols\n\t    ? Object.getOwnPropertyNames\n\t    : Shim.getOwnPropertyNames;\n\t/**\n\t * Returns the names of the enumerable properties and methods of an object.\n\t * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n\t */\n\t/* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n\t * when there is no support for symbols */\n\texports.keys = hasGetOwnPropertySymbols\n\t    ? Object.keys\n\t    : Shim.symbolAwareKeys;\n\t/**\n\t * Returns the values of the enumerable properties and methods of an object.\n\t * @param o Object that contains the properties and methods.\n\t */\n\texports.values = 'values' in Object\n\t    ? Object.values\n\t    : Shim.values;\n\t/**\n\t * Returns the keys and values of the enumerable properties and methods of an object. Each entry will be returned as an\n\t * array holding the [key, value].\n\t * @param o Object that contains the properties and methods.\n\t */\n\texports.entries = 'entries' in Object\n\t    ? Object.entries\n\t    : Shim.entries;\n\texports.getOwnPropertyDescriptor = hasGetOwnPropertySymbols\n\t    ? Object.getOwnPropertyDescriptor\n\t    : Shim.getOwnPropertyDescriptor;\n\tfunction getOwnPropertyDescriptorsWrapper(o) {\n\t    var descriptors = exports.getOwnPropertyNames(o).reduce(function (descriptors, key) {\n\t        descriptors[key] = exports.getOwnPropertyDescriptor(o, key);\n\t        return descriptors;\n\t    }, {});\n\t    exports.getOwnPropertySymbols(o).forEach(function (sym) {\n\t        descriptors[sym] = exports.getOwnPropertyDescriptor(o, sym);\n\t    });\n\t    return descriptors;\n\t}\n\t/* Return descriptors for enumerable and non enumerable properties on an object */\n\texports.getOwnPropertyDescriptors = 'getOwnPropertyDescriptors' in Object\n\t    ? Object.getOwnPropertyDescriptors\n\t    : getOwnPropertyDescriptorsWrapper;\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createRoute_1 = __webpack_require__(33);\n\tvar createRouter_1 = __webpack_require__(35);\n\tvar createHashHistory_1 = __webpack_require__(43);\n\tvar userActions_1 = __webpack_require__(44);\n\tvar filterRoute = createRoute_1.default({\n\t    path: '/{filter}',\n\t    params: function (_a) {\n\t        var filter = _a[0];\n\t        switch (filter) {\n\t            case 'active':\n\t                return { filter: 'active' };\n\t            case 'all':\n\t                return { filter: 'all' };\n\t            case 'completed':\n\t                return { filter: 'completed' };\n\t            default:\n\t                return null;\n\t        }\n\t    },\n\t    exec: function (request) {\n\t        var filter = request.params.filter;\n\t        return userActions_1.filter({ filter: filter });\n\t    }\n\t});\n\tvar router = createRouter_1.default({ history: createHashHistory_1.default() });\n\trouter.append(filterRoute);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = router;\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(6);\n\tvar UrlSearchParams_1 = __webpack_require__(34);\n\tvar WeakMap_1 = __webpack_require__(20);\n\tvar createRouter_1 = __webpack_require__(35);\n\tvar path_1 = __webpack_require__(42);\n\tvar privateStateMap = new WeakMap_1.default();\n\t// Store parent relationships in a separate map, since it's the parent that adds entries to this map. Parents shouldn't\n\t// change the private state of their children.\n\tvar parentMap = new WeakMap_1.default();\n\tvar noop = function () { };\n\tfunction computeDefaultParams(parameters, searchParameters, fromPathname, searchParams) {\n\t    var params = {};\n\t    parameters.forEach(function (name, index) {\n\t        params[name] = fromPathname[index];\n\t    });\n\t    searchParameters.forEach(function (name) {\n\t        var value = searchParams.get(name);\n\t        if (value !== undefined) {\n\t            params[name] = value;\n\t        }\n\t    });\n\t    return params;\n\t}\n\tvar createRoute = compose_1.default({\n\t    get parent() {\n\t        return parentMap.get(this);\n\t    },\n\t    get path() {\n\t        return privateStateMap.get(this).path;\n\t    },\n\t    append: function (add) {\n\t        var _this = this;\n\t        var routes = privateStateMap.get(this).routes;\n\t        var append = function (route) {\n\t            if (createRouter_1.hasBeenAppended(route)) {\n\t                throw new Error('Cannot append route that has already been appended');\n\t            }\n\t            routes.push(route);\n\t            parentMap.set(route, _this);\n\t        };\n\t        if (Array.isArray(add)) {\n\t            for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {\n\t                var route = add_1[_i];\n\t                append(route);\n\t            }\n\t        }\n\t        else {\n\t            append(add);\n\t        }\n\t    },\n\t    link: function (params) {\n\t        return createRouter_1.findRouter(this).link(this, params);\n\t    },\n\t    match: function (segments, hasTrailingSlash, searchParams) {\n\t        var _a = privateStateMap.get(this), computeParams = _a.computeParams, path = _a.path, trailingSlashMustMatch = _a.trailingSlashMustMatch;\n\t        var result = path_1.match(path, segments);\n\t        if (result === null) {\n\t            return null;\n\t        }\n\t        if (!result.hasRemaining && trailingSlashMustMatch && path.trailingSlash !== hasTrailingSlash) {\n\t            return null;\n\t        }\n\t        // Only extract the search params defined in the route's path.\n\t        var knownSearchParams = path.searchParameters.reduce(function (list, name) {\n\t            var value = searchParams.getAll(name);\n\t            if (value !== undefined) {\n\t                list[name] = value;\n\t            }\n\t            return list;\n\t        }, {});\n\t        var params = computeParams(result.values, new UrlSearchParams_1.default(knownSearchParams));\n\t        if (params === null) {\n\t            return null;\n\t        }\n\t        return {\n\t            hasRemaining: result.hasRemaining,\n\t            offset: result.offset,\n\t            params: params,\n\t            rawPathValues: result.values,\n\t            rawSearchParams: knownSearchParams\n\t        };\n\t    },\n\t    select: function (context, segments, hasTrailingSlash, searchParams) {\n\t        var _a = privateStateMap.get(this), exec = _a.exec, index = _a.index, fallback = _a.fallback, guard = _a.guard, path = _a.path, routes = _a.routes;\n\t        var matchResult = this.match(segments, hasTrailingSlash, searchParams);\n\t        // Return early if possible.\n\t        if (!matchResult || matchResult.hasRemaining && routes.length === 0 && !fallback) {\n\t            return [];\n\t        }\n\t        var params = matchResult.params;\n\t        if (guard) {\n\t            var guardResult = guard({ context: context, params: params });\n\t            if (typeof guardResult === 'string') {\n\t                return guardResult;\n\t            }\n\t            if (!guardResult) {\n\t                return [];\n\t            }\n\t        }\n\t        var handler = exec;\n\t        var redirect;\n\t        var remainingSelection;\n\t        var selected = false;\n\t        if (matchResult.hasRemaining) {\n\t            // Match the remaining segments. Return a hierarchy if nested routes were selected.\n\t            var remainingSegments_1 = segments.slice(matchResult.offset);\n\t            selected = routes.some(function (nested) {\n\t                var nestedResult = nested.select(context, remainingSegments_1, hasTrailingSlash, searchParams);\n\t                if (typeof nestedResult === 'string') {\n\t                    redirect = nestedResult;\n\t                    return true;\n\t                }\n\t                if (nestedResult.length > 0) {\n\t                    remainingSelection = nestedResult;\n\t                    return true;\n\t                }\n\t                return false;\n\t            });\n\t            // No remaining segments matched, only select this route if a fallback handler was specified.\n\t            if (!selected && fallback) {\n\t                selected = true;\n\t                handler = fallback;\n\t            }\n\t        }\n\t        else {\n\t            selected = true;\n\t            if (index) {\n\t                handler = index;\n\t            }\n\t        }\n\t        if (!selected) {\n\t            return [];\n\t        }\n\t        if (redirect !== undefined) {\n\t            return redirect;\n\t        }\n\t        var rawPathValues = matchResult.rawPathValues, rawSearchParams = matchResult.rawSearchParams;\n\t        var selection = {\n\t            // Use a noop handler if exec was not provided. Something needs to be returned otherwise the router may\n\t            // think no routes were selected.\n\t            handler: handler || noop,\n\t            path: path,\n\t            params: params,\n\t            rawPathValues: rawPathValues,\n\t            rawSearchParams: rawSearchParams,\n\t            route: this\n\t        };\n\t        return remainingSelection ? [selection].concat(remainingSelection) : [selection];\n\t    }\n\t}, function (instance, _a) {\n\t    var _b = _a === void 0 ? {} : _a, exec = _b.exec, fallback = _b.fallback, guard = _b.guard, index = _b.index, computeParams = _b.params, path = _b.path, _c = _b.trailingSlashMustMatch, trailingSlashMustMatch = _c === void 0 ? true : _c;\n\t    if (path && /#/.test(path)) {\n\t        throw new TypeError('Path must not contain \\'#\\'');\n\t    }\n\t    var deconstructedPath = path_1.deconstruct(path || '/');\n\t    var parameters = deconstructedPath.parameters, searchParameters = deconstructedPath.searchParameters;\n\t    if (computeParams) {\n\t        if (parameters.length === 0 && searchParameters.length === 0) {\n\t            throw new TypeError('Can\\'t specify params() if path doesn\\'t contain any');\n\t        }\n\t    }\n\t    else {\n\t        computeParams = function (fromPathname, searchParams) {\n\t            return computeDefaultParams(parameters, searchParameters, fromPathname, searchParams);\n\t        };\n\t    }\n\t    privateStateMap.set(instance, {\n\t        computeParams: computeParams,\n\t        exec: exec,\n\t        fallback: fallback,\n\t        guard: guard,\n\t        index: index,\n\t        path: deconstructedPath,\n\t        routes: [],\n\t        trailingSlashMustMatch: trailingSlashMustMatch\n\t    });\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createRoute;\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(13);\n\t/**\n\t * Parses a query string, returning a ParamList object.\n\t */\n\tfunction parseQueryString(input) {\n\t    var query = {};\n\t    for (var _i = 0, _a = input.split('&'); _i < _a.length; _i++) {\n\t        var entry = _a[_i];\n\t        var indexOfFirstEquals = entry.indexOf('=');\n\t        var key = void 0;\n\t        var value = '';\n\t        if (indexOfFirstEquals >= 0) {\n\t            key = entry.slice(0, indexOfFirstEquals);\n\t            value = entry.slice(indexOfFirstEquals + 1);\n\t        }\n\t        else {\n\t            key = entry;\n\t        }\n\t        key = key ? decodeURIComponent(key) : '';\n\t        value = value ? decodeURIComponent(value) : '';\n\t        if (key in query) {\n\t            query[key].push(value);\n\t        }\n\t        else {\n\t            query[key] = [value];\n\t        }\n\t    }\n\t    return query;\n\t}\n\t/**\n\t * Represents a set of URL query search parameters.\n\t */\n\tvar UrlSearchParams = (function () {\n\t    /**\n\t     * Constructs a new UrlSearchParams from a query string, an object of parameters and values, or another\n\t     * UrlSearchParams.\n\t     */\n\t    function UrlSearchParams(input) {\n\t        var list;\n\t        if (input instanceof UrlSearchParams) {\n\t            // Copy the incoming UrlSearchParam's internal list\n\t            list = lang_1.duplicate(input._list);\n\t        }\n\t        else if (typeof input === 'object') {\n\t            // Copy the incoming object, assuming its property values are either arrays or strings\n\t            list = {};\n\t            for (var key in input) {\n\t                var value = input[key];\n\t                if (Array.isArray(value)) {\n\t                    list[key] = value.length ? value.slice() : [''];\n\t                }\n\t                else if (value == null) {\n\t                    list[key] = [''];\n\t                }\n\t                else {\n\t                    list[key] = [value];\n\t                }\n\t            }\n\t        }\n\t        else if (typeof input === 'string') {\n\t            // Parse the incoming string as a query string\n\t            list = parseQueryString(input);\n\t        }\n\t        else {\n\t            list = {};\n\t        }\n\t        Object.defineProperty(this, '_list', { value: list });\n\t    }\n\t    /**\n\t     * Appends a new value to the set of values for a key.\n\t     * @param key The key to add a value for\n\t     * @param value The value to add\n\t     */\n\t    UrlSearchParams.prototype.append = function (key, value) {\n\t        if (!this.has(key)) {\n\t            this.set(key, value);\n\t        }\n\t        else {\n\t            var values = this._list[key];\n\t            if (values) {\n\t                values.push(value);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Deletes all values for a key.\n\t     * @param key The key whose values are to be removed\n\t     */\n\t    UrlSearchParams.prototype.delete = function (key) {\n\t        // Set to undefined rather than deleting the key, for better consistency across browsers.\n\t        // If a deleted key is re-added, most browsers put it at the end of iteration order, but IE maintains\n\t        // its original position.  This approach maintains the original position everywhere.\n\t        this._list[key] = undefined;\n\t    };\n\t    /**\n\t     * Returns the first value associated with a key.\n\t     * @param key The key to return the first value for\n\t     * @return The first string value for the key\n\t     */\n\t    UrlSearchParams.prototype.get = function (key) {\n\t        if (!this.has(key)) {\n\t            return undefined;\n\t        }\n\t        var value = this._list[key];\n\t        return value ? value[0] : undefined;\n\t    };\n\t    /**\n\t     * Returns all the values associated with a key.\n\t     * @param key The key to return all values for\n\t     * @return An array of strings containing all values for the key\n\t     */\n\t    UrlSearchParams.prototype.getAll = function (key) {\n\t        if (!this.has(key)) {\n\t            return undefined;\n\t        }\n\t        return this._list[key];\n\t    };\n\t    /**\n\t     * Returns true if a key has been set to any value, false otherwise.\n\t     * @param key The key to test for existence\n\t     * @return A boolean indicating if the key has been set\n\t     */\n\t    UrlSearchParams.prototype.has = function (key) {\n\t        return Array.isArray(this._list[key]);\n\t    };\n\t    /**\n\t     * Returns an array of all keys which have been set.\n\t     * @return An array of strings containing all keys set in the UrlSearchParams instance\n\t     */\n\t    UrlSearchParams.prototype.keys = function () {\n\t        var keys = [];\n\t        for (var key in this._list) {\n\t            if (this.has(key)) {\n\t                keys.push(key);\n\t            }\n\t        }\n\t        return keys;\n\t    };\n\t    /**\n\t     * Sets the value associated with a key.\n\t     * @param key The key to set the value of\n\t     */\n\t    UrlSearchParams.prototype.set = function (key, value) {\n\t        this._list[key] = [value];\n\t    };\n\t    /**\n\t     * Returns this object's data as an encoded query string.\n\t     * @return A string in application/x-www-form-urlencoded format containing all of the set keys/values\n\t     */\n\t    UrlSearchParams.prototype.toString = function () {\n\t        var query = [];\n\t        for (var key in this._list) {\n\t            if (!this.has(key)) {\n\t                continue;\n\t            }\n\t            var values = this._list[key];\n\t            if (values) {\n\t                var encodedKey = encodeURIComponent(key);\n\t                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n\t                    var value = values_1[_i];\n\t                    query.push(encodedKey + (value ? ('=' + encodeURIComponent(value)) : ''));\n\t                }\n\t            }\n\t        }\n\t        return query.join('&');\n\t    };\n\t    return UrlSearchParams;\n\t}());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = UrlSearchParams;\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(6);\n\tvar createEvented_1 = __webpack_require__(36);\n\tvar Task_1 = __webpack_require__(39);\n\tvar on_1 = __webpack_require__(41);\n\tvar UrlSearchParams_1 = __webpack_require__(34);\n\tvar array_1 = __webpack_require__(14);\n\tvar Promise_1 = __webpack_require__(23);\n\tvar WeakMap_1 = __webpack_require__(20);\n\tvar path_1 = __webpack_require__(42);\n\tvar parentMap = new WeakMap_1.default();\n\t/**\n\t * Whether the route has been appended to another route or router.\n\t */\n\tfunction hasBeenAppended(route) {\n\t    return parentMap.has(route) || route.parent !== undefined;\n\t}\n\texports.hasBeenAppended = hasBeenAppended;\n\t/**\n\t * Finds the router whose route hierarchy the route has been appended to.\n\t *\n\t * Throws if the route was not appended to any router.\n\t */\n\tfunction findRouter(route) {\n\t    while (route.parent) {\n\t        route = route.parent;\n\t    }\n\t    var router = parentMap.get(route);\n\t    if (!router) {\n\t        throw new Error('Cannot generate link for route that is not in the hierarchy');\n\t    }\n\t    else {\n\t        return router;\n\t    }\n\t}\n\texports.findRouter = findRouter;\n\tvar privateStateMap = new WeakMap_1.default();\n\t// istanbul ignore next\n\tvar noop = function () { };\n\tfunction createDeferral() {\n\t    // Use noop since TypeScript doesn't know we're assigning cancel and resume in the promise executor.\n\t    var cancel = noop;\n\t    var resume = noop;\n\t    var promise = new Promise_1.default(function (resolve, reject) {\n\t        cancel = reject;\n\t        // Wrap resolve to avoid resume being called with a thenable if type checking is not used.\n\t        resume = function () { return resolve(); };\n\t    });\n\t    return { cancel: cancel, promise: promise, resume: resume };\n\t}\n\tfunction reportError(router, context, path, error) {\n\t    router.emit({\n\t        context: context,\n\t        error: error,\n\t        path: path,\n\t        target: router,\n\t        type: 'error'\n\t    });\n\t}\n\tfunction catchRejection(router, context, path, thenable) {\n\t    if (thenable) {\n\t        Promise_1.default.resolve(thenable).catch(function (error) {\n\t            reportError(router, context, path, error);\n\t        });\n\t    }\n\t}\n\tvar createRouter = compose_1.default.mixin(createEvented_1.default, {\n\t    mixin: {\n\t        append: function (add) {\n\t            var _this = this;\n\t            var routes = privateStateMap.get(this).routes;\n\t            var append = function (route) {\n\t                if (hasBeenAppended(route)) {\n\t                    throw new Error('Cannot append route that has already been appended');\n\t                }\n\t                routes.push(route);\n\t                parentMap.set(route, _this);\n\t            };\n\t            if (Array.isArray(add)) {\n\t                for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {\n\t                    var route = add_1[_i];\n\t                    append(route);\n\t                }\n\t            }\n\t            else {\n\t                append(add);\n\t            }\n\t        },\n\t        dispatch: function (context, path) {\n\t            var _this = this;\n\t            var state = privateStateMap.get(this);\n\t            var dispatchFromStart = state.dispatchFromStart;\n\t            // Reset, any further calls can't have come from start(). This is necessary since the navstart listeners\n\t            // may call dispatch() themselves.\n\t            state.dispatchFromStart = false;\n\t            var canceled = false;\n\t            var cancel = function () {\n\t                canceled = true;\n\t            };\n\t            var deferrals = [];\n\t            this.emit({\n\t                cancel: cancel,\n\t                defer: function () {\n\t                    var _a = createDeferral(), cancel = _a.cancel, promise = _a.promise, resume = _a.resume;\n\t                    deferrals.push(promise);\n\t                    return { cancel: cancel, resume: resume };\n\t                },\n\t                path: path,\n\t                target: this,\n\t                type: 'navstart'\n\t            });\n\t            // Synchronous cancelation.\n\t            if (canceled) {\n\t                return Task_1.default.resolve({ success: false });\n\t            }\n\t            var _a = path_1.parse(path), searchParams = _a.searchParams, segments = _a.segments, trailingSlash = _a.trailingSlash;\n\t            return new Task_1.default(function (resolve, reject) {\n\t                // *Always* start dispatching in a future turn, even if there were no deferrals.\n\t                Promise_1.default.all(deferrals).then(function () {\n\t                    // The cancel() function used in the NavigationStartEvent is reused as the Task canceler.\n\t                    // Strictly speaking any navstart listener can cancel the dispatch asynchronously, as long as it\n\t                    // manages to do so before this turn.\n\t                    if (canceled) {\n\t                        return { success: false };\n\t                    }\n\t                    var fallback = state.fallback, routes = state.routes;\n\t                    var redirect;\n\t                    var dispatched = routes.some(function (route) {\n\t                        var result = route.select(context, segments, trailingSlash, searchParams);\n\t                        if (typeof result === 'string') {\n\t                            redirect = result;\n\t                            return true;\n\t                        }\n\t                        if (result.length === 0) {\n\t                            return false;\n\t                        }\n\t                        // Update the selected routes after selecting new routes, but before invoking the handlers.\n\t                        // This means the original value is available to guard() and params() functions, and the\n\t                        // new value when the newly selected routes are executed.\n\t                        //\n\t                        // Reset selected routes if not dispatched from start().\n\t                        state.currentSelection = dispatchFromStart ? result : [];\n\t                        for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {\n\t                            var _a = result_1[_i], handler = _a.handler, params = _a.params;\n\t                            catchRejection(_this, context, path, handler({ context: context, params: params }));\n\t                        }\n\t                        return true;\n\t                    });\n\t                    // Reset the selected routes if the dispatch was unsuccessful, or if a redirect was requested.\n\t                    if (!dispatched || redirect !== undefined) {\n\t                        state.currentSelection = [];\n\t                    }\n\t                    if (!dispatched && fallback) {\n\t                        catchRejection(_this, context, path, fallback({ context: context, params: {} }));\n\t                        return { success: false };\n\t                    }\n\t                    var result = { success: dispatched };\n\t                    if (redirect !== undefined) {\n\t                        result.redirect = redirect;\n\t                    }\n\t                    return result;\n\t                }, \n\t                // When deferrals are canceled their corresponding promise is rejected. Ensure the task resolves\n\t                // with `false` instead of being rejected too.\n\t                function () {\n\t                    return { success: false };\n\t                }).then(resolve, function (error) {\n\t                    reportError(_this, context, path, error);\n\t                    reject(error);\n\t                });\n\t            }, cancel);\n\t        },\n\t        link: function (route, params) {\n\t            if (params === void 0) { params = {}; }\n\t            var _a = privateStateMap.get(this), history = _a.history, roots = _a.routes, currentSelection = _a.currentSelection;\n\t            var hierarchy = [route];\n\t            for (var parent_1 = route.parent; parent_1 !== undefined; parent_1 = parent_1.parent) {\n\t                hierarchy.unshift(parent_1);\n\t            }\n\t            if (!array_1.includes(roots, hierarchy[0])) {\n\t                throw new Error('Cannot generate link for route that is not in the hierarchy');\n\t            }\n\t            var addLeadingSlash = hierarchy[0].path.leadingSlash;\n\t            var addTrailingSlash = false;\n\t            var segments = [];\n\t            var searchParams = new UrlSearchParams_1.default();\n\t            hierarchy\n\t                .map(function (route, index) {\n\t                var path = route.path;\n\t                var currentPathValues;\n\t                var currentSearchParams;\n\t                var selection = currentSelection[index];\n\t                if (selection && selection.route === route) {\n\t                    currentPathValues = selection.rawPathValues;\n\t                    currentSearchParams = selection.rawSearchParams;\n\t                }\n\t                return { currentPathValues: currentPathValues, currentSearchParams: currentSearchParams, path: path };\n\t            })\n\t                .forEach(function (_a) {\n\t                var currentPathValues = _a.currentPathValues, currentSearchParams = _a.currentSearchParams, path = _a.path;\n\t                var expectedSegments = path.expectedSegments, searchParameters = path.searchParameters, trailingSlash = path.trailingSlash;\n\t                addTrailingSlash = trailingSlash;\n\t                var namedOffset = 0;\n\t                for (var _i = 0, expectedSegments_1 = expectedSegments; _i < expectedSegments_1.length; _i++) {\n\t                    var segment = expectedSegments_1[_i];\n\t                    if (path_1.isNamedSegment(segment)) {\n\t                        var value = params[segment.name];\n\t                        if (typeof value === 'string') {\n\t                            segments.push(value);\n\t                        }\n\t                        else if (Array.isArray(value)) {\n\t                            if (value.length === 1) {\n\t                                segments.push(value[0]);\n\t                            }\n\t                            else {\n\t                                throw new TypeError(\"Cannot generate link, multiple values for parameter '\" + segment.name + \"'\");\n\t                            }\n\t                        }\n\t                        else if (currentPathValues) {\n\t                            segments.push(currentPathValues[namedOffset]);\n\t                        }\n\t                        else {\n\t                            throw new Error(\"Cannot generate link, missing parameter '\" + segment.name + \"'\");\n\t                        }\n\t                        namedOffset++;\n\t                    }\n\t                    else {\n\t                        segments.push(segment.literal);\n\t                    }\n\t                }\n\t                for (var _b = 0, searchParameters_1 = searchParameters; _b < searchParameters_1.length; _b++) {\n\t                    var key = searchParameters_1[_b];\n\t                    // Don't repeat the search parameter if a previous route in the hierarchy has already appended\n\t                    // it.\n\t                    if (searchParams.has(key)) {\n\t                        continue;\n\t                    }\n\t                    var value = params[key];\n\t                    if (typeof value === 'string') {\n\t                        searchParams.append(key, value);\n\t                    }\n\t                    else if (Array.isArray(value)) {\n\t                        for (var _c = 0, value_1 = value; _c < value_1.length; _c++) {\n\t                            var item = value_1[_c];\n\t                            searchParams.append(key, item);\n\t                        }\n\t                    }\n\t                    else if (currentSearchParams) {\n\t                        for (var _d = 0, _e = currentSearchParams[key]; _d < _e.length; _d++) {\n\t                            var item = _e[_d];\n\t                            searchParams.append(key, item);\n\t                        }\n\t                    }\n\t                    else {\n\t                        throw new Error(\"Cannot generate link, missing search parameter '\" + key + \"'\");\n\t                    }\n\t                }\n\t            });\n\t            var pathname = segments.join('/');\n\t            if (addLeadingSlash) {\n\t                pathname = '/' + pathname;\n\t            }\n\t            if (addTrailingSlash) {\n\t                pathname += '/';\n\t            }\n\t            if (history) {\n\t                pathname = history.prefix(pathname);\n\t            }\n\t            var search = searchParams.toString();\n\t            var path = search ? pathname + \"?\" + search : pathname;\n\t            return path;\n\t        },\n\t        replacePath: function (path) {\n\t            var history = privateStateMap.get(this).history;\n\t            if (!history) {\n\t                throw new Error('Cannot replace path, router was created without a history manager');\n\t            }\n\t            history.replace(path);\n\t        },\n\t        setPath: function (path) {\n\t            var history = privateStateMap.get(this).history;\n\t            if (!history) {\n\t                throw new Error('Cannot set path, router was created without a history manager');\n\t            }\n\t            history.set(path);\n\t        },\n\t        start: function (_a) {\n\t            var _this = this;\n\t            var dispatchCurrent = (_a === void 0 ? { dispatchCurrent: true } : _a).dispatchCurrent;\n\t            var state = privateStateMap.get(this);\n\t            if (state.started) {\n\t                throw new Error('start can only be called once');\n\t            }\n\t            state.started = true;\n\t            var contextFactory = state.contextFactory, history = state.history;\n\t            if (!history) {\n\t                return {\n\t                    pause: function () { },\n\t                    resume: function () { },\n\t                    destroy: function () { }\n\t                };\n\t            }\n\t            var lastDispatch;\n\t            var redirectCount = 0;\n\t            var redirecting = false;\n\t            var dispatch = function (path) {\n\t                if (lastDispatch) {\n\t                    lastDispatch.cancel();\n\t                }\n\t                // Reset redirect count if the dispatch was triggered by a non-redirect history change. This allows\n\t                // a route's exec / fallback / index handler to change the history, setting off a new flurry of\n\t                // redirects, without being encumbered by the number of redirects that led to that route being selected.\n\t                if (!redirecting) {\n\t                    redirectCount = 0;\n\t                }\n\t                // Signal to dispatch() that it was called from here.\n\t                state.dispatchFromStart = true;\n\t                var context = contextFactory();\n\t                lastDispatch = _this.dispatch(context, path).then(function (dispatchResult) {\n\t                    var _a = dispatchResult || { success: false }, success = _a.success, _b = _a.redirect, redirect = _b === void 0 ? undefined : _b;\n\t                    if (success && redirect !== undefined) {\n\t                        redirectCount++;\n\t                        if (redirectCount > 20) {\n\t                            var error = new Error('More than 20 redirects, giving up');\n\t                            reportError(_this, context, path, error);\n\t                            throw error;\n\t                        }\n\t                        redirecting = true;\n\t                        // The history manager MUST emit the change event synchronously.\n\t                        history.replace(redirect);\n\t                        redirecting = false;\n\t                    }\n\t                    return dispatchResult;\n\t                });\n\t            };\n\t            var listener = on_1.pausable(history, 'change', function (event) {\n\t                dispatch(event.value);\n\t            });\n\t            this.own(listener);\n\t            if (dispatchCurrent) {\n\t                dispatch(history.current);\n\t            }\n\t            return listener;\n\t        }\n\t    },\n\t    initialize: function (instance, _a) {\n\t        var _b = _a === void 0 ? {} : _a, context = _b.context, fallback = _b.fallback, history = _b.history;\n\t        var contextFactory;\n\t        if (typeof context === 'function') {\n\t            contextFactory = context;\n\t        }\n\t        else if (typeof context === 'undefined') {\n\t            contextFactory = function () {\n\t                return {};\n\t            };\n\t        }\n\t        else {\n\t            // Assign to a constant since the context variable may be changed after the function is defined,\n\t            // which would violate its typing.\n\t            var sharedContext_1 = context;\n\t            contextFactory = function () { return sharedContext_1; };\n\t        }\n\t        if (history) {\n\t            instance.own(history);\n\t        }\n\t        privateStateMap.set(instance, {\n\t            contextFactory: contextFactory,\n\t            currentSelection: [],\n\t            dispatchFromStart: false,\n\t            fallback: fallback,\n\t            history: history,\n\t            routes: []\n\t        });\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createRouter;\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar aspect_1 = __webpack_require__(37);\n\tvar Map_1 = __webpack_require__(30);\n\tvar WeakMap_1 = __webpack_require__(20);\n\tvar createDestroyable_1 = __webpack_require__(38);\n\t/**\n\t * A weak map that contains a map of the listeners for an `Evented`\n\t */\n\tvar listenersMap = new WeakMap_1.default();\n\t/**\n\t * A guard which determines if the value is `Actionable`\n\t *\n\t * @param value The value to guard against\n\t */\n\tfunction isActionable(value) {\n\t    return Boolean(value && typeof value.do === 'function');\n\t}\n\t/**\n\t * An internal function that always returns an EventedCallback\n\t *\n\t * @param listener Either a `EventedCallback` or an `Actionable`\n\t */\n\tfunction resolveListener(listener) {\n\t    return isActionable(listener) ? function (event) { return listener.do({ event: event }); } : listener;\n\t}\n\texports.resolveListener = resolveListener;\n\t/**\n\t * Internal function to convert an array of handles to a single handle\n\t *\n\t * @param handles The array of handles to convert into a signle handle\n\t * @return The single handle\n\t */\n\tfunction handlesArraytoHandle(handles) {\n\t    return {\n\t        destroy: function () {\n\t            handles.forEach(function (handle) { return handle.destroy(); });\n\t        }\n\t    };\n\t}\n\t/**\n\t * Creates a new instance of an `Evented`\n\t */\n\tvar createEvented = createDestroyable_1.default\n\t    .mixin({\n\t    className: 'Evented',\n\t    mixin: {\n\t        emit: function (event) {\n\t            var method = listenersMap.get(this).get(event.type);\n\t            if (method) {\n\t                method.call(this, event);\n\t            }\n\t        },\n\t        on: function () {\n\t            var _this = this;\n\t            var args = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                args[_i] = arguments[_i];\n\t            }\n\t            var listenerMap = listenersMap.get(this);\n\t            if (args.length === 2) {\n\t                var _a = args, type_1 = _a[0], listeners = _a[1];\n\t                if (Array.isArray(listeners)) {\n\t                    var handles = listeners.map(function (listener) { return aspect_1.on(listenerMap, type_1, resolveListener(listener)); });\n\t                    return handlesArraytoHandle(handles);\n\t                }\n\t                else {\n\t                    return aspect_1.on(listenerMap, type_1, resolveListener(listeners));\n\t                }\n\t            }\n\t            else if (args.length === 1) {\n\t                var listenerMapArg_1 = args[0];\n\t                var handles = Object.keys(listenerMapArg_1).map(function (type) { return _this.on(type, listenerMapArg_1[type]); });\n\t                return handlesArraytoHandle(handles);\n\t            }\n\t            else {\n\t                throw new TypeError('Invalid arguments');\n\t            }\n\t        }\n\t    },\n\t    initialize: function (instance, options) {\n\t        listenersMap.set(instance, new Map_1.default());\n\t        if (options && options.listeners) {\n\t            instance.own(instance.on(options.listeners));\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createEvented;\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(13);\n\t/**\n\t * An internal type guard that determines if an value is MapLike or not\n\t *\n\t * @param value The value to guard against\n\t */\n\tfunction isMapLike(value) {\n\t    return value && typeof value.get === 'function' && typeof value.set === 'function';\n\t}\n\t/**\n\t * A UID for tracking advice ordering\n\t */\n\tvar nextId = 0;\n\t/**\n\t * Internal function that advises a join point\n\t *\n\t * @param dispatcher The current advice dispatcher\n\t * @param type The type of before or after advice to apply\n\t * @param advice The advice to apply\n\t * @param receiveArguments If true, the advice will receive the arguments passed to the join point\n\t * @return The handle that will remove the advice\n\t */\n\tfunction advise(dispatcher, type, advice, receiveArguments) {\n\t    var previous = dispatcher && dispatcher[type];\n\t    var advised = {\n\t        id: nextId++,\n\t        advice: advice,\n\t        receiveArguments: receiveArguments\n\t    };\n\t    if (previous) {\n\t        if (type === 'after') {\n\t            // add the listener to the end of the list\n\t            // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n\t            while (previous.next && (previous = previous.next)) { }\n\t            previous.next = advised;\n\t            advised.previous = previous;\n\t        }\n\t        else {\n\t            // add to the beginning\n\t            if (dispatcher) {\n\t                dispatcher.before = advised;\n\t            }\n\t            advised.next = previous;\n\t            previous.previous = advised;\n\t        }\n\t    }\n\t    else {\n\t        dispatcher && (dispatcher[type] = advised);\n\t    }\n\t    advice = previous = undefined;\n\t    return lang_1.createHandle(function () {\n\t        var _a = (advised || {}), _b = _a.previous, previous = _b === void 0 ? undefined : _b, _c = _a.next, next = _c === void 0 ? undefined : _c;\n\t        if (dispatcher && !previous && !next) {\n\t            dispatcher[type] = undefined;\n\t        }\n\t        else {\n\t            if (previous) {\n\t                previous.next = next;\n\t            }\n\t            else {\n\t                dispatcher && (dispatcher[type] = next);\n\t            }\n\t            if (next) {\n\t                next.previous = previous;\n\t            }\n\t        }\n\t        if (advised) {\n\t            delete advised.advice;\n\t        }\n\t        dispatcher = advised = undefined;\n\t    });\n\t}\n\t/**\n\t * An internal function that resolves or creates the dispatcher for a given join point\n\t *\n\t * @param target The target object or map\n\t * @param methodName The name of the method that the dispatcher should be resolved for\n\t * @return The dispatcher\n\t */\n\tfunction getDispatcher(target, methodName) {\n\t    var existing = isMapLike(target) ? target.get(methodName) : target && target[methodName];\n\t    var dispatcher;\n\t    if (!existing || existing.target !== target) {\n\t        /* There is no existing dispatcher, therefore we will create one */\n\t        dispatcher = function () {\n\t            var executionId = nextId;\n\t            var args = arguments;\n\t            var results;\n\t            var before = dispatcher.before;\n\t            while (before) {\n\t                if (before.advice) {\n\t                    args = before.advice.apply(this, args) || args;\n\t                }\n\t                before = before.next;\n\t            }\n\t            if (dispatcher.around && dispatcher.around.advice) {\n\t                results = dispatcher.around.advice(this, args);\n\t            }\n\t            var after = dispatcher.after;\n\t            while (after && after.id < executionId) {\n\t                if (after.advice) {\n\t                    if (after.receiveArguments) {\n\t                        var newResults = after.advice.apply(this, args);\n\t                        results = newResults === undefined ? results : newResults;\n\t                    }\n\t                    else {\n\t                        results = after.advice.call(this, results, args);\n\t                    }\n\t                }\n\t                after = after.next;\n\t            }\n\t            return results;\n\t        };\n\t        if (isMapLike(target)) {\n\t            target.set(methodName, dispatcher);\n\t        }\n\t        else {\n\t            target && (target[methodName] = dispatcher);\n\t        }\n\t        if (existing) {\n\t            dispatcher.around = {\n\t                advice: function (target, args) {\n\t                    return existing.apply(target, args);\n\t                }\n\t            };\n\t        }\n\t        dispatcher.target = target;\n\t    }\n\t    else {\n\t        dispatcher = existing;\n\t    }\n\t    return dispatcher;\n\t}\n\t/**\n\t * Attaches \"after\" advice to be executed after the original method.\n\t * The advising function will receive the original method's return value and arguments object.\n\t * The value it returns will be returned from the method when it is called (even if the return value is undefined).\n\t *\n\t * @param target Object whose method will be aspected\n\t * @param methodName Name of method to aspect\n\t * @param advice Advising function which will receive the original method's return value and arguments object\n\t * @return A handle which will remove the aspect when destroy is called\n\t */\n\tfunction after(target, methodName, advice) {\n\t    return advise(getDispatcher(target, methodName), 'after', advice);\n\t}\n\texports.after = after;\n\t/**\n\t * Attaches \"around\" advice around the original method.\n\t *\n\t * @param target Object whose method will be aspected\n\t * @param methodName Name of method to aspect\n\t * @param advice Advising function which will receive the original function\n\t * @return A handle which will remove the aspect when destroy is called\n\t */\n\tfunction around(target, methodName, advice) {\n\t    var dispatcher = getDispatcher(target, methodName);\n\t    var previous = dispatcher.around;\n\t    var advised;\n\t    if (advice) {\n\t        advised = advice(function () {\n\t            if (previous && previous.advice) {\n\t                return previous.advice(this, arguments);\n\t            }\n\t        });\n\t    }\n\t    dispatcher.around = {\n\t        advice: function (target, args) {\n\t            return advised ? advised.apply(target, args) : previous && previous.advice && previous.advice(target, args);\n\t        }\n\t    };\n\t    return lang_1.createHandle(function () {\n\t        advised = dispatcher = undefined;\n\t    });\n\t}\n\texports.around = around;\n\t/**\n\t * Attaches \"before\" advice to be executed before the original method.\n\t *\n\t * @param target Object whose method will be aspected\n\t * @param methodName Name of method to aspect\n\t * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n\t * @return A handle which will remove the aspect when destroy is called\n\t */\n\tfunction before(target, methodName, advice) {\n\t    return advise(getDispatcher(target, methodName), 'before', advice);\n\t}\n\texports.before = before;\n\t/**\n\t * Attaches advice to be executed after the original method.\n\t * The advising function will receive the same arguments as the original method.\n\t * The value it returns will be returned from the method when it is called *unless* its return value is undefined.\n\t *\n\t * @param target Object whose method will be aspected\n\t * @param methodName Name of method to aspect\n\t * @param advice Advising function which will receive the same arguments as the original method\n\t * @return A handle which will remove the aspect when destroy is called\n\t */\n\tfunction on(target, methodName, advice) {\n\t    return advise(getDispatcher(target, methodName), 'after', advice, true);\n\t}\n\texports.on = on;\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Promise_1 = __webpack_require__(23);\n\tvar WeakMap_1 = __webpack_require__(20);\n\tvar compose_1 = __webpack_require__(6);\n\t/**\n\t * A reference to a function that always returns a promise which resolves to false\n\t */\n\tfunction noop() {\n\t    return Promise_1.default.resolve(false);\n\t}\n\t/**\n\t * A reference to a function that throws, used to replace the `own()` method after\n\t * destruction\n\t */\n\tfunction destroyed() {\n\t    throw new Error('Call made to destroyed method');\n\t}\n\t/**\n\t * A weak map for *owning* handles on instances\n\t */\n\tvar handlesWeakMap = new WeakMap_1.default();\n\t/**\n\t * A type guard that determines if the value is a Destroyable\n\t *\n\t * @param value The value to guard for\n\t */\n\tfunction isDestroyable(value) {\n\t    return Boolean(value && 'destroy' in value && typeof value.destroy === 'function');\n\t}\n\texports.isDestroyable = isDestroyable;\n\t/**\n\t * A mixin which adds the concepts of being able to *destroy* handles which the instance\n\t * *owns*\n\t */\n\tvar createDestroyable = compose_1.default('Destroyable', {\n\t    own: function (handle) {\n\t        var handles = handlesWeakMap.get(this);\n\t        handles.push(handle);\n\t        return {\n\t            destroy: function () {\n\t                handles.splice(handles.indexOf(handle));\n\t                handle.destroy();\n\t            }\n\t        };\n\t    },\n\t    destroy: function () {\n\t        var _this = this;\n\t        return new Promise_1.default(function (resolve) {\n\t            handlesWeakMap.get(_this).forEach(function (handle) {\n\t                handle && handle.destroy && handle.destroy();\n\t            });\n\t            _this.destroy = noop;\n\t            _this.own = destroyed;\n\t            resolve(true);\n\t        });\n\t    }\n\t}, function (instance) {\n\t    handlesWeakMap.set(instance, []);\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createDestroyable;\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t\"use strict\";\n\tvar ExtensiblePromise_1 = __webpack_require__(40);\n\t/**\n\t * A type guard that determines if `value` is a `Task`\n\t * @param value The value to guard\n\t */\n\tfunction isTask(value) {\n\t    return Boolean(value && typeof value.cancel === 'function' && Array.isArray(value.children) && isThenable(value));\n\t}\n\texports.isTask = isTask;\n\t/**\n\t * Returns true if a given value has a `then` method.\n\t * @param {any} value The value to check if is Thenable\n\t * @returns {is Thenable<T>} A type guard if the value is thenable\n\t */\n\tfunction isThenable(value) {\n\t    return value && typeof value.then === 'function';\n\t}\n\texports.isThenable = isThenable;\n\t/**\n\t * Task is an extension of Promise that supports cancellation and the Task#finally method.\n\t */\n\tvar Task = (function (_super) {\n\t    __extends(Task, _super);\n\t    /**\n\t     * @constructor\n\t     *\n\t     * Create a new task. Executor is run immediately. The canceler will be called when the task is canceled.\n\t     *\n\t     * @param executor Method that initiates some task\n\t     * @param canceler Method to call when the task is canceled\n\t     *\n\t     */\n\t    function Task(executor, canceler) {\n\t        var _this = this;\n\t        // we have to initialize these to avoid a compiler error of using them before they are initialized\n\t        var superResolve = function () { };\n\t        var superReject = function () { };\n\t        _this = _super.call(this, function (resolve, reject) {\n\t            superResolve = resolve;\n\t            superReject = reject;\n\t        }) || this;\n\t        _this._state = 1 /* Pending */;\n\t        _this.children = [];\n\t        _this.canceler = function () {\n\t            if (canceler) {\n\t                canceler();\n\t            }\n\t            _this._cancel();\n\t        };\n\t        // Don't let the Task resolve if it's been canceled\n\t        try {\n\t            executor(function (value) {\n\t                if (_this._state === 3 /* Canceled */) {\n\t                    return;\n\t                }\n\t                _this._state = 0 /* Fulfilled */;\n\t                superResolve(value);\n\t            }, function (reason) {\n\t                if (_this._state === 3 /* Canceled */) {\n\t                    return;\n\t                }\n\t                _this._state = 2 /* Rejected */;\n\t                superReject(reason);\n\t            });\n\t        }\n\t        catch (reason) {\n\t            _this._state = 2 /* Rejected */;\n\t            superReject(reason);\n\t        }\n\t        return _this;\n\t    }\n\t    /**\n\t     * Return a Task that resolves when one of the passed in objects have resolved\n\t     *\n\t     * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t     * @returns {Task}\n\t     */\n\t    Task.race = function (iterable) {\n\t        return _super.race.call(this, iterable);\n\t    };\n\t    /**\n\t     * Return a rejected promise wrapped in a Task\n\t     *\n\t     * @param {Error?} reason    The reason for the rejection\n\t     * @returns {Task}\n\t     */\n\t    Task.reject = function (reason) {\n\t        return new this(function (resolve, reject) { return reject(reason); });\n\t    };\n\t    Task.resolve = function (value) {\n\t        return new this(function (resolve, reject) { return resolve(value); });\n\t    };\n\t    Task.all = function (iterable) {\n\t        return _super.all.call(this, iterable);\n\t    };\n\t    Object.defineProperty(Task.prototype, \"state\", {\n\t        get: function () {\n\t            return this._state;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    /**\n\t     * Propagates cancellation down through a Task tree. The Task's state is immediately set to canceled. If a Thenable\n\t     * finally task was passed in, it is resolved before calling this Task's finally callback; otherwise, this Task's\n\t     * finally callback is immediately executed. `_cancel` is called for each child Task, passing in the value returned\n\t     * by this Task's finally callback or a Promise chain that will eventually resolve to that value.\n\t     */\n\t    Task.prototype._cancel = function (finallyTask) {\n\t        var _this = this;\n\t        this._state = 3 /* Canceled */;\n\t        var runFinally = function () {\n\t            try {\n\t                return _this._finally();\n\t            }\n\t            catch (error) {\n\t            }\n\t        };\n\t        if (this._finally) {\n\t            if (isThenable(finallyTask)) {\n\t                finallyTask = finallyTask.then(runFinally, runFinally);\n\t            }\n\t            else {\n\t                finallyTask = runFinally();\n\t            }\n\t        }\n\t        this.children.forEach(function (child) {\n\t            child._cancel(finallyTask);\n\t        });\n\t    };\n\t    /**\n\t     * Immediately cancels this task if it has not already resolved. This Task and any descendants are synchronously set\n\t     * to the Canceled state and any `finally` added downstream from the canceled Task are invoked.\n\t     */\n\t    Task.prototype.cancel = function () {\n\t        if (this._state === 1 /* Pending */) {\n\t            this.canceler();\n\t        }\n\t    };\n\t    Task.prototype.catch = function (onRejected) {\n\t        return this.then(undefined, onRejected);\n\t    };\n\t    /**\n\t     * Allows for cleanup actions to be performed after resolution of a Promise.\n\t     */\n\t    Task.prototype.finally = function (callback) {\n\t        // if this task is already canceled, call the task\n\t        if (this._state === 3 /* Canceled */) {\n\t            return Task.resolve(callback());\n\t        }\n\t        var task = this.then(function (value) { return Task.resolve(callback()).then(function () { return value; }); }, function (reason) { return Task.resolve(callback()).then(function () {\n\t            throw reason;\n\t        }); });\n\t        // Keep a reference to the callback; it will be called if the Task is canceled\n\t        task._finally = callback;\n\t        return task;\n\t    };\n\t    Task.prototype.then = function (onFulfilled, onRejected) {\n\t        var _this = this;\n\t        // FIXME\n\t        // tslint:disable-next-line:no-var-keyword\n\t        var task = _super.prototype.then.call(this, \n\t        // Don't call the onFulfilled or onRejected handlers if this Task is canceled\n\t        function (value) {\n\t            if (task._state === 3 /* Canceled */) {\n\t                return;\n\t            }\n\t            if (onFulfilled) {\n\t                return onFulfilled(value);\n\t            }\n\t            return value;\n\t        }, function (error) {\n\t            if (task._state === 3 /* Canceled */) {\n\t                return;\n\t            }\n\t            if (onRejected) {\n\t                return onRejected(error);\n\t            }\n\t            throw error;\n\t        });\n\t        task.canceler = function () {\n\t            // If task's parent (this) hasn't been resolved, cancel it; downward propagation will start at the first\n\t            // unresolved parent\n\t            if (_this._state === 1 /* Pending */) {\n\t                _this.cancel();\n\t            }\n\t            else {\n\t                task._cancel();\n\t            }\n\t        };\n\t        // Keep track of child Tasks for propogating cancelation back down the chain\n\t        this.children.push(task);\n\t        return task;\n\t    };\n\t    return Task;\n\t}(ExtensiblePromise_1.default));\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Task;\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar iterator_1 = __webpack_require__(16);\n\tvar Promise_1 = __webpack_require__(23);\n\t/**\n\t * Take a list of values, and if any are ExtensiblePromise objects, insert the wrapped Promise in its place,\n\t * otherwise use the original object. We use this to help use the native Promise methods like `all` and `race`.\n\t *\n\t * @param iterable    The list of objects to iterate over\n\t * @returns {any[]}    The list of objects, as an array, with ExtensiblePromises being replaced by Promises.\n\t */\n\tfunction unwrapPromises(iterable) {\n\t    var unwrapped = [];\n\t    iterator_1.forOf(iterable, function (item) {\n\t        unwrapped.push(item instanceof ExtensiblePromise ? item._promise : item);\n\t    });\n\t    return unwrapped;\n\t}\n\t/**\n\t * An extensible base to allow Promises to be extended in ES5. This class basically wraps a native Promise object,\n\t * giving an API like a native promise.\n\t */\n\tvar ExtensiblePromise = (function () {\n\t    /**\n\t     * Creates a new extended Promise.\n\t     *\n\t     * @constructor\n\t     *\n\t     * @param executor\n\t     * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t     * starting the asynchronous operation when it is invoked.\n\t     *\n\t     * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t     * successfully, or the `reject` function when the operation fails.\n\t     */\n\t    function ExtensiblePromise(executor) {\n\t        this._promise = new Promise_1.default(executor);\n\t    }\n\t    /**\n\t     * Return a rejected promise wrapped in an ExtensiblePromise\n\t     *\n\t     * @param {Error?} reason    The reason for the rejection\n\t     * @returns {ExtensiblePromise}\n\t     */\n\t    ExtensiblePromise.reject = function (reason) {\n\t        return new this(function (resolve, reject) { return reject(reason); });\n\t    };\n\t    ExtensiblePromise.resolve = function (value) {\n\t        return new this(function (resolve, reject) { return resolve(value); });\n\t    };\n\t    ExtensiblePromise.all = function (iterable) {\n\t        if (!iterator_1.isArrayLike(iterable) && !iterator_1.isIterable(iterable)) {\n\t            var promiseKeys_1 = Object.keys(iterable);\n\t            return new this(function (resolve, reject) {\n\t                Promise_1.default.all(promiseKeys_1.map(function (key) { return iterable[key]; })).then(function (promiseResults) {\n\t                    var returnValue = {};\n\t                    promiseResults.forEach(function (value, index) {\n\t                        returnValue[promiseKeys_1[index]] = value;\n\t                    });\n\t                    resolve(returnValue);\n\t                }, reject);\n\t            });\n\t        }\n\t        return new this(function (resolve, reject) {\n\t            Promise_1.default.all(unwrapPromises(iterable)).then(resolve, reject);\n\t        });\n\t    };\n\t    /**\n\t     * Return a ExtensiblePromise that resolves when one of the passed in objects have resolved\n\t     *\n\t     * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t     * @returns {ExtensiblePromise}\n\t     */\n\t    ExtensiblePromise.race = function (iterable) {\n\t        return new this(function (resolve, reject) {\n\t            Promise_1.default.race(unwrapPromises(iterable)).then(resolve, reject);\n\t        });\n\t    };\n\t    ExtensiblePromise.prototype.catch = function (onRejected) {\n\t        return this.then(undefined, onRejected);\n\t    };\n\t    ExtensiblePromise.prototype.then = function (onFulfilled, onRejected) {\n\t        var _this = this;\n\t        var e = function (resolve, reject) {\n\t            function handler(rejected, valueOrError) {\n\t                var callback = rejected ? onRejected : onFulfilled;\n\t                if (typeof callback === 'function') {\n\t                    try {\n\t                        resolve(callback(valueOrError));\n\t                    }\n\t                    catch (error) {\n\t                        reject(error);\n\t                    }\n\t                }\n\t                else if (rejected) {\n\t                    reject(valueOrError);\n\t                }\n\t                else {\n\t                    resolve(valueOrError);\n\t                }\n\t            }\n\t            _this._promise.then(handler.bind(null, false), handler.bind(null, true));\n\t        };\n\t        return new this.constructor(e);\n\t    };\n\t    return ExtensiblePromise;\n\t}());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = ExtensiblePromise;\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(13);\n\tfunction emit(target, event) {\n\t    if (target.dispatchEvent &&\n\t        ((target.ownerDocument && target.ownerDocument.createEvent) ||\n\t            (target.document && target.document.createEvent) ||\n\t            target.createEvent) /* matches document */) {\n\t        var nativeEvent = (target.ownerDocument || target.document || target).createEvent('HTMLEvents');\n\t        nativeEvent.initEvent(event.type, Boolean(event.bubbles), Boolean(event.cancelable));\n\t        for (var key in event) {\n\t            if (!(key in nativeEvent)) {\n\t                nativeEvent[key] = event[key];\n\t            }\n\t        }\n\t        return target.dispatchEvent(nativeEvent);\n\t    }\n\t    if (target.emit) {\n\t        if (target.removeListener) {\n\t            // Node.js EventEmitter\n\t            target.emit(event.type, event);\n\t            return false;\n\t        }\n\t        else if (target.on) {\n\t            // Dojo Evented or similar\n\t            target.emit(event);\n\t            return false;\n\t        }\n\t    }\n\t    throw new Error('Target must be an event emitter');\n\t}\n\texports.emit = emit;\n\tfunction on(target, type, listener, capture) {\n\t    if (Array.isArray(type)) {\n\t        var handles = type.map(function (type) {\n\t            return on(target, type, listener, capture);\n\t        });\n\t        return lang_1.createCompositeHandle.apply(void 0, handles);\n\t    }\n\t    var callback = function () {\n\t        listener.apply(this, arguments);\n\t    };\n\t    // DOM EventTarget\n\t    if (target.addEventListener && target.removeEventListener) {\n\t        target.addEventListener(type, callback, capture);\n\t        return lang_1.createHandle(function () {\n\t            target.removeEventListener(type, callback, capture);\n\t        });\n\t    }\n\t    if (target.on) {\n\t        // EventEmitter\n\t        if (target.removeListener) {\n\t            target.on(type, callback);\n\t            return lang_1.createHandle(function () {\n\t                target.removeListener(type, callback);\n\t            });\n\t        }\n\t        else if (target.emit) {\n\t            return target.on(type, listener);\n\t        }\n\t    }\n\t    throw new TypeError('Unknown event emitter object');\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = on;\n\tfunction once(target, type, listener, capture) {\n\t    // FIXME\n\t    // tslint:disable-next-line:no-var-keyword\n\t    var handle = on(target, type, function () {\n\t        handle.destroy();\n\t        return listener.apply(this, arguments);\n\t    }, capture);\n\t    return handle;\n\t}\n\texports.once = once;\n\tfunction pausable(target, type, listener, capture) {\n\t    var paused;\n\t    var handle = on(target, type, function () {\n\t        if (!paused) {\n\t            return listener.apply(this, arguments);\n\t        }\n\t    }, capture);\n\t    handle.pause = function () {\n\t        paused = true;\n\t    };\n\t    handle.resume = function () {\n\t        paused = false;\n\t    };\n\t    return handle;\n\t}\n\texports.pausable = pausable;\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar UrlSearchParams_1 = __webpack_require__(34);\n\t/**\n\t * Parses a path\n\t * @param path The path to parse.\n\t * @return The search params, pathname segments, and whether it ended with a trailing slash.\n\t */\n\tfunction parse(path) {\n\t    var tokens = path.split(/([/?#])/).filter(Boolean);\n\t    var pathnameTokens = tokens;\n\t    var searchParams;\n\t    var searchStart = tokens.indexOf('?');\n\t    var hashStart = tokens.indexOf('#');\n\t    if (searchStart >= 0) {\n\t        if (hashStart >= 0) {\n\t            // Either `/foo?bar#baz` or `/foo#bar?baz`\n\t            pathnameTokens = tokens.slice(0, Math.min(searchStart, hashStart));\n\t            searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1, hashStart).join(''));\n\t        }\n\t        else {\n\t            // `/foo?bar`\n\t            pathnameTokens = tokens.slice(0, searchStart);\n\t            searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1).join(''));\n\t        }\n\t    }\n\t    else {\n\t        searchParams = new UrlSearchParams_1.default();\n\t        if (hashStart >= 0) {\n\t            // `/foo#bar`\n\t            pathnameTokens = tokens.slice(0, hashStart);\n\t        }\n\t    }\n\t    var segments = pathnameTokens.filter(function (t) { return t !== '/'; });\n\t    var trailingSlash = pathnameTokens[pathnameTokens.length - 1] === '/' && segments.length > 0;\n\t    return {\n\t        searchParams: searchParams,\n\t        segments: segments,\n\t        trailingSlash: trailingSlash\n\t    };\n\t}\n\texports.parse = parse;\n\t/**\n\t * Determines whether a DeconstructedPath is a (partial) match for given pathname segments.\n\t * @param expectedSegments Part of a DeconstructedPath object.\n\t * @param segments Pathname segments as returned by `parse()`\n\t * @return A result object.\n\t */\n\tfunction match(_a, segments) {\n\t    var expectedSegments = _a.expectedSegments;\n\t    if (expectedSegments.length === 0) {\n\t        return {\n\t            hasRemaining: segments.length > 0,\n\t            offset: 0,\n\t            values: []\n\t        };\n\t    }\n\t    if (expectedSegments.length > segments.length) {\n\t        return null;\n\t    }\n\t    var isMatch = true;\n\t    var values = [];\n\t    for (var i = 0; isMatch && i < expectedSegments.length; i++) {\n\t        var value = segments[i];\n\t        var expected = expectedSegments[i];\n\t        if (isNamedSegment(expected)) {\n\t            values.push(value);\n\t        }\n\t        else if (expected.literal !== value) {\n\t            isMatch = false;\n\t        }\n\t    }\n\t    if (!isMatch) {\n\t        return null;\n\t    }\n\t    return {\n\t        hasRemaining: expectedSegments.length < segments.length,\n\t        offset: expectedSegments.length,\n\t        values: values\n\t    };\n\t}\n\texports.match = match;\n\t/**\n\t * Determine whether the segment is a NamedSegment.\n\t *\n\t * @param segment The segment to be checked\n\t * @return true if the segment is a NamedSegment, false otherwise\n\t */\n\tfunction isNamedSegment(segment) {\n\t    return segment.name !== undefined;\n\t}\n\texports.isNamedSegment = isNamedSegment;\n\t/**\n\t * Deconstruct a route path into its constituent parts.\n\t * @param path The path to deconstruct.\n\t * @return An object describing the path's constituent parts.\n\t */\n\tfunction deconstruct(path) {\n\t    var expectedSegments = [];\n\t    var parameters = [];\n\t    var searchParameters = [];\n\t    var trailingSlash = false;\n\t    var tokens = path.split(/([/{}?&])/).filter(Boolean);\n\t    var leadingSlash = tokens[0] === '/';\n\t    var i = 0;\n\t    var consume = function () { return tokens[i++]; };\n\t    var peek = function () { return tokens[i]; };\n\t    var inSearchComponent = false;\n\t    while (i < tokens.length) {\n\t        var t = consume();\n\t        switch (t) {\n\t            case '{': {\n\t                var name_1 = consume();\n\t                if (!name_1 || name_1 === '}') {\n\t                    throw new TypeError('Parameter must have a name');\n\t                }\n\t                // Reserve : for future use, e.g. including type data in the parameter declaration.\n\t                if (name_1 === '{' || name_1 === '&' || /:/.test(name_1)) {\n\t                    throw new TypeError('Parameter name must not contain \\'{\\', \\'&\\' or \\':\\'');\n\t                }\n\t                if (parameters.indexOf(name_1) !== -1 || searchParameters.indexOf(name_1) !== -1) {\n\t                    throw new TypeError(\"Parameter must have a unique name, got '\" + name_1 + \"'\");\n\t                }\n\t                var closing = consume();\n\t                if (!closing || closing !== '}') {\n\t                    throw new TypeError(\"Parameter name must be followed by '}', got '\" + closing + \"'\");\n\t                }\n\t                var separator = peek();\n\t                if (separator) {\n\t                    if (inSearchComponent) {\n\t                        if (separator !== '&') {\n\t                            throw new TypeError(\"Search parameter must be followed by '&', got '\" + separator + \"'\");\n\t                        }\n\t                    }\n\t                    else if (separator !== '/' && separator !== '?') {\n\t                        throw new TypeError(\"Parameter must be followed by '/' or '?', got '\" + separator + \"'\");\n\t                    }\n\t                }\n\t                if (inSearchComponent) {\n\t                    searchParameters.push(name_1);\n\t                }\n\t                else {\n\t                    parameters.push(name_1);\n\t                    expectedSegments.push(Object.freeze({ name: name_1 }));\n\t                }\n\t                break;\n\t            }\n\t            case '?':\n\t            case '/':\n\t                if (inSearchComponent) {\n\t                    throw new TypeError(\"Expected parameter in search component, got '\" + t + \"'\");\n\t                }\n\t                if (t === '?') {\n\t                    inSearchComponent = true;\n\t                    if (expectedSegments.length === 0) {\n\t                        throw new TypeError('Path must contain at least one segment');\n\t                    }\n\t                }\n\t                if (t === '/') {\n\t                    var next_1 = peek();\n\t                    if (next_1 === '/') {\n\t                        throw new TypeError('Path segment must not be empty');\n\t                    }\n\t                    if (expectedSegments.length > 0 && (!next_1 || next_1 === '?')) {\n\t                        trailingSlash = true;\n\t                    }\n\t                }\n\t                break;\n\t            case '&':\n\t                if (!inSearchComponent) {\n\t                    throw new TypeError('Path segment must not contain \\'&\\'');\n\t                }\n\t                var next = peek();\n\t                if (next === '&') {\n\t                    throw new TypeError('Expected parameter in search component, got \\'&\\'');\n\t                }\n\t                break;\n\t            default:\n\t                if (inSearchComponent) {\n\t                    throw new TypeError(\"Expected parameter in search component, got '\" + t + \"'\");\n\t                }\n\t                expectedSegments.push(Object.freeze({ literal: t }));\n\t        }\n\t    }\n\t    return Object.freeze({\n\t        expectedSegments: Object.freeze(expectedSegments),\n\t        leadingSlash: leadingSlash,\n\t        parameters: Object.freeze(parameters),\n\t        searchParameters: Object.freeze(searchParameters),\n\t        trailingSlash: trailingSlash\n\t    });\n\t}\n\texports.deconstruct = deconstruct;\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(6);\n\tvar createEvented_1 = __webpack_require__(36);\n\tvar global_1 = __webpack_require__(5);\n\tvar on_1 = __webpack_require__(41);\n\tvar WeakMap_1 = __webpack_require__(20);\n\tvar privateStateMap = new WeakMap_1.default();\n\tvar createHashHistory = compose_1.default.mixin(createEvented_1.default, {\n\t    mixin: {\n\t        get current() {\n\t            return privateStateMap.get(this).current;\n\t        },\n\t        prefix: function (path) {\n\t            return \"#\" + path;\n\t        },\n\t        set: function (path) {\n\t            var privateState = privateStateMap.get(this);\n\t            if (privateState.current === path) {\n\t                return;\n\t            }\n\t            privateState.current = path;\n\t            privateState.browserLocation.hash = this.prefix(path);\n\t            this.emit({\n\t                type: 'change',\n\t                value: path\n\t            });\n\t        },\n\t        replace: function (path) {\n\t            var privateState = privateStateMap.get(this);\n\t            if (privateState.current === path) {\n\t                return;\n\t            }\n\t            privateState.current = path;\n\t            var _a = privateState.browserLocation, pathname = _a.pathname, search = _a.search;\n\t            privateState.browserLocation.replace(pathname + search + this.prefix(path));\n\t            this.emit({\n\t                type: 'change',\n\t                value: path\n\t            });\n\t        }\n\t    },\n\t    initialize: function (instance, _a) {\n\t        var window = (_a === void 0 ? { window: global_1.default } : _a).window;\n\t        var browserLocation = window.location;\n\t        var privateState = {\n\t            current: browserLocation.hash.slice(1),\n\t            browserLocation: browserLocation\n\t        };\n\t        privateStateMap.set(instance, privateState);\n\t        instance.own(on_1.default(window, 'hashchange', function () {\n\t            var path = browserLocation.hash.slice(1);\n\t            // Ignore hashchange for the current path. Guards against browsers firing hashchange when the history\n\t            // manager sets the hash.\n\t            if (path !== privateState.current) {\n\t                privateState.current = path;\n\t                instance.emit({\n\t                    type: 'change',\n\t                    value: path\n\t                });\n\t            }\n\t        }));\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createHashHistory;\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(13);\n\tvar widgetStore_1 = __webpack_require__(45);\n\tvar todoStoreActions_1 = __webpack_require__(59);\n\texports.todoInput = function (_a) {\n\t    var which = _a.which, label = _a.target.value;\n\t    if (which === 13 && label) {\n\t        todoStoreActions_1.addTodo({ label: label, completed: false });\n\t        widgetStore_1.default.patch({ id: 'todo-app', todo: '' });\n\t        this.invalidate();\n\t    }\n\t};\n\tfunction toggleEditing(todos, todoId, editing) {\n\t    return todos\n\t        .filter(function (todo) { return todo.id === todoId; })\n\t        .map(function (todo) {\n\t        todo.editing = true;\n\t        return todo;\n\t    });\n\t}\n\texports.todoEdit = function (event) {\n\t    var id = this.properties.id;\n\t    if (event.type === 'keypress' && event.which !== 13 && event.which !== 32) {\n\t        return;\n\t    }\n\t    widgetStore_1.default.get('todo-app').then(function (todoListState) {\n\t        var todos = todoListState.todos;\n\t        todoListState.todos = toggleEditing(todos, id, true);\n\t        return widgetStore_1.default.patch({ id: 'todo-app', todoListState: todoListState });\n\t    });\n\t};\n\texports.todoEditInput = function (event) {\n\t    var id = this.properties.id;\n\t    if (event.which === 13) {\n\t        exports.todoSave.call(this, event);\n\t    }\n\t    else if (event.which === 27) {\n\t        widgetStore_1.default.get('todo-app').then(function (todoListState) {\n\t            todoListState.todos = toggleEditing(todoListState.todos, id, false);\n\t            widgetStore_1.default.patch({ id: 'todo-app', todoListState: todoListState });\n\t        });\n\t    }\n\t};\n\texports.todoSave = function (event) {\n\t    var properties = this.properties;\n\t    if (!event.target.value) {\n\t        todoStoreActions_1.deleteTodo(properties);\n\t    }\n\t    else {\n\t        todoStoreActions_1.updateTodo(lang_1.assign({}, properties, { label: event.target.value, editing: false }));\n\t    }\n\t};\n\texports.todoRemove = function () {\n\t    var properties = this.properties;\n\t    todoStoreActions_1.deleteTodo({ id: properties.id });\n\t};\n\texports.todoToggleComplete = function () {\n\t    var properties = this.properties;\n\t    todoStoreActions_1.updateTodo({ id: properties.id, completed: !properties.completed });\n\t};\n\texports.filter = function (_a) {\n\t    var filter = _a.filter;\n\t    var _b = this.state, _c = (_b === void 0 ? {} : _b).activeFilter, activeFilter = _c === void 0 ? filter : _c;\n\t    widgetStore_1.default.patch({ id: 'todo-app', activeFilter: activeFilter });\n\t};\n\texports.todoToggleAll = function (event) {\n\t    todoStoreActions_1.toggleAll({ checked: event.target.checked });\n\t};\n\texports.clearCompleted = function () {\n\t    todoStoreActions_1.deleteCompleted();\n\t};\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createObservableStoreMixin_1 = __webpack_require__(46);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createObservableStoreMixin_1.createObservableStore({\n\t    data: [\n\t        {\n\t            id: 'todo-app',\n\t            todo: '',\n\t            todos: [],\n\t            completedCount: 0,\n\t            activeCount: 0,\n\t            activeFilter: 'all',\n\t            allCompleted: false\n\t        }\n\t    ]\n\t});\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createStore_1 = __webpack_require__(47);\n\tvar Observable_1 = __webpack_require__(48);\n\tvar WeakMap_1 = __webpack_require__(20);\n\tvar Map_1 = __webpack_require__(30);\n\tvar Set_1 = __webpack_require__(57);\n\tvar aspect_1 = __webpack_require__(22);\n\tvar util_1 = __webpack_require__(58);\n\t/**\n\t * Combines several sequential deltas into a single delta.\n\t * It performs several checks to remove redundant data.\n\t * \t- Checks for repeated copies items with the same ID in\n\t * \tadds and updates, or just the same ID in deletes, and keeps\n\t * \tonly the last.\n\t * \t- Checks for deletes followed by adds or updates and replaces with a\n\t * \tsingle update\n\t * \t- Checks for adds followed by deletes and removes both\n\t * \t- Checks for updates followed by deletes and removes the update\n\t * @param instance The instance that can identify these items\n\t * @param currentUpdate The current store delta\n\t * @param newUpdate The new update to merge\n\t * @returns The merged delta\n\t */\n\tfunction mergeDeltas(instance, currentUpdate, newUpdate) {\n\t    /**\n\t     * Takes the last instance of an item repeated in the list\n\t     * @param items Added or updated items\n\t     * @returns The added or updated items with repeated items replaced by only the latest version of the item\n\t     */\n\t    function takeLastItem(items) {\n\t        var found = {};\n\t        var ids = instance.identify(items);\n\t        return items.reverse().filter(function (_, index) {\n\t            var id = ids[index];\n\t            var exists = Boolean(found[id]);\n\t            found[id] = true;\n\t            return !exists;\n\t        }).reverse();\n\t    }\n\t    /**\n\t     * Takes the last instance of an id repeated in the list\n\t     * @param ids IDs of deleted items\n\t     * @returns The list with duplicates removed\n\t     */\n\t    function takeLastId(ids) {\n\t        var found = {};\n\t        return ids.reverse().filter(function (id) {\n\t            var exists = Boolean(found[id]);\n\t            found[id] = true;\n\t            return !exists;\n\t        }).reverse();\n\t    }\n\t    /**\n\t     * Removes updates for items that were later deleted\n\t     * @param newDeletes Deletes from delta(s) after the updates\n\t     * @param oldUpdates Updates from delta(s) before the deletes\n\t     * @return The updates without updates for subsequently deleted items\n\t     */\n\t    function removeOutdatedItems(newDeletes, oldUpdates) {\n\t        var deletedIds = newDeletes.reduce(function (prev, next) {\n\t            prev.set(next, null);\n\t            return prev;\n\t        }, new Map_1.default());\n\t        var ids = instance.identify(oldUpdates);\n\t        return oldUpdates.filter(function (_, index) {\n\t            return !deletedIds.has(ids[index]);\n\t        });\n\t    }\n\t    /**\n\t     * Finds cases where an older update has an add, and a newer update has a delete, and removes\n\t     * both, since the net effect is that the operations are cancelled out\n\t     * @param newDeletes Deletes form delta(s) after the adds\n\t     * @param oldAdds Adds from delta(s) before the deletes\n\t     * @returns An object with the filtered adds and deletes\n\t     */\n\t    function removeCancellingUpdates(newDeletes, oldAdds) {\n\t        var deletedIds = newDeletes.reduce(function (prev, next) {\n\t            prev.set(next, null);\n\t            return prev;\n\t        }, new Map_1.default());\n\t        var ids = instance.identify(oldAdds);\n\t        var addIds = ids.reduce(function (prev, next) {\n\t            prev.set(next, null);\n\t            return prev;\n\t        }, new Map_1.default());\n\t        return {\n\t            oldAdds: oldAdds.filter(function (_, index) {\n\t                return !deletedIds.has(ids[index]);\n\t            }),\n\t            newDeletes: newDeletes.filter(function (id) { return !addIds.has(id); })\n\t        };\n\t    }\n\t    /**\n\t     * Finds places where an item was deleted and then added or updated, and removes the delete. If the item was added,\n\t     * the add is also replaced with an update since it should already exist in the collection receiving the updates,\n\t     * as it will never receive the delete\n\t     * @param oldDeletes - Deletes from delta(s) before the adds and updates\n\t     * @param newAdds - Adds from delta(s) after the deletes\n\t     * @param newUpdates - Updates from delta(s) after the deletes\n\t     * @returns An object containing the updated deletes, adds, and updates\n\t     */\n\t    function convertReplacementToUpdate(oldDeletes, newAdds, newUpdates) {\n\t        var deletes = oldDeletes.reduce(function (prev, next) {\n\t            prev.set(next, null);\n\t            return prev;\n\t        }, new Map_1.default());\n\t        var addIds = instance.identify(newAdds);\n\t        var updateIds = instance.identify(newUpdates);\n\t        var adds = addIds.concat(updateIds).reduce(function (prev, next) {\n\t            prev.set(next, null);\n\t            return prev;\n\t        }, new Map_1.default());\n\t        var updatedUpdates = newUpdates.slice();\n\t        return {\n\t            oldDeletes: oldDeletes.filter(function (id) { return !adds.has(id); }),\n\t            newAdds: newAdds.filter(function (item, index) {\n\t                var shouldKeep = !deletes.has(addIds[index]);\n\t                if (!shouldKeep) {\n\t                    // Always add it to the beginning, because it may have been updated as well, but the add\n\t                    // has to have come first.\n\t                    updatedUpdates.unshift(item);\n\t                }\n\t                return shouldKeep;\n\t            }),\n\t            newUpdates: updatedUpdates\n\t        };\n\t    }\n\t    var _a = convertReplacementToUpdate(currentUpdate.deletes, newUpdate.adds, newUpdate.updates), oldDeletes = _a.oldDeletes, newAdds = _a.newAdds, newUpdates = _a.newUpdates;\n\t    var oldUpdates = removeOutdatedItems(newUpdate.deletes, currentUpdate.updates);\n\t    var _b = removeCancellingUpdates(newUpdate.deletes, currentUpdate.adds), newDeletes = _b.newDeletes, oldAdds = _b.oldAdds;\n\t    return {\n\t        updates: takeLastItem(oldUpdates.concat(newUpdates)),\n\t        adds: takeLastItem(oldAdds.concat(newAdds)),\n\t        deletes: takeLastId(oldDeletes.concat(newDeletes)),\n\t        beforeAll: currentUpdate.beforeAll,\n\t        afterAll: newUpdate.afterAll\n\t    };\n\t}\n\texports.mergeDeltas = mergeDeltas;\n\tvar instanceStateMap = new WeakMap_1.default();\n\t/**\n\t * Takes a collection of items and creates a new copy modified according to the provided updates. This can be used to\n\t * attempt to track updates in the local collection when fetching after each update is disabled.\n\t * @param store\n\t * @param state\n\t * @param data\n\t * @param update\n\t * @returns A new collection with the modifications specified by the update\n\t */\n\tfunction addUpdateDelete(store, state, data, update) {\n\t    var newData = data.slice();\n\t    update.adds.forEach(function (item) {\n\t        newData.push(item);\n\t    });\n\t    store.identify(update.updates).forEach(function (id, index) {\n\t        if (state.localIndex.has(id)) {\n\t            newData[state.localIndex.get(id)] = update.updates[index];\n\t        }\n\t        else {\n\t            newData.push(update.updates[index]);\n\t        }\n\t    });\n\t    update.deletes.sort().reverse().forEach(function (id) {\n\t        if (state.localIndex.has(id)) {\n\t            newData.splice(state.localIndex.get(id), 1);\n\t        }\n\t    });\n\t    return newData;\n\t}\n\t/**\n\t * Build a map of ids to indices for the provided collection. This requires that the array of IDs is either what\n\t * the index if for, or that the array of items the IDs represent is in the same order, which is already the case\n\t * if the IDs were generated using the Store's identify function.\n\t * @param ids - The IDS to build the index for\n\t * @returns An index mapping ids to indices\n\t */\n\tfunction buildIndex(ids) {\n\t    return ids.reduce(function (map, id, index) {\n\t        map.set(id, index);\n\t        return map;\n\t    }, new Map_1.default());\n\t}\n\texports.buildIndex = buildIndex;\n\t/**\n\t * Merges the latest queued updates, updates the local data and index based on the latest data,\n\t * sends out updates to observers, and then removes observers that unsubscribed during the update process from the list\n\t * of observers. If after is provided, it is assumed that that is the latest data for the store, if it is not provided\n\t * the local data is updated according to the merged delta and that is used as the new local data.\n\t * @param store\n\t * @param after - Optional array of items containing the latest data for the store.\n\t */\n\tfunction sendUpdates(store, after) {\n\t    var state = instanceStateMap.get(store);\n\t    var storeDelta = state.queuedUpdate || {\n\t        updates: [],\n\t        adds: [],\n\t        deletes: [],\n\t        beforeAll: [],\n\t        afterAll: []\n\t    };\n\t    state.queuedUpdate = undefined;\n\t    after = after || addUpdateDelete(store, state, state.localData, storeDelta);\n\t    storeDelta.beforeAll = state.localData;\n\t    storeDelta.afterAll = after;\n\t    state.localData = after;\n\t    state.localIndex = buildIndex(store.identify(after));\n\t    state.observers.forEach(function (observer) {\n\t        observer.next({\n\t            updates: storeDelta.updates.slice(),\n\t            adds: storeDelta.adds.slice(),\n\t            deletes: storeDelta.deletes.slice(),\n\t            beforeAll: storeDelta.beforeAll.slice(),\n\t            afterAll: storeDelta.afterAll.slice()\n\t        });\n\t    });\n\t}\n\t/**\n\t * Determines whether this is a single observer or a set entry\n\t * @param observer\n\t * @returns {boolean}\n\t */\n\tfunction isObserverEntry(observer) {\n\t    return observer.observes instanceof Set_1.default;\n\t}\n\t/**\n\t * Determines whether this is a single observer or a set entry\n\t * @param observer\n\t * @returns {boolean}\n\t */\n\tfunction isObserver(observer) {\n\t    return !isObserverEntry(observer);\n\t}\n\t/**\n\t * Iterates through the provided items and/or IDs and notifies observers. If items is provided, then the\n\t * observers for that item, and the observers for sets of items that include that are updated. If items is null, then\n\t * these are delete notifications for observers of multiple items. In this case, no update is sent to individual\n\t * observers, and observers of sets receive `ItemUpdate` objects with the IDs of the deleted items and an undefined item\n\t *\n\t * @param items Items to send updates for, or null if these are delete notifications for item set observers\n\t * @param ids - IDs of the items, should be in the same order as items\n\t * @param state\n\t * @param store\n\t */\n\tfunction notifyItemObservers(items, ids, state, store) {\n\t    function notify(id, after) {\n\t        if (state.itemObservers.has(id)) {\n\t            state.itemObservers.get(id).map(function (observerOrEntry) {\n\t                if (isObserverEntry(observerOrEntry)) {\n\t                    return observerOrEntry.observer;\n\t                }\n\t                else {\n\t                    return null;\n\t                }\n\t            }).filter(function (observerEntry) {\n\t                return observerEntry;\n\t            }).forEach(function (observer) {\n\t                observer.next({\n\t                    item: after,\n\t                    id: id\n\t                });\n\t            });\n\t            if (after) {\n\t                state.itemObservers.get(id).map(function (observerOrEntry) {\n\t                    if (isObserver(observerOrEntry)) {\n\t                        return observerOrEntry;\n\t                    }\n\t                    else {\n\t                        return null;\n\t                    }\n\t                }).filter(function (observer) {\n\t                    return observer;\n\t                }).forEach(function (observer) {\n\t                    observer.next(after);\n\t                });\n\t            }\n\t        }\n\t    }\n\t    if (items) {\n\t        items.forEach(function (after, index) {\n\t            var id = ids[index] || store.identify(after);\n\t            notify(id, after);\n\t        });\n\t    }\n\t    else {\n\t        ids.forEach(function (id) {\n\t            notify(id, undefined);\n\t        });\n\t    }\n\t}\n\t/**\n\t * Queues the appropriate update and then either starts up a fetch or just triggers sending the updates depending\n\t * on the `fetchAroundUpdates` property\n\t * @param state\n\t * @param store\n\t * @param updates Updated items\n\t * @param adds Added items\n\t * @param deletes Deleted IDs\n\t */\n\tfunction sendUpdatesOrFetch(state, store, updates, adds, deletes) {\n\t    var newUpdate = {\n\t        updates: updates,\n\t        adds: adds,\n\t        deletes: deletes,\n\t        beforeAll: [],\n\t        afterAll: []\n\t    };\n\t    state.queuedUpdate = state.queuedUpdate ? mergeDeltas(store, state.queuedUpdate, newUpdate) : newUpdate;\n\t    if (state.fetchAroundUpdates) {\n\t        state.fetchAndSendUpdates(store);\n\t    }\n\t    else {\n\t        sendUpdates(store);\n\t    }\n\t}\n\tfunction createObservableStoreMixin() {\n\t    return {\n\t        mixin: {\n\t            observe: function (idOrIds) {\n\t                if (idOrIds) {\n\t                    var self_1 = this;\n\t                    var state_1 = instanceStateMap.get(self_1);\n\t                    if (Array.isArray(idOrIds)) {\n\t                        var ids_1 = idOrIds;\n\t                        var idSet_1 = new Set_1.default(ids_1);\n\t                        var observable = new Observable_1.Observable(function subscribe(observer) {\n\t                            var observerEntry = {\n\t                                observes: idSet_1,\n\t                                observer: observer\n\t                            };\n\t                            ids_1.forEach(function (id) {\n\t                                if (state_1.itemObservers.has(id)) {\n\t                                    state_1.itemObservers.get(id).push(observerEntry);\n\t                                }\n\t                                else {\n\t                                    state_1.itemObservers.set(id, [observerEntry]);\n\t                                }\n\t                            });\n\t                            var foundIds = new Set_1.default();\n\t                            observer.next = aspect_1.after(observer.next, function (result, itemUpdate) {\n\t                                foundIds.add(itemUpdate.id);\n\t                                return result;\n\t                            });\n\t                            self_1.get(ids_1).then(function (items) {\n\t                                if (foundIds.size !== ids_1.length) {\n\t                                    var retrievedIdSet_1 = new Set_1.default(self_1.identify(items));\n\t                                    var missingItemIds = ids_1.filter(function (id) { return !retrievedIdSet_1.has(id); });\n\t                                    if (retrievedIdSet_1.size !== idSet_1.size || missingItemIds.length) {\n\t                                        observer.error(new Error(\"ID(s) \\\"\" + missingItemIds + \"\\\" not found in store\"));\n\t                                    }\n\t                                    else {\n\t                                        items.forEach(function (item, index) { return observer.next({\n\t                                            item: item,\n\t                                            id: ids_1[index]\n\t                                        }); });\n\t                                    }\n\t                                }\n\t                            });\n\t                        });\n\t                        return observable;\n\t                    }\n\t                    else {\n\t                        var id_1 = idOrIds;\n\t                        return new Observable_1.Observable(function subscribe(observer) {\n\t                            self_1.get(id_1).then(function (item) {\n\t                                if (!item) {\n\t                                    observer.error(new Error(\"ID \\\"\" + id_1 + \"\\\" not found in store\"));\n\t                                }\n\t                                else {\n\t                                    if (state_1.itemObservers.has(id_1)) {\n\t                                        state_1.itemObservers.get(id_1).push(observer);\n\t                                    }\n\t                                    else {\n\t                                        state_1.itemObservers.set(id_1, [observer]);\n\t                                    }\n\t                                    observer.next(item);\n\t                                }\n\t                            });\n\t                        });\n\t                    }\n\t                }\n\t                else {\n\t                    return instanceStateMap.get(this).storeObservable;\n\t                }\n\t            }\n\t        },\n\t        aspectAdvice: {\n\t            after: {\n\t                /**\n\t                 * After fetching, sends updates if no query was used. If a custom query was used then the data retrieved\n\t                 * is not indicative of the local data and can't be used. We shouldn't apply the query locally because we\n\t                 * have no knowledge of the underlying storage implementation or the amount of data and it may be too much\n\t                 * data to retrieve or update in memory. If this is the initialFetch, don't update since that update\n\t                 * will be sent to each subscriber at the time of subscription. If we're not sending updates, still set\n\t                 * the local data and index to the newly retrieved data.\n\t                 * @param result\n\t                 * @param query\n\t                 * @returns {Promise<T[]>}\n\t                 */\n\t                fetch: function (result, query) {\n\t                    var _this = this;\n\t                    if (!query) {\n\t                        result.then(function (data) {\n\t                            var state = instanceStateMap.get(_this);\n\t                            if (result !== state.initialFetch) {\n\t                                sendUpdates(_this, data);\n\t                            }\n\t                            else {\n\t                                state.localData = data;\n\t                                state.localIndex = buildIndex(_this.identify(data));\n\t                            }\n\t                        }, \n\t                        // Ignore errors here, they should be handled by the caller not observers\n\t                        function () { });\n\t                    }\n\t                    return result;\n\t                },\n\t                /**\n\t                 * After the put is completed, notify the item observers, and then either queue a fetch to send updates\n\t                 * if fetchAroundUpdates is true, or just send updates if not.\n\t                 * @param result\n\t                 * @returns {StoreObservable<T, any>}\n\t                 */\n\t                put: function (result) {\n\t                    var _this = this;\n\t                    result.then(function (updatedItems) {\n\t                        var state = instanceStateMap.get(_this);\n\t                        notifyItemObservers(updatedItems, [], state, _this);\n\t                        sendUpdatesOrFetch(state, _this, updatedItems, [], []);\n\t                    }, \n\t                    // Ignore errors here, they should be handled by the caller not observers\n\t                    function () { });\n\t                    return result;\n\t                },\n\t                /**\n\t                 * After the patch is completed, notify the item observers, and then either queue a fetch to send updates\n\t                 * if fetchAroundUpdates is true, or just send updates if not.\n\t                 * @param result\n\t                 * @returns {StoreObservable<T, any>}\n\t                 */\n\t                patch: function (result) {\n\t                    var _this = this;\n\t                    result.then(function (updatedItems) {\n\t                        var state = instanceStateMap.get(_this);\n\t                        notifyItemObservers(updatedItems, [], state, _this);\n\t                        sendUpdatesOrFetch(state, _this, updatedItems, [], []);\n\t                    }, \n\t                    // Ignore errors here, they should be handled by the caller not observers\n\t                    function () { });\n\t                    return result;\n\t                },\n\t                /**\n\t                 * After the add is completed notify observers. If this is the initial add AND we are fetching around\n\t                 * updates, then the first update to subscribers will already contain this data, since the initial fetch\n\t                 * is performed after the initial add. In this case we do not need to send an update. We can tell this\n\t                 * is the first add because it'll be triggered in the createStore base before the state is created for\n\t                 * this instance in the mixin's initializer\n\t                 * @param result\n\t                 * @returns {StoreObservable<T, U>}\n\t                 */\n\t                add: function (result) {\n\t                    var _this = this;\n\t                    var isFirstAdd = !instanceStateMap.get(this);\n\t                    result.then(function (addedItems) {\n\t                        var state = instanceStateMap.get(_this);\n\t                        if (!isFirstAdd || !state.fetchAroundUpdates) {\n\t                            sendUpdatesOrFetch(state, _this, [], addedItems, []);\n\t                        }\n\t                    }, \n\t                    // Ignore errors here, they should be handled by the caller not observers\n\t                    function () { });\n\t                    return result;\n\t                },\n\t                /**\n\t                 * After the items are deleted, notify item set observers of the deletion of one of the items they are\n\t                 * observing, and then complete any observables that need to be completed.\n\t                 * Completing observables is dones as follows\n\t                 * \t- For observers of a single item, just complete the observer\n\t                 * \t- For observers of a set of items\n\t                 * \t\t- Remove the deleted ID of this item from the set of observed IDs\n\t                 * \t\t- If there are now no observed IDs for the set, complete the observable\n\t                 * \t- Remove the item observer entry for the deleted ID\n\t                 * @param result\n\t                 * @param ids\n\t                 * @returns {StoreObservable<string, any>}\n\t                 */\n\t                delete: function (result, ids) {\n\t                    var _this = this;\n\t                    result.then(function (deleted) {\n\t                        var state = instanceStateMap.get(_this);\n\t                        notifyItemObservers(null, deleted, state, _this);\n\t                        deleted.forEach(function (id) {\n\t                            if (state.itemObservers.has(id)) {\n\t                                state.itemObservers.get(id).forEach(function (observerOrEntry) {\n\t                                    if (isObserver(observerOrEntry)) {\n\t                                        observerOrEntry.complete();\n\t                                    }\n\t                                    else {\n\t                                        observerOrEntry.observes.delete(id);\n\t                                        if (!observerOrEntry.observes.size) {\n\t                                            observerOrEntry.observer.complete();\n\t                                        }\n\t                                    }\n\t                                });\n\t                                state.itemObservers.delete(id);\n\t                            }\n\t                        });\n\t                        sendUpdatesOrFetch(state, _this, [], [], deleted);\n\t                    }, \n\t                    // Ignore errors here, they should be handled by the caller not observers\n\t                    function () { });\n\t                    return result;\n\t                }\n\t            }\n\t        },\n\t        initialize: function (instance, options) {\n\t            options = options || {};\n\t            var itemObservers = new Map_1.default();\n\t            var storeObservable = new Observable_1.Observable(function (observer) {\n\t                var state = instanceStateMap.get(this);\n\t                state.observers.push(observer);\n\t                if (state.initialFetch) {\n\t                    state.initialFetch.then(function () {\n\t                        observer.next({\n\t                            updates: [],\n\t                            deletes: [],\n\t                            adds: [],\n\t                            beforeAll: [],\n\t                            afterAll: state.localData.slice()\n\t                        });\n\t                    });\n\t                }\n\t                else {\n\t                    observer.next({\n\t                        updates: [],\n\t                        deletes: [],\n\t                        adds: [],\n\t                        beforeAll: [],\n\t                        afterAll: state.localData.slice()\n\t                    });\n\t                }\n\t                return function () {\n\t                    function remove(observer) {\n\t                        state.observers.splice(state.observers.indexOf(observer), 1);\n\t                    }\n\t                    setTimeout(function () {\n\t                        remove(observer);\n\t                    });\n\t                };\n\t            }.bind(instance));\n\t            var state = {\n\t                fetchAroundUpdates: Boolean(options.fetchAroundUpdates),\n\t                fetchAndSendUpdates: util_1.debounce(function (store) {\n\t                    store.fetch();\n\t                }, options.fetchAroundUpdateDebounce || 20),\n\t                itemObservers: itemObservers,\n\t                observers: [],\n\t                storeObservable: storeObservable,\n\t                localData: [],\n\t                localIndex: new Map_1.default()\n\t            };\n\t            if (options.fetchAroundUpdates) {\n\t                state.initialFetch = instance.fetch();\n\t            }\n\t            instanceStateMap.set(instance, state);\n\t        }\n\t    };\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createObservableStoreMixin;\n\texports.createObservableStore = createStore_1.default\n\t    .mixin(createObservableStoreMixin());\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Promise_1 = __webpack_require__(23);\n\tvar WeakMap_1 = __webpack_require__(20);\n\tvar Map_1 = __webpack_require__(30);\n\tvar lang_1 = __webpack_require__(13);\n\tvar compose_1 = __webpack_require__(6);\n\tvar Observable_1 = __webpack_require__(48);\n\tvar createPatch_1 = __webpack_require__(50);\n\tvar createStoreObservable_1 = __webpack_require__(54);\n\tvar createInMemoryStorage_1 = __webpack_require__(55);\n\tvar instanceStateMap = new WeakMap_1.default();\n\tfunction isPatchArray(patches) {\n\t    return isPatch(patches[0]);\n\t}\n\tfunction isPatch(patchObj) {\n\t    var patch = patchObj && patchObj.patch;\n\t    var id = patchObj && patchObj.id;\n\t    return typeof id === 'string' && patch && Array.isArray(patch.operations) && typeof patch.apply === 'function' &&\n\t        typeof patch.toString === 'function';\n\t}\n\tfunction createStoreObservable(storeResultsPromise) {\n\t    return createStoreObservable_1.default(new Observable_1.Observable(function subscribe(observer) {\n\t        storeResultsPromise\n\t            .then(function (results) {\n\t            observer.next(results);\n\t            observer.complete();\n\t        }, function (error) {\n\t            observer.error(error);\n\t        });\n\t    }), function (results) {\n\t        return results.successfulData;\n\t    });\n\t}\n\tvar createStore = compose_1.default({\n\t    get: function (ids) {\n\t        var state = instanceStateMap.get(this);\n\t        return state.initialAddPromise.then(function () {\n\t            if (Array.isArray(ids)) {\n\t                return state.storage.get(ids).then(function (items) { return items.filter(function (item) { return Boolean(item); }); });\n\t            }\n\t            else {\n\t                return state.storage.get([ids]).then(function (items) { return items[0]; });\n\t            }\n\t        });\n\t    },\n\t    add: function (items, options) {\n\t        var self = this;\n\t        var state = instanceStateMap.get(self);\n\t        var storeResultsPromise = state.initialAddPromise.then(function () {\n\t            return state.storage.add(Array.isArray(items) ? items : [items], options);\n\t        });\n\t        return createStoreObservable(storeResultsPromise);\n\t    },\n\t    put: function (items, options) {\n\t        var self = this;\n\t        var state = instanceStateMap.get(self);\n\t        var storeResultsPromise = state.initialAddPromise.then(function () {\n\t            return state.storage.put(Array.isArray(items) ? items : [items], options);\n\t        });\n\t        return createStoreObservable(storeResultsPromise);\n\t    },\n\t    patch: function (updates, options) {\n\t        var self = this;\n\t        var state = instanceStateMap.get(self);\n\t        var patchEntries = [];\n\t        if (Array.isArray(updates)) {\n\t            if (isPatchArray(updates)) {\n\t                patchEntries = updates;\n\t            }\n\t            else {\n\t                patchEntries = self.identify(updates).map(function (id, index) {\n\t                    return { id: id, patch: createPatch_1.diff(updates[index]) };\n\t                });\n\t            }\n\t        }\n\t        else if (updates instanceof Map_1.default) {\n\t            updates.forEach(function (value, key) {\n\t                patchEntries.push({\n\t                    id: key,\n\t                    patch: value\n\t                });\n\t            });\n\t        }\n\t        else if (isPatch(updates)) {\n\t            patchEntries = [updates];\n\t        }\n\t        else {\n\t            var dupe = lang_1.duplicate(updates);\n\t            var idInOptions = (options && options.id);\n\t            var id = idInOptions || dupe.id;\n\t            if (!idInOptions) {\n\t                delete dupe.id;\n\t            }\n\t            patchEntries = [{ id: id, patch: createPatch_1.diff(dupe) }];\n\t        }\n\t        var storeResultsPromise = state.initialAddPromise.then(function () {\n\t            return state.storage.patch(patchEntries);\n\t        });\n\t        return createStoreObservable(storeResultsPromise);\n\t    },\n\t    delete: function (ids) {\n\t        var self = this;\n\t        var state = instanceStateMap.get(self);\n\t        var storeResultsPromise = state.initialAddPromise.then(function () {\n\t            return state.storage.delete(Array.isArray(ids) ? ids : [ids]);\n\t        });\n\t        return createStoreObservable(storeResultsPromise);\n\t    },\n\t    fetch: function (query) {\n\t        var state = instanceStateMap.get(this);\n\t        var resolveTotalLength;\n\t        var rejectTotalLength;\n\t        var totalLength = new Promise_1.default(function (resolve, reject) {\n\t            resolveTotalLength = resolve;\n\t            rejectTotalLength = reject;\n\t        });\n\t        var fetchResult = state.initialAddPromise.then(function () {\n\t            var result = state.storage.fetch(query);\n\t            result.totalLength.then(resolveTotalLength, rejectTotalLength);\n\t            return result;\n\t        });\n\t        fetchResult.totalLength = fetchResult.dataLength = totalLength;\n\t        return fetchResult;\n\t    },\n\t    identify: function (items) {\n\t        var storage = instanceStateMap.get(this).storage;\n\t        if (Array.isArray(items)) {\n\t            return storage.identify(items);\n\t        }\n\t        else {\n\t            return storage.identify([items])[0];\n\t        }\n\t    },\n\t    createId: function () {\n\t        return instanceStateMap.get(this).storage.createId();\n\t    }\n\t}, function (instance, options) {\n\t    options = options || {};\n\t    var data = options.data;\n\t    options.data = undefined;\n\t    var instanceState = {\n\t        storage: options.storage || createInMemoryStorage_1.default(options),\n\t        initialAddPromise: Promise_1.default.resolve()\n\t    };\n\t    instanceStateMap.set(instance, instanceState);\n\t    if (data) {\n\t        instanceState.initialAddPromise = instance.add(data).catch(function (error) {\n\t            console.error(error);\n\t        });\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createStore;\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(49);\n\tvar Promise_1 = __webpack_require__(23);\n\tfunction isSubscribable(object) {\n\t    return object && object.subscribe !== undefined;\n\t}\n\tvar Observable = (function (_super) {\n\t    __extends(Observable, _super);\n\t    function Observable() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    Observable.of = function () {\n\t        var items = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            items[_i] = arguments[_i];\n\t        }\n\t        return _super.of.apply(this, items);\n\t    };\n\t    Observable.from = function (item) {\n\t        return _super.from.call(this, item);\n\t    };\n\t    Observable.defer = function (deferFunction) {\n\t        return new Observable(function (observer) {\n\t            var trueObservable = deferFunction();\n\t            return trueObservable.subscribe({\n\t                next: function (value) {\n\t                    return observer.next(value);\n\t                },\n\t                error: function (errorValue) {\n\t                    return observer.error(errorValue);\n\t                },\n\t                complete: function (completeValue) {\n\t                    observer.complete(completeValue);\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Observable.prototype.toPromise = function () {\n\t        var _this = this;\n\t        return new Promise_1.default(function (resolve, reject) {\n\t            _this.subscribe({\n\t                next: function (value) {\n\t                    resolve(value);\n\t                },\n\t                error: function (error) {\n\t                    reject(error);\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Observable.prototype.map = function (mapFunction) {\n\t        var self = this;\n\t        if (typeof mapFunction !== 'function') {\n\t            throw new TypeError('Map parameter must be a function');\n\t        }\n\t        return new Observable(function (observer) {\n\t            self.subscribe({\n\t                next: function (value) {\n\t                    try {\n\t                        var result = mapFunction(value);\n\t                        return observer.next(result);\n\t                    }\n\t                    catch (e) {\n\t                        return observer.error(e);\n\t                    }\n\t                },\n\t                error: function (errorValue) {\n\t                    return observer.error(errorValue);\n\t                },\n\t                complete: function (completeValue) {\n\t                    return observer.complete(completeValue);\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Observable.prototype.filter = function (filterFunction) {\n\t        var self = this;\n\t        if (typeof filterFunction !== 'function') {\n\t            throw new TypeError('Filter argument must be a function');\n\t        }\n\t        return new Observable(function (observer) {\n\t            self.subscribe({\n\t                next: function (value) {\n\t                    try {\n\t                        if (filterFunction(value)) {\n\t                            return observer.next(value);\n\t                        }\n\t                    }\n\t                    catch (e) {\n\t                        return observer.error(e);\n\t                    }\n\t                },\n\t                error: function (errorValue) {\n\t                    return observer.error(errorValue);\n\t                },\n\t                complete: function (completeValue) {\n\t                    return observer.complete(completeValue);\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Observable.prototype.toArray = function () {\n\t        var self = this;\n\t        return new Observable(function (observer) {\n\t            var values = [];\n\t            self.subscribe({\n\t                next: function (value) {\n\t                    values.push(value);\n\t                },\n\t                error: function (errorValue) {\n\t                    return observer.error(errorValue);\n\t                },\n\t                complete: function (completeValue) {\n\t                    observer.next(values);\n\t                    observer.complete(completeValue);\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Observable.prototype.mergeAll = function (concurrent) {\n\t        var self = this;\n\t        return new Observable(function (observer) {\n\t            var active = [];\n\t            var queue = [];\n\t            function checkForComplete() {\n\t                if (active.length === 0 && queue.length === 0) {\n\t                    observer.complete();\n\t                }\n\t                else if (queue.length > 0 && active.length < concurrent) {\n\t                    var item = queue.shift();\n\t                    if (isSubscribable(item)) {\n\t                        var itemIndex_1 = active.length;\n\t                        active.push(item);\n\t                        item.subscribe({\n\t                            next: function (value) {\n\t                                observer.next(value);\n\t                            },\n\t                            complete: function () {\n\t                                active.splice(itemIndex_1, 1);\n\t                                checkForComplete();\n\t                            }\n\t                        });\n\t                    }\n\t                    else {\n\t                        observer.next(item);\n\t                        checkForComplete();\n\t                    }\n\t                }\n\t            }\n\t            self.subscribe({\n\t                next: function (value) {\n\t                    queue.push(value);\n\t                },\n\t                complete: function () {\n\t                    checkForComplete();\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return Observable;\n\t}(Observable_1.default));\n\texports.Observable = Observable;\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Observable;\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar iterator_1 = __webpack_require__(16);\n\tvar decorators_1 = __webpack_require__(21);\n\tvar global_1 = __webpack_require__(10);\n\t__webpack_require__(18);\n\tvar Shim;\n\t(function (Shim) {\n\t    /*\n\t     * Decorator to mark a single method/property as non-enumerable. ES spec requires pretty much every\n\t     * method or property in Subscription, Observable, and SubscriptionObserver to be non-enumerable.\n\t     */\n\t    function nonEnumerable(target, key, descriptor) {\n\t        descriptor.enumerable = false;\n\t    }\n\t    /*\n\t     * Create a subscription observer for a given observer, and return the subscription.  The \"logic\" for Observerables\n\t     * is in here!\n\t     */\n\t    function startSubscription(executor, observer) {\n\t        var closed = false;\n\t        var cleanUp;\n\t        function unsubscribe() {\n\t            if (!closed) {\n\t                closed = true;\n\t                if (cleanUp) {\n\t                    cleanUp();\n\t                }\n\t            }\n\t        }\n\t        function start(subscriptionObserver) {\n\t            if (observer.start) {\n\t                observer.start(subscription);\n\t            }\n\t            if (closed) {\n\t                return;\n\t            }\n\t            try {\n\t                var result = executor(subscriptionObserver);\n\t                if (typeof result === 'function') {\n\t                    cleanUp = result;\n\t                }\n\t                else if (result && 'unsubscribe' in result) {\n\t                    cleanUp = result.unsubscribe;\n\t                }\n\t                else if (result !== undefined && result !== null) {\n\t                    throw new TypeError('Subscriber must return a callable or subscription');\n\t                }\n\t                if (closed) {\n\t                    if (cleanUp) {\n\t                        cleanUp();\n\t                    }\n\t                }\n\t            }\n\t            catch (e) {\n\t                error(e);\n\t            }\n\t        }\n\t        function next(value) {\n\t            if (closed) {\n\t                return;\n\t            }\n\t            var next = observer.next;\n\t            try {\n\t                if (typeof next === 'function') {\n\t                    return next(value);\n\t                }\n\t                else if (next !== undefined && next !== null) {\n\t                    throw new TypeError('Observer.next is not a function');\n\t                }\n\t            }\n\t            catch (e) {\n\t                error(e);\n\t            }\n\t        }\n\t        function error(errorValue) {\n\t            if (!closed) {\n\t                var cleanUpError = undefined;\n\t                try {\n\t                    unsubscribe();\n\t                }\n\t                catch (e) {\n\t                    cleanUpError = e;\n\t                }\n\t                var observerError = observer.error;\n\t                if (observerError !== undefined && observerError !== null) {\n\t                    if (typeof observerError === 'function') {\n\t                        var errorResult = observerError(errorValue);\n\t                        if (cleanUpError !== undefined) {\n\t                            throw cleanUpError;\n\t                        }\n\t                        return errorResult;\n\t                    }\n\t                    else {\n\t                        throw new TypeError('Observer.error is not a function');\n\t                    }\n\t                }\n\t                else if (observer.complete) {\n\t                    return observer.complete(errorValue);\n\t                }\n\t                else {\n\t                    throw errorValue;\n\t                }\n\t            }\n\t            else {\n\t                throw errorValue;\n\t            }\n\t        }\n\t        function complete(completeValue) {\n\t            if (!closed) {\n\t                var cleanUpError = undefined;\n\t                try {\n\t                    unsubscribe();\n\t                }\n\t                catch (e) {\n\t                    cleanUpError = e;\n\t                }\n\t                var observerComplete = observer.complete;\n\t                if (observerComplete !== undefined && observerComplete !== null) {\n\t                    if (typeof observerComplete === 'function') {\n\t                        var completeResult = observerComplete(completeValue);\n\t                        if (cleanUpError !== undefined) {\n\t                            throw cleanUpError;\n\t                        }\n\t                        return completeResult;\n\t                    }\n\t                    else {\n\t                        throw new TypeError('Observer.complete is not a function');\n\t                    }\n\t                }\n\t                else if (cleanUpError) {\n\t                    throw cleanUpError;\n\t                }\n\t            }\n\t        }\n\t        var subscription = Object.create(Object.create({}, {\n\t            'closed': {\n\t                enumerable: false,\n\t                configurable: true,\n\t                get: function () {\n\t                    return closed;\n\t                }\n\t            },\n\t            'unsubscribe': {\n\t                enumerable: false,\n\t                configurable: true,\n\t                writable: true,\n\t                value: unsubscribe\n\t            }\n\t        }));\n\t        var prototype = Object.create({}, {\n\t            'next': {\n\t                enumerable: false,\n\t                writable: true,\n\t                value: next,\n\t                configurable: true\n\t            },\n\t            'error': {\n\t                enumerable: false,\n\t                writable: true,\n\t                value: error,\n\t                configurable: true\n\t            },\n\t            'complete': {\n\t                enumerable: false,\n\t                writable: true,\n\t                value: complete,\n\t                configurable: true\n\t            },\n\t            'closed': {\n\t                enumerable: false,\n\t                configurable: true,\n\t                get: function () {\n\t                    return closed;\n\t                }\n\t            }\n\t        });\n\t        // create the SubscriptionObserver and kick things off\n\t        start(Object.create(prototype));\n\t        // the ONLY way to control the SubscriptionObserver is with the subscription or from a subscriber\n\t        return subscription;\n\t    }\n\t    var ShimObservable = (function () {\n\t        function ShimObservable(subscriber) {\n\t            if (typeof subscriber !== 'function') {\n\t                throw new TypeError('subscriber is not a function');\n\t            }\n\t            this._executor = subscriber;\n\t        }\n\t        ShimObservable.prototype[_a = Symbol.observable] = function () {\n\t            return this;\n\t        };\n\t        ShimObservable.prototype.subscribe = function (observerOrNext) {\n\t            var listeners = [];\n\t            for (var _i = 1; _i < arguments.length; _i++) {\n\t                listeners[_i - 1] = arguments[_i];\n\t            }\n\t            var _a = listeners.slice(), onError = _a[0], onComplete = _a[1];\n\t            if (!observerOrNext || typeof observerOrNext === 'number' || typeof observerOrNext === 'string' || typeof observerOrNext === 'boolean') {\n\t                throw new TypeError('parameter must be a function or an observer');\n\t            }\n\t            var observer;\n\t            if (typeof observerOrNext === 'function') {\n\t                observer = {\n\t                    next: observerOrNext\n\t                };\n\t                if (typeof onError === 'function') {\n\t                    observer.error = onError;\n\t                }\n\t                if (typeof onComplete === 'function') {\n\t                    observer.complete = onComplete;\n\t                }\n\t            }\n\t            else {\n\t                observer = observerOrNext;\n\t            }\n\t            return startSubscription(this._executor, observer);\n\t        };\n\t        ShimObservable.of = function () {\n\t            var items = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                items[_i] = arguments[_i];\n\t            }\n\t            var constructor;\n\t            if (typeof this !== 'function') {\n\t                constructor = ShimObservable;\n\t            }\n\t            else {\n\t                constructor = this;\n\t            }\n\t            return new constructor(function (observer) {\n\t                iterator_1.forOf(items, function (o) {\n\t                    observer.next(o);\n\t                });\n\t                observer.complete();\n\t            });\n\t        };\n\t        ShimObservable.from = function (item) {\n\t            if (item === null || item === undefined) {\n\t                throw new TypeError('item cannot be null or undefined');\n\t            }\n\t            var constructor;\n\t            if (typeof this !== 'function') {\n\t                constructor = ShimObservable;\n\t            }\n\t            else {\n\t                constructor = this;\n\t            }\n\t            var observableSymbol = item[Symbol.observable];\n\t            if (observableSymbol !== undefined) {\n\t                if (typeof observableSymbol !== 'function') {\n\t                    throw new TypeError('Symbol.observable must be a function');\n\t                }\n\t                var result = observableSymbol.call(item);\n\t                if (result === undefined || result === null || typeof result === 'number' || typeof result === 'boolean' || typeof result === 'string') {\n\t                    throw new TypeError('Return value of Symbol.observable must be object');\n\t                }\n\t                if (result.constructor && result.constructor === this || result instanceof ShimObservable) {\n\t                    return result;\n\t                }\n\t                else if (result.subscribe) {\n\t                    return new constructor(result.subscribe);\n\t                }\n\t                else {\n\t                    if (constructor.of) {\n\t                        return constructor.of(result);\n\t                    }\n\t                    else {\n\t                        return ShimObservable.of(result);\n\t                    }\n\t                }\n\t            }\n\t            else if (iterator_1.isIterable(item) || iterator_1.isArrayLike(item)) {\n\t                return new constructor(function (observer) {\n\t                    iterator_1.forOf(item, function (o) {\n\t                        observer.next(o);\n\t                    });\n\t                    observer.complete();\n\t                });\n\t            }\n\t            else {\n\t                throw new TypeError('Parameter is neither Observable nor Iterable');\n\t            }\n\t        };\n\t        return ShimObservable;\n\t    }());\n\t    __decorate([\n\t        nonEnumerable\n\t    ], ShimObservable.prototype, _a, null);\n\t    __decorate([\n\t        nonEnumerable\n\t    ], ShimObservable.prototype, \"subscribe\", null);\n\t    __decorate([\n\t        nonEnumerable\n\t    ], ShimObservable, \"of\", null);\n\t    __decorate([\n\t        nonEnumerable\n\t    ], ShimObservable, \"from\", null);\n\t    Shim.ShimObservable = ShimObservable;\n\t    var _a;\n\t})(Shim || (Shim = {}));\n\tvar Observable = (function () {\n\t    /* istanbul ignore next */\n\t    /**\n\t     * Create a new observerable with a subscriber function. The subscriber function will get called with a\n\t     * SubscriptionObserver parameter for controlling the subscription.  I a function is returned, it will be\n\t     * run when the subscription is complete.\n\t     *\n\t     * @param {Subscriber<T>} subscriber    The subscription function to be called when observers are subscribed\n\t     *\n\t     * @example\n\t     * const source = new Observer<number>((observer) => {\n\t     *     observer.next(1);\n\t     *     observer.next(2);\n\t     *     observer.next(3);\n\t     * });\n\t     */\n\t    function Observable(subscriber) {\n\t    }\n\t    /* istanbul ignore next */\n\t    Observable.prototype.subscribe = function (observerOrNext, onError, onComplete) {\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    /**\n\t     * Create an Observable from a list of values.\n\t     *\n\t     * @param {...T} items The values to be emitted\n\t     *\n\t     * @return {Observable<T>}    An Observable that will emit the specified values\n\t     *\n\t     * @example\n\t     *\n\t     * let source = Observable.of(1, 2, 3);\n\t     *\n\t     * // will emit three separate values, 1, 2, and 3.\n\t     */\n\t    Observable.of = function () {\n\t        var items = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            items[_i] = arguments[_i];\n\t        }\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    /**\n\t     * Create an Observable from another object. If the object is in itself Observable, the object will be returned.\n\t     * Otherwise, the value will be wrapped in an Observable. If the object is iterable, an Observable will be created\n\t     * that emits each item of the iterable.\n\t     *\n\t     * @param {Iterable<T> | ArrayLike<T> | ObservableObject} item The item to be turned into an Observable\n\t     *\n\t     * @return {Observable<T>}    An observable for the item you passed in\n\t     */\n\t    Observable.from = function (item) {\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    Observable.prototype[Symbol.observable] = function () {\n\t        throw new Error();\n\t    };\n\t    return Observable;\n\t}());\n\tObservable = __decorate([\n\t    decorators_1.hasClass('es-observable', global_1.default.Observable, Shim.ShimObservable)\n\t], Observable);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Observable;\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar utils_1 = __webpack_require__(51);\n\tvar createOperation_1 = __webpack_require__(52);\n\tvar createJsonPointer_1 = __webpack_require__(53);\n\tfunction _diff(to, from, startingPath) {\n\t    if (!utils_1.shouldRecurseInto(from) || !utils_1.shouldRecurseInto(to)) {\n\t        return [];\n\t    }\n\t    var path = startingPath || createJsonPointer_1.default();\n\t    var fromKeys = Object.keys(from);\n\t    var toKeys = Object.keys(to);\n\t    var operations = [];\n\t    fromKeys.forEach(function (key) {\n\t        if (!utils_1.isEqual(from[key], to[key])) {\n\t            if ((key in from) && !(key in to)) {\n\t                operations.push(createOperation_1.default(1 /* Remove */, path.push(key)));\n\t            }\n\t            else if (utils_1.shouldRecurseInto(from[key]) && utils_1.shouldRecurseInto(to[key])) {\n\t                operations.push.apply(operations, _diff(to[key], from[key], path.push(key)));\n\t            }\n\t            else {\n\t                operations.push(createOperation_1.default(2 /* Replace */, path.push(key), to[key], undefined, from[key]));\n\t            }\n\t        }\n\t    });\n\t    toKeys.forEach(function (key) {\n\t        if (!(key in from) && (key in to)) {\n\t            operations.push(createOperation_1.default(0 /* Add */, path.push(key), to[key]));\n\t        }\n\t    });\n\t    return operations;\n\t}\n\tfunction diff(to, from) {\n\t    if (from === void 0) { from = {}; }\n\t    return createPatch(_diff(to, from));\n\t}\n\texports.diff = diff;\n\tfunction createPatch(operations) {\n\t    return {\n\t        operations: operations,\n\t        apply: function (target) {\n\t            return this.operations.reduce(function (prev, next) { return next.apply(prev); }, target);\n\t        },\n\t        toString: function () {\n\t            return '[' + this.operations.reduce(function (prev, next) {\n\t                if (prev) {\n\t                    return prev + ',' + next.toString();\n\t                }\n\t                else {\n\t                    return next.toString();\n\t                }\n\t            }, '') + ']';\n\t        }\n\t    };\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createPatch;\n\n/***/ },\n/* 51 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction shouldRecurseInto(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\texports.shouldRecurseInto = shouldRecurseInto;\n\tfunction isEqual(a, b) {\n\t    if (Array.isArray(a) && Array.isArray(b)) {\n\t        return a.length === b.length && a.every(function (element, i) { return isEqual(element, b[i]); });\n\t    }\n\t    else if (shouldRecurseInto(a) && shouldRecurseInto(b)) {\n\t        var keysForA = Object.keys(a).sort();\n\t        var keysforB = Object.keys(b).sort();\n\t        return isEqual(keysForA, keysforB) && keysForA.every(function (key) { return isEqual(a[key], b[key]); });\n\t    }\n\t    else {\n\t        return a === b;\n\t    }\n\t}\n\texports.isEqual = isEqual;\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar utils_1 = __webpack_require__(51);\n\tvar createJsonPointer_1 = __webpack_require__(53);\n\tfunction navigatePath(target, path) {\n\t    var currentPath = '';\n\t    var lastSegment = '';\n\t    var pathSegments = path.segments();\n\t    pathSegments.forEach(function (segment, index) {\n\t        currentPath += \"/\" + segment;\n\t        if (!target) {\n\t            throw new Error(\"Invalid path: \" + currentPath + \" doesn't exist in target\");\n\t        }\n\t        else if (index + 1 < pathSegments.length) {\n\t            target = target[segment];\n\t        }\n\t        else {\n\t            lastSegment = segment;\n\t        }\n\t    });\n\t    return {\n\t        object: target,\n\t        property: lastSegment\n\t    };\n\t}\n\tfunction add(target) {\n\t    var applyTo = navigatePath(target, this.path);\n\t    applyTo.object[applyTo.property] = this.value;\n\t    return target;\n\t}\n\tfunction remove(target) {\n\t    var applyTo = navigatePath(target, this.path);\n\t    delete applyTo.object[applyTo.property];\n\t    return target;\n\t}\n\tfunction replace(target) {\n\t    var applyTo = navigatePath(target, this.path);\n\t    if (!(applyTo.property in applyTo.object)) {\n\t        throw new Error(\"Cannot replace undefined path: \" + this.path.toString() + \" on object\");\n\t    }\n\t    applyTo.object[applyTo.property] = this.value;\n\t    return target;\n\t}\n\tfunction copyOrMove(from, to, target, toDelete) {\n\t    var moveFrom = navigatePath(target, from);\n\t    if (!(moveFrom.property in moveFrom.object)) {\n\t        throw new Error(\"Cannot move from undefined path: \" + from.toString() + \" on object\");\n\t    }\n\t    var applyTo = navigatePath(target, to);\n\t    applyTo.object[applyTo.property] = moveFrom.object[moveFrom.property];\n\t    if (toDelete) {\n\t        delete moveFrom.object[moveFrom.property];\n\t    }\n\t}\n\tfunction move(target) {\n\t    copyOrMove(this.from, this.path, target, true);\n\t    return target;\n\t}\n\tfunction copy(target) {\n\t    copyOrMove(this.from, this.path, target, false);\n\t    return target;\n\t}\n\tfunction test(target) {\n\t    var applyTo = navigatePath(target, this.path);\n\t    return utils_1.isEqual(applyTo.object[applyTo.property], this.value);\n\t}\n\tfunction getPath(path) {\n\t    if (Array.isArray(path)) {\n\t        return createJsonPointer_1.default.apply(void 0, path);\n\t    }\n\t    else {\n\t        return path;\n\t    }\n\t}\n\tfunction toString() {\n\t    var jsonObj = {};\n\t    jsonObj.op = this.op;\n\t    jsonObj.path = this.path.toString();\n\t    if (this.value) {\n\t        jsonObj.value = this.value;\n\t    }\n\t    if (this.from) {\n\t        jsonObj.from = this.from.toString();\n\t    }\n\t    return JSON.stringify(jsonObj);\n\t}\n\tfunction createOperation(type, path, value, from, oldValue) {\n\t    switch (type) {\n\t        case 0 /* Add */:\n\t            return {\n\t                op: 'add',\n\t                path: getPath(path),\n\t                value: value,\n\t                apply: add,\n\t                toString: toString\n\t            };\n\t        case 1 /* Remove */:\n\t            return {\n\t                op: 'remove',\n\t                path: getPath(path),\n\t                apply: remove,\n\t                toString: toString\n\t            };\n\t        case 2 /* Replace */:\n\t            return {\n\t                op: 'replace',\n\t                path: getPath(path),\n\t                value: value,\n\t                oldValue: oldValue,\n\t                apply: replace,\n\t                toString: toString\n\t            };\n\t        case 4 /* Move */:\n\t            if (!from) {\n\t                throw new Error('From value is required for Move operations');\n\t            }\n\t            return {\n\t                op: 'move',\n\t                path: getPath(path),\n\t                from: getPath(from),\n\t                apply: move,\n\t                toString: toString\n\t            };\n\t        case 3 /* Copy */:\n\t            if (!from) {\n\t                throw new Error('From value is required in Copy operation');\n\t            }\n\t            return {\n\t                op: 'copy',\n\t                path: getPath(path),\n\t                from: getPath(from),\n\t                apply: copy,\n\t                toString: toString\n\t            };\n\t        case 5 /* Test */:\n\t            return {\n\t                op: 'test',\n\t                path: getPath(path),\n\t                value: value,\n\t                apply: test,\n\t                toString: toString\n\t            };\n\t    }\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createOperation;\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction navigate(path, target) {\n\t    return path.segments().reduce(function (prev, next) {\n\t        return prev ? prev[next] : prev;\n\t    }, target);\n\t}\n\texports.navigate = navigate;\n\tfunction decode(segment) {\n\t    return segment.replace(/~1/g, '/').replace(/~0/g, '~');\n\t}\n\tfunction encode(segment) {\n\t    return segment.replace(/~/g, '~0').replace(/\\//g, '~1');\n\t}\n\tfunction toString() {\n\t    var segments = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        segments[_i] = arguments[_i];\n\t    }\n\t    return segments.reduce(function (prev, next) {\n\t        return prev + '/' + encode(next);\n\t    });\n\t}\n\tfunction createJsonPointer() {\n\t    var segments = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        segments[_i] = arguments[_i];\n\t    }\n\t    return {\n\t        segments: function () {\n\t            return segments.map(function (segment) { return decode(segment); });\n\t        }, toString: function () {\n\t            return toString.apply(void 0, segments);\n\t        },\n\t        push: function (segment) {\n\t            return createJsonPointer.apply(void 0, segments.concat(segment));\n\t        },\n\t        pop: function () {\n\t            return createJsonPointer.apply(void 0, segments.slice(0, segments.length - 1));\n\t        }\n\t    };\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createJsonPointer;\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Promise_1 = __webpack_require__(23);\n\tvar global_1 = __webpack_require__(5);\n\tglobal_1.default.Rx = { config: { Promise: Promise_1.default } };\n\tfunction createStoreObservable(observable, transform) {\n\t    // Cast to any because the signatures of catch between the Observable and Promise interfaces are not\n\t    // compatible\n\t    var storeObservable = observable;\n\t    storeObservable.then = function (onFulfilled, onRejected) {\n\t        // Wrap in a shim promise because the interface that leaks through observable.toPromise is missing some\n\t        // properties on the shim(e.g. promise)\n\t        return Promise_1.default.resolve(observable.toPromise())\n\t            .then(transform)\n\t            .then(onFulfilled, onRejected);\n\t    };\n\t    storeObservable.catch = function (onRejected) {\n\t        return observable.toPromise().then(transform).then(undefined, onRejected);\n\t    };\n\t    return storeObservable;\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createStoreObservable;\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(6);\n\tvar Promise_1 = __webpack_require__(23);\n\tvar WeakMap_1 = __webpack_require__(20);\n\tvar Map_1 = __webpack_require__(30);\n\tvar lang_1 = __webpack_require__(13);\n\tvar uuid_1 = __webpack_require__(56);\n\tvar instanceStateMap = new WeakMap_1.default();\n\tfunction putSync(instance, items, options) {\n\t    var state = instanceStateMap.get(instance);\n\t    var ids = instance.identify(items);\n\t    var updatedItems = [];\n\t    var oldIndices = [];\n\t    var newIds = [];\n\t    var newItems = [];\n\t    ids.forEach(function (id, index) {\n\t        var oldIndex = state.index.get(id);\n\t        if (typeof oldIndex === 'undefined') {\n\t            newIds.push(id);\n\t            newItems.push(items[index]);\n\t        }\n\t        else {\n\t            updatedItems.push(items[index]);\n\t            oldIndices.push(oldIndex);\n\t        }\n\t    });\n\t    if (oldIndices.length && options && options.rejectOverwrite) {\n\t        throw Error('Objects already exist in store');\n\t    }\n\t    var data = state.data;\n\t    updatedItems.forEach(function (item, index) {\n\t        data[oldIndices[index]] = item;\n\t    });\n\t    newItems.forEach(function (item, index) {\n\t        state.index.set(newIds[index], data.push(item) - 1);\n\t    });\n\t    return {\n\t        successfulData: items,\n\t        type: 1 /* Put */\n\t    };\n\t}\n\tvar createInMemoryStorage = compose_1.default({\n\t    identify: function (items) {\n\t        var state = instanceStateMap.get(this);\n\t        var itemArray = Array.isArray(items) ? items : [items];\n\t        if (state.idProperty) {\n\t            var idProperty_1 = state.idProperty;\n\t            return itemArray.map(function (item) {\n\t                return item[idProperty_1];\n\t            });\n\t        }\n\t        else if (state.idFunction) {\n\t            return itemArray.map(state.idFunction);\n\t        }\n\t        else {\n\t            return itemArray.map(function (item) {\n\t                return item.id;\n\t            });\n\t        }\n\t    },\n\t    createId: function () {\n\t        return Promise_1.default.resolve(uuid_1.default());\n\t    },\n\t    fetch: function (query) {\n\t        var state = instanceStateMap.get(this);\n\t        var fullData = state.data;\n\t        var data = (query ? query.apply(fullData) : fullData).slice();\n\t        var returnPromise = state.returnsPromise.then(function () { return data; });\n\t        state.returnsPromise = returnPromise;\n\t        returnPromise.totalLength = returnPromise.dataLength = Promise_1.default.resolve(fullData.length);\n\t        return returnPromise;\n\t    },\n\t    get: function (ids) {\n\t        var state = instanceStateMap.get(this);\n\t        var data = state.data;\n\t        var objects = [];\n\t        return Promise_1.default.resolve(ids.reduce(function (prev, next) {\n\t            return state.index.has(next) ? prev.concat(data[state.index.get(next)]) : prev;\n\t        }, objects));\n\t    },\n\t    put: function (items, options) {\n\t        var state = instanceStateMap.get(this);\n\t        try {\n\t            var result_1 = putSync(this, items, options);\n\t            // Don't control the order operations are executed in, but make sure that the results\n\t            // resolve in the order they were actually executed in.\n\t            var returnPromise = state.returnsPromise.then(function () { return result_1; });\n\t            state.returnsPromise = returnPromise;\n\t            return returnPromise;\n\t        }\n\t        catch (error) {\n\t            return Promise_1.default.reject(error);\n\t        }\n\t    },\n\t    add: function (items, options) {\n\t        options = options || {};\n\t        var state = instanceStateMap.get(this);\n\t        if (typeof options.rejectOverwrite === 'undefined') {\n\t            options.rejectOverwrite = true;\n\t        }\n\t        try {\n\t            var result_2 = putSync(this, items, options);\n\t            // Don't control the order operations are executed in, but make sure that the results\n\t            // resolve in the order they were actually executed in.\n\t            var returnPromise = state.returnsPromise.then(function () {\n\t                result_2.type = 0 /* Add */;\n\t                return result_2;\n\t            });\n\t            state.returnsPromise = returnPromise;\n\t            return returnPromise;\n\t        }\n\t        catch (error) {\n\t            return Promise_1.default.reject(error);\n\t        }\n\t    },\n\t    delete: function (ids) {\n\t        var state = instanceStateMap.get(this);\n\t        var data = state.data;\n\t        var idsToRemove = ids.filter(function (id) {\n\t            return state.index.has(id);\n\t        });\n\t        var indices = idsToRemove\n\t            .map(function (id) {\n\t            return state.index.get(id);\n\t        })\n\t            .sort();\n\t        idsToRemove.forEach(function (id) {\n\t            state.index.delete(id);\n\t        });\n\t        indices.forEach(function (index, indexArrayIndex) {\n\t            return data.splice(index - indexArrayIndex, 1);\n\t        });\n\t        if (indices.length) {\n\t            var firstInvalidIndex_1 = indices[0];\n\t            var updateIndexForIds = this.identify(data.slice(firstInvalidIndex_1));\n\t            updateIndexForIds.forEach(function (id, index) {\n\t                state.index.set(id, index + firstInvalidIndex_1);\n\t            });\n\t        }\n\t        // Don't control the order operations are executed in, but make sure that the results\n\t        // resolve in the order they were actually executed in.\n\t        var returnPromise = state.returnsPromise.then(function () { return ({\n\t            successfulData: idsToRemove,\n\t            type: 3 /* Delete */\n\t        }); });\n\t        state.returnsPromise = returnPromise;\n\t        return returnPromise;\n\t    },\n\t    patch: function (updates) {\n\t        var state = instanceStateMap.get(this);\n\t        var data = state.data;\n\t        var filteredUpdates = updates.filter(function (update) {\n\t            return state.index.has(update.id);\n\t        });\n\t        var oldIndices = filteredUpdates.map(function (update) {\n\t            return state.index.get(update.id);\n\t        });\n\t        try {\n\t            var updatedItems_1 = filteredUpdates.map(function (update, index) {\n\t                var item = lang_1.duplicate(data[oldIndices[index]]);\n\t                var updatedItem = update.patch.apply(item);\n\t                data[oldIndices[index]] = updatedItem;\n\t                return updatedItem;\n\t            });\n\t            // Don't control the order operations are executed in, but make sure that the results\n\t            // resolve in the order they were actually executed in.\n\t            var returnsPromise = state.returnsPromise.then(function () { return ({\n\t                successfulData: updatedItems_1,\n\t                type: 2 /* Patch */\n\t            }); });\n\t            state.returnsPromise = returnsPromise;\n\t            return returnsPromise;\n\t        }\n\t        catch (error) {\n\t            return Promise_1.default.reject(error);\n\t        }\n\t    },\n\t    isUpdate: function (item) {\n\t        var state = instanceStateMap.get(this);\n\t        var id = this.identify([item])[0];\n\t        var isUpdate = state.index.has(id);\n\t        return Promise_1.default.resolve({\n\t            id: id,\n\t            item: item,\n\t            isUpdate: isUpdate\n\t        });\n\t    }\n\t}, function (instance, options) {\n\t    options = options || {};\n\t    instanceStateMap.set(instance, {\n\t        data: [],\n\t        index: new Map_1.default(),\n\t        idProperty: options.idProperty,\n\t        idFunction: options.idFunction,\n\t        returnsPromise: Promise_1.default.resolve()\n\t    });\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createInMemoryStorage;\n\n/***/ },\n/* 56 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * Returns a v4 compliant UUID.\n\t *\n\t * @returns {string}\n\t */\n\tfunction uuid() {\n\t    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t        var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n\t        return v.toString(16);\n\t    });\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = uuid;\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar decorators_1 = __webpack_require__(21);\n\tvar global_1 = __webpack_require__(10);\n\tvar iterator_1 = __webpack_require__(16);\n\t__webpack_require__(18);\n\tvar Shim;\n\t(function (Shim) {\n\t    var Set = (function () {\n\t        function Set(iterable) {\n\t            var _this = this;\n\t            this._setData = [];\n\t            this[Symbol.toStringTag] = 'Set';\n\t            if (iterable) {\n\t                iterator_1.forOf(iterable, function (value) { return _this.add(value); });\n\t            }\n\t        }\n\t        ;\n\t        Set.prototype.add = function (value) {\n\t            if (this.has(value)) {\n\t                return this;\n\t            }\n\t            this._setData.push(value);\n\t            return this;\n\t        };\n\t        ;\n\t        Set.prototype.clear = function () {\n\t            this._setData.length = 0;\n\t        };\n\t        ;\n\t        Set.prototype.delete = function (value) {\n\t            var idx = this._setData.indexOf(value);\n\t            if (idx === -1) {\n\t                return false;\n\t            }\n\t            this._setData.splice(idx, 1);\n\t            return true;\n\t        };\n\t        ;\n\t        Set.prototype.entries = function () {\n\t            return new iterator_1.ShimIterator(this._setData.map(function (value) { return [value, value]; }));\n\t        };\n\t        ;\n\t        Set.prototype.forEach = function (callbackfn, thisArg) {\n\t            var iterator = this.values();\n\t            var result = iterator.next();\n\t            while (!result.done) {\n\t                callbackfn.call(thisArg, result.value, result.value, this);\n\t                result = iterator.next();\n\t            }\n\t        };\n\t        ;\n\t        Set.prototype.has = function (value) {\n\t            return this._setData.indexOf(value) > -1;\n\t        };\n\t        ;\n\t        Set.prototype.keys = function () {\n\t            return new iterator_1.ShimIterator(this._setData);\n\t        };\n\t        ;\n\t        Object.defineProperty(Set.prototype, \"size\", {\n\t            get: function () {\n\t                return this._setData.length;\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        ;\n\t        Set.prototype.values = function () {\n\t            return new iterator_1.ShimIterator(this._setData);\n\t        };\n\t        ;\n\t        Set.prototype[Symbol.iterator] = function () {\n\t            return new iterator_1.ShimIterator(this._setData);\n\t        };\n\t        ;\n\t        return Set;\n\t    }());\n\t    Shim.Set = Set;\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\tvar Set = (function () {\n\t    /* istanbul ignore next */\n\t    function Set(iterable) {\n\t        /* istanbul ignore next */\n\t        this[Symbol.toStringTag] = 'Set';\n\t    }\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.add = function (value) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.clear = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.delete = function (value) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.entries = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.forEach = function (callbackfn, thisArg) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.has = function (value) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.keys = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    Object.defineProperty(Set.prototype, \"size\", {\n\t        /* istanbul ignore next */\n\t        get: function () { throw new Error('Abstract method'); },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.values = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype[Symbol.iterator] = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    return Set;\n\t}());\n\tSet = __decorate([\n\t    decorators_1.hasClass('es6-set', global_1.default.Set, Shim.Set)\n\t], Set);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Set;\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(13);\n\t/**\n\t * Wraps a setTimeout call in a handle, allowing the timeout to be cleared by calling destroy.\n\t *\n\t * @param callback Callback to be called when the timeout elapses\n\t * @param delay Number of milliseconds to wait before calling the callback\n\t * @return Handle which can be destroyed to clear the timeout\n\t */\n\tfunction createTimer(callback, delay) {\n\t    var timerId = setTimeout(callback, delay);\n\t    return lang_1.createHandle(function () {\n\t        if (timerId) {\n\t            clearTimeout(timerId);\n\t            timerId = null;\n\t        }\n\t    });\n\t}\n\texports.createTimer = createTimer;\n\t/**\n\t * Wraps a callback, returning a function which fires after no further calls are received over a set interval.\n\t *\n\t * @param callback Callback to wrap\n\t * @param delay Number of milliseconds to wait after any invocations before calling the original callback\n\t * @return Debounced function\n\t */\n\tfunction debounce(callback, delay) {\n\t    // node.d.ts clobbers setTimeout/clearTimeout with versions that return/receive NodeJS.Timer,\n\t    // but browsers return/receive a number\n\t    var timer;\n\t    return function () {\n\t        timer && clearTimeout(timer);\n\t        var context = this;\n\t        var args = arguments;\n\t        timer = setTimeout(function () {\n\t            callback.apply(context, args);\n\t            args = context = timer = null;\n\t        }, delay);\n\t    };\n\t}\n\texports.debounce = debounce;\n\t/**\n\t * Wraps a callback, returning a function which fires at most once per set interval.\n\t *\n\t * @param callback Callback to wrap\n\t * @param delay Number of milliseconds to wait before allowing the original callback to be called again\n\t * @return Throttled function\n\t */\n\tfunction throttle(callback, delay) {\n\t    var ran;\n\t    return function () {\n\t        if (ran) {\n\t            return;\n\t        }\n\t        ran = true;\n\t        callback.apply(this, arguments);\n\t        setTimeout(function () {\n\t            ran = null;\n\t        }, delay);\n\t    };\n\t}\n\texports.throttle = throttle;\n\t/**\n\t * Like throttle, but calls the callback at the end of each interval rather than the beginning.\n\t * Useful for e.g. resize or scroll events, when debounce would appear unresponsive.\n\t *\n\t * @param callback Callback to wrap\n\t * @param delay Number of milliseconds to wait before calling the original callback and allowing it to be called again\n\t * @return Throttled function\n\t */\n\tfunction throttleAfter(callback, delay) {\n\t    var ran;\n\t    return function () {\n\t        if (ran) {\n\t            return;\n\t        }\n\t        ran = true;\n\t        var context = this;\n\t        var args = arguments;\n\t        setTimeout(function () {\n\t            callback.apply(context, args);\n\t            args = context = ran = null;\n\t        }, delay);\n\t    };\n\t}\n\texports.throttleAfter = throttleAfter;\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar todoStore_1 = __webpack_require__(60);\n\tvar createFilter_1 = __webpack_require__(62);\n\tvar lang_1 = __webpack_require__(13);\n\tvar id = 0;\n\texports.addTodo = function (_a) {\n\t    var label = _a.label, completed = _a.completed;\n\t    return todoStore_1.default.add({ id: \"\" + id++, label: label, completed: completed });\n\t};\n\texports.deleteTodo = function (_a) {\n\t    var id = _a.id;\n\t    return todoStore_1.default.delete(id);\n\t};\n\texports.deleteCompleted = function () {\n\t    return todoStore_1.default.fetch(createFilter_1.default().equalTo('completed', true))\n\t        .then(function (items) { return todoStore_1.default.identify(items); })\n\t        .then(function (ids) { return todoStore_1.default.delete(ids); });\n\t};\n\texports.toggleAll = function (_a) {\n\t    var completed = _a.checked;\n\t    return todoStore_1.default.fetch()\n\t        .then(function (items) {\n\t        return items.map(function (item) {\n\t            return lang_1.assign({}, item, { completed: completed });\n\t        });\n\t    })\n\t        .then(function (items) { return todoStore_1.default.patch(items); });\n\t};\n\texports.updateTodo = function (item) {\n\t    return todoStore_1.default.patch(item);\n\t};\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createObservableStoreMixin_1 = __webpack_require__(46);\n\tvar widgetStoreActions_1 = __webpack_require__(61);\n\tvar todoStore = createObservableStoreMixin_1.createObservableStore({\n\t    data: [],\n\t    fetchAroundUpdates: true\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = todoStore;\n\tfunction bindActions() {\n\t    return todoStore\n\t        .observe()\n\t        .subscribe(function (options) {\n\t        widgetStoreActions_1.putTodo(options);\n\t    });\n\t}\n\texports.bindActions = bindActions;\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar widgetStore_1 = __webpack_require__(45);\n\texports.putTodo = function (_a) {\n\t    var _b = _a.afterAll, afterAll = _b === void 0 ? [] : _b;\n\t    var completedCount = afterAll.filter(function (_a) {\n\t        var completed = _a.completed;\n\t        return completed;\n\t    }).length;\n\t    var activeCount = afterAll.length - completedCount;\n\t    var allCompleted = afterAll.length === completedCount && afterAll.length;\n\t    return widgetStore_1.default.patch({ id: 'todo-app', todos: afterAll, activeCount: activeCount, completedCount: completedCount, allCompleted: allCompleted });\n\t};\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createJsonPointer_1 = __webpack_require__(53);\n\tvar utils_1 = __webpack_require__(51);\n\tfunction isBooleanOp(op) {\n\t    return op === 0 /* And */ || op === 1 /* Or */;\n\t}\n\tfunction isFilter(filterOrFunction) {\n\t    return typeof filterOrFunction !== 'function' && filterOrFunction.apply;\n\t}\n\tfunction createFilterOrReturnOp(descriptorOrOp) {\n\t    if (isBooleanOp(descriptorOrOp)) {\n\t        return descriptorOrOp;\n\t    }\n\t    else {\n\t        return createComparator(descriptorOrOp.filterType, descriptorOrOp.value, descriptorOrOp.path);\n\t    }\n\t}\n\tfunction createFilter(filterDescriptors, serializer) {\n\t    var filters = [];\n\t    if (filterDescriptors) {\n\t        if (Array.isArray(filterDescriptors)) {\n\t            filters = filterDescriptors.map(function (descriptorChainMember) {\n\t                if (Array.isArray(descriptorChainMember)) {\n\t                    return createFilter(descriptorChainMember);\n\t                }\n\t                else {\n\t                    return createFilterOrReturnOp(descriptorChainMember);\n\t                }\n\t            });\n\t        }\n\t        else {\n\t            filters.push(createComparator(filterDescriptors.filterType, filterDescriptors.value, filterDescriptors.path));\n\t        }\n\t    }\n\t    return createFilterHelper(filters, serializer || serializeFilter);\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createFilter;\n\tfunction createFilterHelper(filters, serializer) {\n\t    // Small helpers to abstract common operations for building comparator filters\n\t    // The main helper delegates to the factory, adding and AND operation before the next filter,\n\t    // because by default each filter in a chain will be ANDed with the previous.\n\t    function comparatorFilterHelper(filterType, value, path) {\n\t        path = path || createJsonPointer_1.default();\n\t        var needsOperator = filters.length > 0 &&\n\t            ((filters[filters.length - 1] !== 0 /* And */ && filters[filters.length - 1] !== 1) /* Or */);\n\t        var newFilters = needsOperator ? filters.concat([0 /* And */, createComparator(filterType, value, path)]) : filters.concat([createComparator(filterType, value, path)]);\n\t        return createFilterHelper(newFilters, serializer);\n\t    }\n\t    var filter = {\n\t        test: function (item) {\n\t            return applyFilterChain(item, filters);\n\t        },\n\t        filterType: 12 /* Compound */,\n\t        apply: function (data) {\n\t            return data.filter(this.test);\n\t        },\n\t        filterChain: filters,\n\t        toString: function (filterSerializer) {\n\t            return (filterSerializer || serializer)(this);\n\t        },\n\t        and: function (newFilter) {\n\t            var newFilters = [];\n\t            if (newFilter) {\n\t                newFilters.push(this, 0 /* And */, newFilter);\n\t            }\n\t            else if (filters.length) {\n\t                newFilters.push.apply(newFilters, filters.concat([0 /* And */]));\n\t            }\n\t            return createFilterHelper(newFilters, serializer);\n\t        },\n\t        or: function (newFilter) {\n\t            var newFilters = [];\n\t            if (newFilter) {\n\t                newFilters.push(this, 1 /* Or */, newFilter);\n\t            }\n\t            else if (filters.length) {\n\t                newFilters.push.apply(newFilters, filters.concat([1 /* Or */]));\n\t            }\n\t            return createFilterHelper(newFilters, serializer);\n\t        },\n\t        lessThan: function (path, value) {\n\t            return comparatorFilterHelper(0 /* LessThan */, value, path);\n\t        },\n\t        lessThanOrEqualTo: function (path, value) {\n\t            return comparatorFilterHelper(8 /* LessThanOrEqualTo */, value, path);\n\t        },\n\t        greaterThan: function (path, value) {\n\t            return comparatorFilterHelper(1 /* GreaterThan */, value, path);\n\t        },\n\t        greaterThanOrEqualTo: function (path, value) {\n\t            return comparatorFilterHelper(9 /* GreaterThanOrEqualTo */, value, path);\n\t        },\n\t        matches: function (path, value) {\n\t            return comparatorFilterHelper(10 /* Matches */, value, path);\n\t        },\n\t        'in': function (path, value) {\n\t            return comparatorFilterHelper(4 /* In */, value, path);\n\t        },\n\t        contains: function (path, value) {\n\t            return comparatorFilterHelper(5 /* Contains */, value, path);\n\t        },\n\t        equalTo: function (path, value) {\n\t            return comparatorFilterHelper(2 /* EqualTo */, value, path);\n\t        },\n\t        deepEqualTo: function (path, value) {\n\t            return comparatorFilterHelper(3 /* DeepEqualTo */, value, path);\n\t        },\n\t        notEqualTo: function (path, value) {\n\t            return comparatorFilterHelper(6 /* NotEqualTo */, value, path);\n\t        },\n\t        notDeepEqualTo: function (path, value) {\n\t            return comparatorFilterHelper(7 /* NotDeepEqualTo */, value, path);\n\t        },\n\t        custom: function (test) {\n\t            return comparatorFilterHelper(11 /* Custom */, test);\n\t        },\n\t        queryType: 0 /* Filter */,\n\t        incremental: true\n\t    };\n\t    return filter;\n\t}\n\tfunction applyFilterChain(item, filterChain) {\n\t    var ordFilterSections = [];\n\t    var startOfSlice = 0;\n\t    // Ands have higher precedence, so split into chains of\n\t    // ands between ors.\n\t    filterChain.forEach(function (chainMember, i) {\n\t        if (chainMember === 1 /* Or */) {\n\t            ordFilterSections.push(filterChain.slice(startOfSlice, i));\n\t            startOfSlice = i + 1;\n\t        }\n\t    });\n\t    if (startOfSlice < filterChain.length) {\n\t        ordFilterSections.push(filterChain.slice(startOfSlice, filterChain.length));\n\t    }\n\t    // These sections are or'd together so only\n\t    // one has to pass\n\t    return ordFilterSections.some(function (filterChain) {\n\t        // The individual filters are and'd together, so if any\n\t        // fails the whole section fails\n\t        return filterChain.every(function (filterOrAnd) {\n\t            if (isFilter(filterOrAnd)) {\n\t                return filterOrAnd.test(item);\n\t            }\n\t            else {\n\t                return true;\n\t            }\n\t        });\n\t    });\n\t}\n\tfunction createComparator(operator, value, path) {\n\t    path = typeof path === 'string' ? createJsonPointer_1.default(path) : path;\n\t    var test;\n\t    var filterType = operator;\n\t    var operatorString;\n\t    switch (operator) {\n\t        case 0 /* LessThan */:\n\t            test = function (property) {\n\t                return property < value;\n\t            };\n\t            operatorString = 'lt';\n\t            break;\n\t        case 8 /* LessThanOrEqualTo */:\n\t            test = function (property) {\n\t                return property <= value;\n\t            };\n\t            operatorString = 'lte';\n\t            break;\n\t        case 1 /* GreaterThan */:\n\t            test = function (property) {\n\t                return property > value;\n\t            };\n\t            operatorString = 'gt';\n\t            break;\n\t        case 9 /* GreaterThanOrEqualTo */:\n\t            test = function (property) {\n\t                return property >= value;\n\t            };\n\t            operatorString = 'gte';\n\t            break;\n\t        case 2 /* EqualTo */:\n\t            test = function (property) {\n\t                return property === value;\n\t            };\n\t            operatorString = 'eq';\n\t            break;\n\t        case 6 /* NotEqualTo */:\n\t            test = function (property) {\n\t                return property !== value;\n\t            };\n\t            operatorString = 'ne';\n\t            break;\n\t        case 3 /* DeepEqualTo */:\n\t            test = function (property) {\n\t                return utils_1.isEqual(property, value);\n\t            };\n\t            operatorString = 'eq';\n\t            break;\n\t        case 7 /* NotDeepEqualTo */:\n\t            test = function (property) {\n\t                return !utils_1.isEqual(property, value);\n\t            };\n\t            operatorString = 'ne';\n\t            break;\n\t        case 5 /* Contains */:\n\t            test = function (propertyOrItem) {\n\t                if (Array.isArray(propertyOrItem)) {\n\t                    return propertyOrItem.indexOf(value) > -1;\n\t                }\n\t                else {\n\t                    return propertyOrItem && Boolean(propertyOrItem[value]);\n\t                }\n\t            };\n\t            operatorString = 'contains';\n\t            break;\n\t        case 4 /* In */:\n\t            test = function (propertyOrItem) {\n\t                return Array.isArray(value) && value.indexOf(propertyOrItem) > -1;\n\t            };\n\t            operatorString = 'in';\n\t            break;\n\t        case 10 /* Matches */:\n\t            test = function (property) {\n\t                return value.test(property);\n\t            };\n\t            break;\n\t        case 11 /* Custom */:\n\t            test = value;\n\t            break;\n\t    }\n\t    return {\n\t        test: function (item) {\n\t            var propertyValue = createJsonPointer_1.navigate(path, item);\n\t            return test(propertyValue);\n\t        },\n\t        apply: function (data) {\n\t            return data.filter(this.test);\n\t        },\n\t        toString: function () {\n\t            if (!operatorString) {\n\t                throw Error('Cannot parse this filter type to an RQL query string');\n\t            }\n\t            return operatorString + \"(\" + path.toString() + \", \" + JSON.stringify(value) + \")\";\n\t        },\n\t        path: path,\n\t        value: value,\n\t        filterType: filterType,\n\t        queryType: 0 /* Filter */\n\t    };\n\t}\n\t//// Default serialization function\n\tfunction serializeFilter(filter) {\n\t    var operator = '&';\n\t    if (filter.filterChain && filter.filterChain.length > 0) {\n\t        return filter.filterChain.reduce(function (prev, next) {\n\t            if (isFilter(next)) {\n\t                var start = next.filterChain ? '(' : '';\n\t                var end = next.filterChain ? ')' : '';\n\t                return prev + (prev ? operator : '') + (prev ? start : '') + next.toString() + (prev ? end : '');\n\t            }\n\t            else if (next === 0 /* And */) {\n\t                operator = '&';\n\t                return prev;\n\t            }\n\t            else {\n\t                operator = '|';\n\t                return prev;\n\t            }\n\t        }, '');\n\t    }\n\t    else {\n\t        return '';\n\t    }\n\t}\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(64);\n\tvar storeMixin_1 = __webpack_require__(65);\n\tvar d_1 = __webpack_require__(28);\n\tvar userActions_1 = __webpack_require__(44);\n\tvar utils_1 = __webpack_require__(66);\n\tvar createApp = createWidgetBase_1.default\n\t    .mixin(storeMixin_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        classes: ['todoapp'],\n\t        tagName: 'section',\n\t        getChildrenNodes: function () {\n\t            var _a = this.state, _b = _a.todos, todos = _b === void 0 ? [] : _b, activeCount = _a.activeCount, completedCount = _a.completedCount, allCompleted = _a.allCompleted, activeFilter = _a.activeFilter;\n\t            var classes = todos && todos.length ? [] : ['hidden'];\n\t            var todoFooterProperties = { id: 'todo-footer', activeCount: activeCount, completedCount: completedCount, activeFilter: activeFilter, classes: classes };\n\t            return [\n\t                d_1.v('header', {}, [\n\t                    d_1.w('title', { label: 'todos' }),\n\t                    d_1.w('text-input', { classes: ['new-todo'], focused: true, placeholder: 'What needs to be done?', onKeyUp: utils_1.bind(userActions_1.todoInput, this) })\n\t                ]),\n\t                d_1.w('main-section', { todos: todos, activeFilter: activeFilter, allCompleted: allCompleted }),\n\t                d_1.w('todo-footer', todoFooterProperties)\n\t            ];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createApp;\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(6);\n\tvar createEvented_1 = __webpack_require__(36);\n\tvar lang_1 = __webpack_require__(13);\n\tvar WeakMap_1 = __webpack_require__(20);\n\tvar Map_1 = __webpack_require__(30);\n\tvar d_1 = __webpack_require__(28);\n\t/**\n\t * Internal state map for widget instances\n\t */\n\tvar widgetInternalStateMap = new WeakMap_1.default();\n\tvar propertyFunctionNameRegex = /^diffProperty(.*)/;\n\tfunction getFromRegistry(instance, factoryLabel) {\n\t    if (instance.registry && instance.registry.has(factoryLabel)) {\n\t        return instance.registry.get(factoryLabel);\n\t    }\n\t    return d_1.registry.get(factoryLabel);\n\t}\n\tfunction dNodeToVNode(instance, dNode) {\n\t    var internalState = widgetInternalStateMap.get(instance);\n\t    if (typeof dNode === 'string' || dNode === null) {\n\t        return dNode;\n\t    }\n\t    if (d_1.isWNode(dNode)) {\n\t        var children = dNode.children, properties = dNode.properties;\n\t        var key = properties.key;\n\t        var factory_1 = dNode.factory;\n\t        var child = void 0;\n\t        if (typeof factory_1 === 'string') {\n\t            var item = getFromRegistry(instance, factory_1);\n\t            if (compose_1.isComposeFactory(item)) {\n\t                factory_1 = item;\n\t            }\n\t            else {\n\t                if (item && !internalState.initializedFactoryMap.has(factory_1)) {\n\t                    var promise = item.then(function (factory) {\n\t                        instance.invalidate();\n\t                        return factory;\n\t                    });\n\t                    internalState.initializedFactoryMap.set(factory_1, promise);\n\t                }\n\t                return null;\n\t            }\n\t        }\n\t        var childrenMapKey = key || factory_1;\n\t        var cachedChildren = internalState.cachedChildrenMap.get(childrenMapKey) || [];\n\t        var cachedChild_1;\n\t        cachedChildren.some(function (cachedChildWrapper) {\n\t            if (cachedChildWrapper.factory === factory_1 && !cachedChildWrapper.used) {\n\t                cachedChild_1 = cachedChildWrapper;\n\t                return true;\n\t            }\n\t            return false;\n\t        });\n\t        if (cachedChild_1) {\n\t            child = cachedChild_1.child;\n\t            if (properties) {\n\t                child.setProperties(properties);\n\t            }\n\t            cachedChild_1.used = true;\n\t        }\n\t        else {\n\t            child = factory_1({ properties: properties });\n\t            child.own(child.on('invalidated', function () {\n\t                instance.invalidate();\n\t            }));\n\t            cachedChildren = cachedChildren.concat([{ child: child, factory: factory_1, used: true }]);\n\t            internalState.cachedChildrenMap.set(childrenMapKey, cachedChildren);\n\t            instance.own(child);\n\t        }\n\t        if (!key && cachedChildren.length > 1) {\n\t            var errorMsg = 'It is recommended to provide a unique `key` property when using the same widget factory multiple times';\n\t            console.warn(errorMsg);\n\t            instance.emit({ type: 'error', target: instance, error: new Error(errorMsg) });\n\t        }\n\t        child.setChildren(children);\n\t        return child.__render__();\n\t    }\n\t    dNode.children = dNode.children\n\t        .filter(function (child) { return child !== null; })\n\t        .map(function (child) {\n\t        return dNodeToVNode(instance, child);\n\t    });\n\t    return dNode.render({ bind: instance });\n\t}\n\tfunction manageDetachedChildren(instance) {\n\t    var internalState = widgetInternalStateMap.get(instance);\n\t    internalState.cachedChildrenMap.forEach(function (cachedChildren, key) {\n\t        var filterCachedChildren = cachedChildren.filter(function (cachedChild) {\n\t            if (cachedChild.used) {\n\t                cachedChild.used = false;\n\t                return true;\n\t            }\n\t            cachedChild.child.destroy();\n\t            return false;\n\t        });\n\t        internalState.cachedChildrenMap.set(key, filterCachedChildren);\n\t    });\n\t}\n\tfunction formatTagNameAndClasses(tagName, classes) {\n\t    if (classes.length) {\n\t        return tagName + \".\" + classes.join('.');\n\t    }\n\t    return tagName;\n\t}\n\tvar createWidget = createEvented_1.default\n\t    .mixin({\n\t    mixin: {\n\t        get properties() {\n\t            var properties = widgetInternalStateMap.get(this).properties;\n\t            return properties;\n\t        },\n\t        classes: [],\n\t        getNode: function () {\n\t            var tag = formatTagNameAndClasses(this.tagName, this.classes);\n\t            return d_1.v(tag, this.getNodeAttributes(), this.getChildrenNodes());\n\t        },\n\t        get children() {\n\t            return widgetInternalStateMap.get(this).children;\n\t        },\n\t        setChildren: function (children) {\n\t            var internalState = widgetInternalStateMap.get(this);\n\t            internalState.children = children;\n\t            this.emit({\n\t                type: 'widget:children',\n\t                target: this\n\t            });\n\t        },\n\t        getChildrenNodes: function () {\n\t            return this.children;\n\t        },\n\t        getNodeAttributes: function (overrides) {\n\t            var _this = this;\n\t            var props = {};\n\t            this.nodeAttributes.forEach(function (fn) {\n\t                var newProps = fn.call(_this);\n\t                if (newProps) {\n\t                    lang_1.assign(props, newProps);\n\t                }\n\t            });\n\t            return props;\n\t        },\n\t        invalidate: function () {\n\t            var internalState = widgetInternalStateMap.get(this);\n\t            internalState.dirty = true;\n\t            this.emit({\n\t                type: 'invalidated',\n\t                target: this\n\t            });\n\t        },\n\t        get id() {\n\t            return this.properties.id;\n\t        },\n\t        setProperties: function (properties) {\n\t            var _this = this;\n\t            var internalState = widgetInternalStateMap.get(this);\n\t            var diffPropertyResults = {};\n\t            var diffPropertyChangedKeys = [];\n\t            internalState.diffPropertyFunctionMap.forEach(function (property, diffFunctionName) {\n\t                var previousProperty = internalState.previousProperties[property];\n\t                var newProperty = properties[property];\n\t                var result = _this[diffFunctionName](previousProperty, newProperty);\n\t                if (!result) {\n\t                    return;\n\t                }\n\t                if (result.changed) {\n\t                    diffPropertyChangedKeys.push(property);\n\t                }\n\t                delete properties[property];\n\t                delete internalState.previousProperties[property];\n\t                diffPropertyResults[property] = result.value;\n\t            });\n\t            var diffPropertiesResult = this.diffProperties(internalState.previousProperties, properties);\n\t            internalState.properties = lang_1.assign(diffPropertiesResult.properties, diffPropertyResults);\n\t            var changedPropertyKeys = diffPropertiesResult.changedKeys.concat(diffPropertyChangedKeys);\n\t            if (changedPropertyKeys.length) {\n\t                this.emit({\n\t                    type: 'properties:changed',\n\t                    target: this,\n\t                    properties: this.properties,\n\t                    changedPropertyKeys: changedPropertyKeys\n\t                });\n\t            }\n\t            internalState.previousProperties = this.properties;\n\t        },\n\t        diffProperties: function (previousProperties, newProperties) {\n\t            var changedKeys = Object.keys(newProperties).reduce(function (changedPropertyKeys, propertyKey) {\n\t                if (previousProperties[propertyKey] !== newProperties[propertyKey]) {\n\t                    changedPropertyKeys.push(propertyKey);\n\t                }\n\t                return changedPropertyKeys;\n\t            }, []);\n\t            return { changedKeys: changedKeys, properties: lang_1.assign({}, newProperties) };\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                var baseIdProp = this.properties && this.properties.id ? { 'data-widget-id': this.properties.id } : {};\n\t                var _a = (this.properties || {}).styles, styles = _a === void 0 ? {} : _a;\n\t                var classes = {};\n\t                var internalState = widgetInternalStateMap.get(this);\n\t                internalState.widgetClasses.forEach(function (c) { return classes[c] = false; });\n\t                if (this.properties && this.properties.classes) {\n\t                    this.properties.classes.forEach(function (c) { return classes[c] = true; });\n\t                    internalState.widgetClasses = this.properties.classes;\n\t                }\n\t                return lang_1.assign(baseIdProp, { key: this, classes: classes, styles: styles });\n\t            }\n\t        ],\n\t        __render__: function () {\n\t            var internalState = widgetInternalStateMap.get(this);\n\t            if (internalState.dirty || !internalState.cachedVNode) {\n\t                var widget = dNodeToVNode(this, this.getNode());\n\t                manageDetachedChildren(this);\n\t                if (widget) {\n\t                    internalState.cachedVNode = widget;\n\t                }\n\t                internalState.dirty = false;\n\t                return widget;\n\t            }\n\t            return internalState.cachedVNode;\n\t        },\n\t        registry: undefined,\n\t        tagName: 'div'\n\t    },\n\t    initialize: function (instance, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var tagName = options.tagName, _a = options.properties, properties = _a === void 0 ? {} : _a;\n\t        var diffPropertyFunctionMap = new Map_1.default();\n\t        instance.tagName = tagName || instance.tagName;\n\t        Object.keys(Object.getPrototypeOf(instance)).forEach(function (attribute) {\n\t            var match = attribute.match(propertyFunctionNameRegex);\n\t            if (match) {\n\t                diffPropertyFunctionMap.set(match[0], \"\" + match[1].slice(0, 1).toLowerCase() + match[1].slice(1));\n\t            }\n\t        });\n\t        widgetInternalStateMap.set(instance, {\n\t            dirty: true,\n\t            widgetClasses: [],\n\t            properties: {},\n\t            previousProperties: {},\n\t            initializedFactoryMap: new Map_1.default(),\n\t            cachedChildrenMap: new Map_1.default(),\n\t            diffPropertyFunctionMap: diffPropertyFunctionMap,\n\t            children: []\n\t        });\n\t        instance.own(instance.on('properties:changed', function (evt) {\n\t            instance.invalidate();\n\t        }));\n\t        instance.setProperties(properties);\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createWidget;\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar WeakMap_1 = __webpack_require__(20);\n\tvar array_1 = __webpack_require__(14);\n\tvar lang_1 = __webpack_require__(13);\n\tvar createEvented_1 = __webpack_require__(36);\n\t/**\n\t * Private map for store mixin.\n\t */\n\tvar internalStateMap = new WeakMap_1.default();\n\tvar stateMap = new WeakMap_1.default();\n\t/**\n\t * state changed event type\n\t */\n\tvar stateChangedEventType = 'state:changed';\n\tfunction replaceState(instance, state) {\n\t    var internalState = stateMap.get(instance);\n\t    internalState.state = state;\n\t    var eventObject = {\n\t        type: stateChangedEventType,\n\t        state: state,\n\t        target: instance\n\t    };\n\t    instance.emit(eventObject);\n\t}\n\tfunction onPropertiesChanged(instance, properties, changedPropertyKeys) {\n\t    var internalState = internalStateMap.get(instance);\n\t    if (internalState) {\n\t        if (array_1.includes(changedPropertyKeys, 'store') || array_1.includes(changedPropertyKeys, 'id')) {\n\t            internalState.handle.destroy();\n\t        }\n\t    }\n\t    instance.observe();\n\t}\n\t/**\n\t * Store Mixin Factory\n\t */\n\tvar storeMixinFactory = createEvented_1.default.mixin({\n\t    className: 'StoreMixin',\n\t    mixin: {\n\t        get state() {\n\t            return stateMap.get(this).state;\n\t        },\n\t        observe: function () {\n\t            var _this = this;\n\t            var internalState = internalStateMap.get(this);\n\t            var _a = this.properties, id = _a.id, store = _a.store;\n\t            if (!store) {\n\t                throw new Error('store is required to observe state');\n\t            }\n\t            if (internalState) {\n\t                if (internalState.id === id) {\n\t                    return;\n\t                }\n\t                throw new Error('Unable to observe state for a different id');\n\t            }\n\t            var observer = id ? store.observe(id) : store.observe();\n\t            var subscription = observer.subscribe(function (state) {\n\t                replaceState(_this, state['afterAll'] ? { data: state['afterAll'] } : state);\n\t            }, function (err) {\n\t                throw err;\n\t            });\n\t            var handle = {\n\t                destroy: function () {\n\t                    subscription.unsubscribe();\n\t                    internalStateMap.delete(_this);\n\t                }\n\t            };\n\t            internalStateMap.set(this, { id: id, handle: handle });\n\t            this.own(handle);\n\t        },\n\t        setState: function (newState) {\n\t            var _this = this;\n\t            var _a = this.properties, store = _a.store, id = _a.id;\n\t            if (id || newState['id']) {\n\t                store.patch(lang_1.assign({ id: id }, newState))\n\t                    .then(function () { return id ? store.get(id) : store.fetch(); })\n\t                    .then(function (state) {\n\t                    replaceState(_this, state);\n\t                });\n\t            }\n\t            else {\n\t                throw new Error('Unable to set state without a specified `id`');\n\t            }\n\t        }\n\t    },\n\t    initialize: function (instance) {\n\t        instance.own(instance.on('properties:changed', function (evt) {\n\t            onPropertiesChanged(instance, evt.properties, evt.changedPropertyKeys);\n\t        }));\n\t        instance.own(instance.on(stateChangedEventType, function () {\n\t            instance.invalidate();\n\t        }));\n\t        stateMap.set(instance, { state: Object.create(null) });\n\t        instance.observe();\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = storeMixinFactory;\n\n/***/ },\n/* 66 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction bind(fn, instance) {\n\t    return fn.bind(instance);\n\t}\n\texports.bind = bind;\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(64);\n\tvar createLabel = createWidgetBase_1.default\n\t    .mixin({\n\t    mixin: {\n\t        tagName: 'label',\n\t        onDblclick: function (event) {\n\t            this.properties.onDblclick && this.properties.onDblclick(event);\n\t        },\n\t        onKeypress: function (event) {\n\t            this.properties.onKeypress && this.properties.onKeypress(event);\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                return {\n\t                    innerHTML: this.properties.label,\n\t                    'aria-describedby': 'edit-instructions',\n\t                    tabindex: '0',\n\t                    onkeyup: this.onKeypress,\n\t                    ondblclick: this.onDblclick\n\t                };\n\t            }\n\t        ]\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createLabel;\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(64);\n\tvar createTitle = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'h1',\n\t        nodeAttributes: [\n\t            function () {\n\t                return { innerHTML: this.properties.label };\n\t            }\n\t        ]\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createTitle;\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(64);\n\tvar createButton = createWidgetBase_1.default\n\t    .mixin({\n\t    mixin: {\n\t        onClick: function (event) {\n\t            this.properties.onClick && this.properties.onClick(event);\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                return { innerHTML: this.properties.label, onclick: this.onClick };\n\t            }\n\t        ],\n\t        tagName: 'button',\n\t        type: 'button'\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createButton;\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(64);\n\tvar d_1 = __webpack_require__(28);\n\tvar userActions_1 = __webpack_require__(44);\n\tvar utils_1 = __webpack_require__(66);\n\tvar createTodoItem = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'li',\n\t        nodeAttributes: [\n\t            function () {\n\t                var _a = this.properties, completed = _a.completed, editing = _a.editing;\n\t                return {\n\t                    classes: { completed: completed, editing: editing }\n\t                };\n\t            }\n\t        ],\n\t        getChildrenNodes: function () {\n\t            var _a = this.properties, todoId = _a.id, checked = _a.completed, label = _a.label, _b = _a.editing, focused = _b === void 0 ? false : _b;\n\t            return [\n\t                d_1.v('div.view', [\n\t                    d_1.w('checkbox', { classes: ['toggle'], checked: checked, onChange: utils_1.bind(userActions_1.todoToggleComplete, this) }),\n\t                    d_1.w('label', { label: label, onDblclick: utils_1.bind(userActions_1.todoEdit, this), onKeypress: utils_1.bind(userActions_1.todoEdit, this) }),\n\t                    d_1.w('button', { classes: ['destroy'], onClick: utils_1.bind(userActions_1.todoRemove, this) })\n\t                ]),\n\t                focused ? d_1.w('text-input', {\n\t                    value: label,\n\t                    id: todoId,\n\t                    focused: focused, classes: ['edit'],\n\t                    onBlur: utils_1.bind(userActions_1.todoSave, this),\n\t                    onKeyUp: utils_1.bind(userActions_1.todoEditInput, this)\n\t                }) : null\n\t            ];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createTodoItem;\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(64);\n\tvar d_1 = __webpack_require__(28);\n\tvar lang_1 = __webpack_require__(13);\n\tfunction filter(filterName, todo) {\n\t    switch (filterName) {\n\t        case 'completed':\n\t            return !!todo.completed;\n\t        case 'active':\n\t            return !todo.completed;\n\t        default:\n\t            return true;\n\t    }\n\t}\n\tvar createTodoList = createWidgetBase_1.default\n\t    .mixin({\n\t    mixin: {\n\t        tagName: 'ul',\n\t        classes: ['todo-list'],\n\t        getChildrenNodes: function () {\n\t            var _a = this.properties, _b = _a.todos, todos = _b === void 0 ? [] : _b, _c = _a.activeFilter, activeFilter = _c === void 0 ? '' : _c;\n\t            return todos\n\t                .filter(function (todo) { return filter(activeFilter, todo); })\n\t                .map(function (todo) { return d_1.w('todo-item', lang_1.assign({}, { key: todo.id }, todo)); });\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createTodoList;\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(64);\n\tvar d_1 = __webpack_require__(28);\n\tfunction createFilterItems(activeFilter) {\n\t    var filters = ['all', 'active', 'completed'];\n\t    return filters.map(function (filterItem) {\n\t        var label = filterItem[0].toUpperCase() + filterItem.substring(1);\n\t        return d_1.v('li', {}, [\n\t            d_1.v('a', {\n\t                innerHTML: label,\n\t                href: \"#\" + filterItem,\n\t                classes: {\n\t                    selected: activeFilter === filterItem\n\t                }\n\t            })\n\t        ]);\n\t    });\n\t}\n\tvar createTodoFilter = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'ul',\n\t        classes: ['filters'],\n\t        getChildrenNodes: function () {\n\t            var activeFilter = this.properties.activeFilter || '';\n\t            return createFilterItems(activeFilter);\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createTodoFilter;\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(64);\n\tvar d_1 = __webpack_require__(28);\n\tvar userActions_1 = __webpack_require__(44);\n\tvar createTodoFooter = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'footer',\n\t        classes: ['footer'],\n\t        getChildrenNodes: function () {\n\t            var _a = this.properties, activeCount = _a.activeCount, activeFilter = _a.activeFilter, completedCount = _a.completedCount;\n\t            var countLabel = activeCount === 1 ? 'item' : 'items';\n\t            return [\n\t                d_1.v('span', { 'class': 'todo-count' }, [\n\t                    d_1.v('strong', [activeCount + ' ']),\n\t                    d_1.v('span', [countLabel + ' left'])\n\t                ]),\n\t                d_1.w('todo-filter', {\n\t                    classes: ['filters'],\n\t                    activeFilter: activeFilter\n\t                }),\n\t                completedCount ? d_1.w('button', {\n\t                    onClick: userActions_1.clearCompleted,\n\t                    label: 'Clear completed',\n\t                    classes: ['clear-completed']\n\t                }) : null\n\t            ];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createTodoFooter;\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(64);\n\tvar d_1 = __webpack_require__(28);\n\tvar userActions_1 = __webpack_require__(44);\n\tvar createMainSection = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'section',\n\t        classes: ['main'],\n\t        getChildrenNodes: function () {\n\t            var _a = this.properties, activeFilter = _a.activeFilter, todos = _a.todos, checked = _a.allCompleted;\n\t            return [\n\t                d_1.w('checkbox', { checked: checked, onChange: userActions_1.todoToggleAll, classes: ['toggle-all'] }),\n\t                d_1.w('todo-list', { todos: todos, activeFilter: activeFilter })\n\t            ];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createMainSection;\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(64);\n\tvar createCheckboxInput = createWidgetBase_1.default\n\t    .mixin({\n\t    mixin: {\n\t        tagName: 'input',\n\t        type: 'checkbox',\n\t        onChange: function (event) {\n\t            this.properties.onChange && this.properties.onChange(event);\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                var _a = this, type = _a.type, onchange = _a.onChange, checked = _a.properties.checked;\n\t                return { checked: checked, onchange: onchange, type: type };\n\t            }\n\t        ]\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createCheckboxInput;\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(64);\n\tvar createFocusableTextInput = createWidgetBase_1.default\n\t    .mixin({\n\t    mixin: {\n\t        tagName: 'input',\n\t        type: 'text',\n\t        onKeyUp: function (event) {\n\t            this.properties.onKeyUp && this.properties.onKeyUp(event);\n\t        },\n\t        onBlur: function (event) {\n\t            this.properties.onBlur && this.properties.onBlur(event);\n\t        },\n\t        afterUpdate: function (element) {\n\t            var focused = this.properties.focused;\n\t            if (focused) {\n\t                setTimeout(function () { return element.focus(); }, 0);\n\t            }\n\t            else if (!focused && document.activeElement === element) {\n\t                element.blur();\n\t            }\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                var _a = this, onkeyup = _a.onKeyUp, onblur = _a.onBlur, afterUpdate = _a.afterUpdate, afterCreate = _a.afterUpdate;\n\t                var _b = this.properties, placeholder = _b.placeholder, _c = _b.value, value = _c === void 0 ? '' : _c;\n\t                return { afterUpdate: afterUpdate, placeholder: placeholder, innerHTML: value, value: value, afterCreate: afterCreate, onkeyup: onkeyup, onblur: onblur };\n\t            }\n\t        ]\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createFocusableTextInput;\n\n\n/***/ },\n/* 77 */\n1\n/******/ ])))\n});\n;\n\n\n// WEBPACK FOOTER //\n// src/main.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2b3123ceb3e8c542395e","import createProjectorMixin from '@dojo/widget-core/mixins/createProjectorMixin';\nimport { registry } from '@dojo/widget-core/d';\n\nimport router from './routes';\nimport { bindActions as bindTodoStoreActions } from './stores/todoStore';\nimport widgetStore from './stores/widgetStore';\nimport createApp from './createApp';\nimport createLabel from './widgets/createLabel';\nimport createTitle from './widgets/createTitle';\nimport createButton from './widgets/createButton';\nimport createTodoItem from './widgets/createTodoItem';\nimport createTodoList from './widgets/createTodoList';\nimport createTodoFilter from './widgets/createTodoFilter';\nimport createTodoFooter from './widgets/createTodoFooter';\nimport createMainSection from './widgets/createMainSection';\nimport createCheckboxInput from './widgets/createCheckboxInput';\nimport createFocusableTextInput from './widgets/createFocusableTextInput';\n\nimport 'todomvc-app-css/index.css';\n\nregistry.define('label', createLabel);\nregistry.define('title', createTitle);\nregistry.define('button', createButton);\nregistry.define('todo-item', createTodoItem);\nregistry.define('todo-list', createTodoList);\nregistry.define('todo-filter', createTodoFilter);\nregistry.define('todo-footer', createTodoFooter);\nregistry.define('main-section', createMainSection);\nregistry.define('checkbox', createCheckboxInput);\nregistry.define('text-input', createFocusableTextInput);\n\nconst root = document.getElementsByTagName('my-app')[0];\n\nconst app = createApp.mixin(createProjectorMixin)({\n\tproperties: {\n\t\tid: 'todo-app',\n\t\tstore: widgetStore\n\t},\n\troot\n});\n\napp.append()\n\t.then(() => bindTodoStoreActions())\n\t.then(() => router.start());\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.ts","\"use strict\";\nvar global_1 = require(\"@dojo/core/global\");\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar maquette_1 = require(\"maquette\");\n/**\n * Represents the state of the projector\n */\nvar ProjectorState;\n(function (ProjectorState) {\n    ProjectorState[ProjectorState[\"Attached\"] = 1] = \"Attached\";\n    ProjectorState[ProjectorState[\"Detached\"] = 2] = \"Detached\";\n})(ProjectorState = exports.ProjectorState || (exports.ProjectorState = {}));\n/**\n * Attach type for the projector\n */\nvar AttachType;\n(function (AttachType) {\n    AttachType[AttachType[\"Append\"] = 1] = \"Append\";\n    AttachType[AttachType[\"Merge\"] = 2] = \"Merge\";\n    AttachType[AttachType[\"Replace\"] = 3] = \"Replace\";\n})(AttachType = exports.AttachType || (exports.AttachType = {}));\n/**\n * Private state map keyed by instance.\n */\nvar projectorDataMap = new WeakMap_1.default();\n/**\n * Schedules a render.\n */\nfunction scheduleRender(event) {\n    var projector = event.target;\n    var projectorData = projectorDataMap.get(projector);\n    if (projectorData.state === ProjectorState.Attached) {\n        projector.emit({\n            type: 'render:scheduled',\n            target: projector\n        });\n        projectorData.projector.scheduleRender();\n    }\n}\nfunction attach(instance, _a) {\n    var type = _a.type;\n    var projectorData = projectorDataMap.get(instance);\n    var render = instance.__render__.bind(instance);\n    if (projectorData.state === ProjectorState.Attached) {\n        return projectorData.attachPromise || Promise_1.default.resolve({});\n    }\n    projectorData.state = ProjectorState.Attached;\n    projectorData.attachHandle = instance.own({\n        destroy: function () {\n            if (projectorData.state === ProjectorState.Attached) {\n                projectorData.projector.stop();\n                projectorData.projector.detach(render);\n                projectorData.state = ProjectorState.Detached;\n            }\n            projectorData.attachHandle = { destroy: function () { } };\n        }\n    });\n    projectorData.attachPromise = new Promise_1.default(function (resolve, reject) {\n        projectorData.afterCreate = function () {\n            instance.emit({\n                type: 'projector:attached',\n                target: instance\n            });\n            resolve(projectorData.attachHandle);\n        };\n    });\n    switch (type) {\n        case AttachType.Append:\n            projectorData.projector.append(projectorData.root, render);\n            break;\n        case AttachType.Merge:\n            projectorData.projector.merge(projectorData.root, render);\n            break;\n        case AttachType.Replace:\n            projectorData.projector.replace(projectorData.root, render);\n            break;\n    }\n    return projectorData.attachPromise;\n}\nvar createProjectorMixin = compose_1.default({\n    append: function () {\n        var options = {\n            type: AttachType.Append\n        };\n        return attach(this, options);\n    },\n    merge: function () {\n        var options = {\n            type: AttachType.Merge\n        };\n        return attach(this, options);\n    },\n    replace: function () {\n        var options = {\n            type: AttachType.Replace\n        };\n        return attach(this, options);\n    },\n    set root(root) {\n        var projectorData = projectorDataMap.get(this);\n        if (projectorData.state === ProjectorState.Attached) {\n            throw new Error('Projector already attached, cannot change root element');\n        }\n        projectorData.root = root;\n    },\n    get root() {\n        var projectorData = projectorDataMap.get(this);\n        return projectorData && projectorData.root;\n    },\n    get projector() {\n        return projectorDataMap.get(this).projector;\n    },\n    get projectorState() {\n        var projectorData = projectorDataMap.get(this);\n        return projectorData && projectorData.state;\n    }\n}).mixin({\n    mixin: {\n        nodeAttributes: [\n            function () {\n                var afterCreate = projectorDataMap.get(this).afterCreate;\n                return { afterCreate: afterCreate };\n            }\n        ]\n    },\n    aspectAdvice: {\n        after: {\n            __render__: function (result) {\n                if (typeof result === 'string' || result === null) {\n                    throw new Error('Must provide a VNode at the root of a projector');\n                }\n                return result;\n            }\n        }\n    }\n}).mixin({\n    initialize: function (instance, options) {\n        if (options === void 0) { options = {}; }\n        var _a = options.root, root = _a === void 0 ? document.body : _a, _b = options.cssTransitions, cssTransitions = _b === void 0 ? false : _b;\n        var maquetteProjectorOptions = {};\n        if (cssTransitions) {\n            if (global_1.default.cssTransitions) {\n                maquetteProjectorOptions.transitions = global_1.default.cssTransitions;\n            }\n            else {\n                throw new Error('Unable to create projector with css transitions enabled. Is the \\'css-transition.js\\' script loaded in the page?');\n            }\n        }\n        instance.own(instance.on('widget:children', instance.invalidate));\n        instance.own(instance.on('invalidated', scheduleRender));\n        var projector = maquette_1.createProjector(maquetteProjectorOptions);\n        projectorDataMap.set(instance, {\n            projector: projector,\n            root: root,\n            state: ProjectorState.Detached\n        });\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createProjectorMixin;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widget-core/mixins/createProjectorMixin.js\n// module id = 4\n// module chunks = 0","\"use strict\";\nvar globalObject = (function () {\n    if (typeof window !== 'undefined') {\n        // Browsers\n        return window;\n    }\n    else if (typeof global !== 'undefined') {\n        // Node\n        return global;\n    }\n    else if (typeof self !== 'undefined') {\n        // Web workers\n        return self;\n    }\n    return {};\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = globalObject;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/global.js\n// module id = 5\n// module chunks = 0","\"use strict\";\nvar instrument_1 = require(\"@dojo/core/instrument\");\nvar lang_1 = require(\"@dojo/core/lang\");\nvar array_1 = require(\"@dojo/shim/array\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar Symbol_1 = require(\"@dojo/shim/Symbol\");\nvar aspect_1 = require(\"./aspect\");\n/**\n * The default factory label if no label can be derived during the factory creation process\n */\nvar DEFAULT_FACTORY_LABEL = 'Compose';\n/* References to support minification */\nvar defineProperty = Object.defineProperty;\nvar isArray = Array.isArray;\nvar objectCreate = Object.create;\nvar objectKeys = Object.keys;\n/**\n * A weakmap that stores all the private data for a factory\n */\nvar privateFactoryData = new WeakMap_1.default();\n/**\n * An internal function which stubs out a method which, when called at runtime, throws.\n *\n * @param method The name of \"abstract\" method being called\n */\nfunction missingMethod(method) {\n    return function throwOnMissingMethod() {\n        throw new TypeError(\"Advice being applied to missing method named: \" + method);\n    };\n}\n/**\n * Internal function which can label a factory with a name and also sets\n * the `toString()` method on the prototype to return the approriate\n * name for instances.\n *\n * @param fn The name of the factory to label\n * @param value The name to supply for the label\n */\nfunction assignFactoryName(factory, value) {\n    if (typeof factory === 'function' && factory.prototype) {\n        assignFunctionName(factory, value);\n        defineProperty(factory.prototype, Symbol_1.default.toStringTag, {\n            get: function () {\n                return value;\n            },\n            configurable: true\n        });\n    }\n}\n/**\n * Internal function which can label a function with a name\n */\nfunction assignFunctionName(fn, value) {\n    var nameDescriptor = Object.getOwnPropertyDescriptor(fn, 'name');\n    if (typeof nameDescriptor === 'undefined' || nameDescriptor.configurable) {\n        defineProperty(fn, 'name', {\n            value: value,\n            writable: true,\n            configurable: true\n        });\n    }\n}\n/**\n * A helper function that copies own properties and their descriptors\n * from one or more sources to a target object. Includes non-enumerable properties\n *\n * @param overwrite If `true` properties, like arrays, will not be merged, instead overwritten\n * @param target The target that properties should be copied onto\n * @param sources The rest of the parameters treated as sources to apply\n */\nfunction assignProperties(overwrite, target) {\n    var sources = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        sources[_i - 2] = arguments[_i];\n    }\n    sources.forEach(function (source) {\n        if (!source) {\n            return;\n        }\n        Object.defineProperties(target, Object.getOwnPropertyNames(source).reduce(function (descriptors, key) {\n            if (key !== 'constructor') {\n                var sourceDescriptor = Object.getOwnPropertyDescriptor(source, key);\n                var sourceValue = sourceDescriptor && sourceDescriptor.value;\n                var targetDescriptor = Object.getOwnPropertyDescriptor(target, key);\n                var targetValue = targetDescriptor && targetDescriptor.value;\n                /* Special handling to merge array proprties */\n                if (!overwrite && isArray(sourceValue) && isArray(targetValue)) {\n                    sourceDescriptor.value = sourceValue.reduce(function (value, current) {\n                        if (!array_1.includes(target[key], current)) {\n                            value.push(current);\n                        }\n                        return value;\n                    }, array_1.from(targetValue));\n                }\n                descriptors[key] = sourceDescriptor;\n            }\n            return descriptors;\n        }, objectCreate(null)));\n    });\n    return target;\n}\n/**\n * A helper funtion to return a function that is rebased to infer that the\n * first argument of the passed function will be the `this` when the function\n * is executed.\n *\n * @param  fn The function to be rebased\n * @return    The rebased function\n */\nfunction rebase(fn) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn.apply(this, [this].concat(args));\n    };\n}\n/**\n * For a given factory, return the names of the initialization functions that will be\n * invoked upon construction.\n *\n * @param factory The factory that the array of function names should be returned for\n */\nfunction getInitFunctionNames(factory) {\n    var initFns = privateFactoryData.get(factory).initFns;\n    if (initFns) {\n        return initFns.map(function (fn) { return fn.name; });\n    }\n}\nexports.getInitFunctionNames = getInitFunctionNames;\n/* The rebased functions we need to decorate compose constructors with */\n/**\n * Perform an extension of a class\n *\n * @deprecated\n */\nvar doExtend = rebase(extend);\n/**\n * Perform a mixin of a class\n */\nvar doMixin = rebase(mixin);\n/**\n * Perform a override of a class\n */\nvar doOverride = rebase(override);\n/**\n * Perform an overlay of a class\n */\nvar doOverlay = rebase(overlay);\n/**\n * Apply aspect advice to a class\n */\nvar doAspect = rebase(aspect);\n/**\n * Add static method/properties to a class\n */\nvar doStatic = rebase(_static);\n/**\n * Take a mixin and return a factory descriptor for the mixin\n *\n * @param mixin The factory to return the descriptor for\n * @template T The outer type of the descriptor\n * @template O The outer factory options of the descriptor\n * @template U The inner type of the descriptor\n * @template P The inner factory options of the descriptor\n */\nfunction factoryDescriptor(mixin) {\n    return {\n        mixin: mixin,\n        className: mixin.name\n    };\n}\n/**\n * Generate a factory descriptor for a class\n */\nvar doFactoryDescriptor = rebase(factoryDescriptor);\n/**\n * A set of functions that are used to decorate the compose factories\n */\nvar staticMethods = {\n    extend: doExtend,\n    mixin: doMixin,\n    override: doOverride,\n    overlay: doOverlay,\n    from: doFrom,\n    before: doBefore,\n    after: doAfter,\n    around: doAround,\n    aspect: doAspect,\n    factoryDescriptor: doFactoryDescriptor,\n    static: doStatic\n};\n/**\n * Internal function that merges (or creates) an advice map\n *\n * @param sources The advice maps to be merged into a single one\n */\nfunction assignAdviceMap() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    var result = {};\n    sources.forEach(function (source) {\n        if (source) {\n            for (var method in source) {\n                result[method] = result[method] ? result[method].concat(source[method]) : source[method].slice();\n            }\n        }\n    });\n    return result;\n}\n/**\n * An internal function that takes a set of create widget options and returns a set of private factory data\n *\n * @param options The set of factory options to use in creating the private factory data\n */\nfunction createPrivateFactoryData(_a) {\n    var optionsAdvice = _a.advice, factories = _a.factories, initFunction = _a.initFunction, overwrite = _a.overwrite, proto = _a.proto, staticProperties = _a.staticProperties;\n    var factoryData = (factories || []).reduce(function (factoryData, factory) {\n        var _a = privateFactoryData.get(factory), advice = _a.advice, base = _a.base, initFns = _a.initFns;\n        if (advice) {\n            factoryData.advice = assignAdviceMap(factoryData.advice, advice);\n        }\n        if (base) {\n            assignProperties(false, factoryData.base, base);\n        }\n        var optionsInitFns = factoryData.initFns;\n        initFns.forEach(function (initFn) {\n            if (!array_1.includes(optionsInitFns, initFn)) {\n                optionsInitFns.push(initFn);\n            }\n        });\n        return factoryData;\n    }, {\n        base: {},\n        initFns: [],\n        staticProperties: staticProperties ? lang_1.assign({}, staticProperties) : undefined\n    });\n    if (initFunction) {\n        factoryData.initFns.push(initFunction);\n    }\n    if (optionsAdvice) {\n        factoryData.advice = assignAdviceMap(factoryData.advice, optionsAdvice);\n    }\n    assignProperties(Boolean(overwrite), factoryData.base, proto);\n    return factoryData;\n}\nfunction createFactory(options) {\n    /**\n     * A compose factory\n     */\n    function factory() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (this && this.constructor === factory) {\n            throw new SyntaxError('Factories cannot be called with \"new\".');\n        }\n        var instance = objectCreate(factory.prototype);\n        /* clone any arrays in the instance */\n        for (var key in instance) {\n            if (isArray(Object.getOwnPropertyDescriptor(factory.prototype, key).value)) {\n                instance[key] = array_1.from(instance[key]);\n            }\n        }\n        args.unshift(instance);\n        privateFactoryData.get(factory).initFns.forEach(function (fn) {\n            fn.apply(null, args);\n        });\n        return instance;\n    }\n    var factoryData = createPrivateFactoryData(options);\n    privateFactoryData.set(factory, factoryData);\n    var factoryPrototype = factory.prototype;\n    /* mixin base properties into the prototype */\n    assignProperties(false, factoryPrototype, factoryData.base);\n    /* apply any advice to the prototype */\n    if (factoryData.advice) {\n        var _loop_1 = function (method) {\n            factoryData.advice[method].forEach(function (_a) {\n                var aspect = _a[0], advice = _a[1];\n                var sourceMethod = factoryPrototype[method] || missingMethod(method);\n                switch (aspect) {\n                    case 'before':\n                        factoryPrototype[method] = aspect_1.before(sourceMethod, advice);\n                        break;\n                    case 'after':\n                        factoryPrototype[method] = aspect_1.after(sourceMethod, advice);\n                        break;\n                    case 'around':\n                        factoryPrototype[method] = aspect_1.around(sourceMethod, advice);\n                }\n            });\n        };\n        for (var method in factoryData.advice) {\n            _loop_1(method);\n        }\n    }\n    /* assign a constructor to the prototype */\n    factoryPrototype.constructor = factory;\n    /* assign static methods/properties */\n    lang_1.assign(factory, staticMethods, factoryData.staticProperties);\n    /* assign factory name */\n    var className = options.className ||\n        (options.factories && options.factories[0] && options.factories[0].name) ||\n        DEFAULT_FACTORY_LABEL;\n    assignFactoryName(factory, className);\n    /* freeze the factory, so it cannot be accidently modified */\n    Object.freeze(factory);\n    return factory;\n}\n/**\n * A custom type guard that determines if the value is a ComposeFactory\n *\n * @param   value The target to check\n * @returns       Return true if it is a ComposeFactory, otherwise false\n */\nfunction isComposeFactory(value) {\n    return Boolean(value && privateFactoryData.get(value));\n}\nexports.isComposeFactory = isComposeFactory;\nfunction extend(base, className, extension) {\n    instrument_1.deprecated({ message: 'This function will be removed, use \"override\" instead.', name: 'extend' });\n    if (typeof className !== 'string') {\n        extension = className;\n        className = undefined;\n    }\n    return createFactory({\n        className: className,\n        proto: typeof extension === 'function' ? extension.prototype : extension,\n        factories: [base]\n    });\n}\nfunction override(baseFactory, className, properties) {\n    if (typeof className !== 'string') {\n        properties = className;\n        className = undefined;\n    }\n    if (typeof properties !== 'object') {\n        throw new TypeError('Argument \"properties\" must be an object.');\n    }\n    var base = privateFactoryData.get(baseFactory).base;\n    /* TODO: In TypeScript 2.1 we have merge types which can then be used to provide type checking at design time\n     * similiar to this */\n    Object.keys(properties).forEach(function (key) {\n        if (!(key in base)) {\n            throw new TypeError(\"Attempting to override missing property \\\"\" + key + \"\\\"\");\n        }\n    });\n    return createFactory({\n        className: className,\n        overwrite: true,\n        proto: properties,\n        factories: [baseFactory]\n    });\n}\n/**\n * Internal implementation of the overlay functionality, to allow a function to modify a\n * compose factory prototype\n *\n * @param base The target compose factory\n * @param overlayFunction The callback function that will modify the prototype of the factory\n */\nfunction overlay(base, overlayFunction) {\n    var factory = createFactory({\n        factories: [base]\n    });\n    overlayFunction(factory.prototype);\n    return factory;\n}\n/**\n * Internal function that converts `AspectAdvice` into `AdviceMap` which can then be used for\n * creating a factory\n *\n * @param aspectAdvice The aspect advice to convert into an advice map\n */\nfunction aspectAdviceToAdviceMap(aspectAdvice) {\n    if (!aspectAdvice) {\n        return;\n    }\n    var adviceMap = {};\n    var beforeAdvice = aspectAdvice.before;\n    var afterAdvice = aspectAdvice.after;\n    var aroundAdvice = aspectAdvice.around;\n    function mapAdvice(type, key, advice) {\n        var adviceTuple = [type, advice[key]];\n        if (adviceMap[key]) {\n            adviceMap[key].push(adviceTuple);\n        }\n        else {\n            adviceMap[key] = [adviceTuple];\n        }\n    }\n    if (beforeAdvice) {\n        objectKeys(beforeAdvice).forEach(function (key) {\n            /* TODO: Remove ! in 2.1 */\n            mapAdvice('before', key, beforeAdvice);\n        });\n    }\n    if (afterAdvice) {\n        objectKeys(afterAdvice).forEach(function (key) {\n            /* TODO: Remove ! in 2.1 */\n            mapAdvice('after', key, afterAdvice);\n        });\n    }\n    if (aroundAdvice) {\n        objectKeys(aroundAdvice).forEach(function (key) {\n            /* TODO: Remove ! in 2.1 */\n            mapAdvice('around', key, aroundAdvice);\n        });\n    }\n    return adviceMap;\n}\n/**\n * A custom type guard that determines if a value is ComposeMixinable\n *\n * @param value The value to guard for\n */\nfunction isComposeMixinable(value) {\n    return Boolean(value && 'factoryDescriptor' in value && typeof value.factoryDescriptor === 'function');\n}\n/**\n * The internal implementation of mixin in values into a compose factory\n *\n * @param base The base compose factory that is the target for being mixed in\n * @param toMixin The value to be mixed in\n */\nfunction mixin(base, toMixin) {\n    /* ensure we are dealing with a mixinDescriptor */\n    var mixinDescriptor = isComposeMixinable(toMixin) ? toMixin.factoryDescriptor() : toMixin;\n    /* destructure out most of the factory creation options */\n    var mixin = mixinDescriptor.mixin, initFunction = mixinDescriptor.initialize, aspectAdvice = mixinDescriptor.aspectAdvice, className = mixinDescriptor.className;\n    /* we will at least be using the base factory to create the new one */\n    var factories = [base];\n    var proto;\n    /* if mixin is a compose factory, we will pass it as a factory used to create the new factory */\n    if (isComposeFactory(mixin)) {\n        factories.push(mixin);\n    }\n    else {\n        /* of which, we can have a constructor function/class, or an object literal (or undefined) */\n        proto = typeof mixin === 'function' ? mixin.prototype : mixin;\n    }\n    /* convert the advice, if any, to the format used by createFactory */\n    var advice = aspectAdviceToAdviceMap(aspectAdvice);\n    /* label the initFn */\n    if (initFunction) {\n        assignFunctionName(initFunction, \"mixin\" + (className || (isComposeFactory(mixin) && mixin.name) || base.name));\n    }\n    /* return the newly created factory */\n    return createFactory({\n        advice: advice,\n        factories: factories,\n        initFunction: initFunction,\n        className: className,\n        proto: proto\n    });\n}\n/**\n * Internal implementation of extracting methods from another object\n *\n * @param base The target that the method should be extracted from\n * @param method The name of the method\n */\nfunction from(base, method) {\n    return base.prototype[method];\n}\n/**\n * Internal implementation to apply from when `this` represents the base\n *\n * @param base The target that the method should be extracted from\n * @param method The name of the method\n */\nfunction doFrom(base, method) {\n    return createFactory({\n        factories: [this],\n        proto: (_a = {},\n            _a[method] = base.prototype[method],\n            _a)\n    });\n    var _a;\n}\nfunction before() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var base;\n    var method;\n    var advice;\n    if (args.length >= 3) {\n        base = args[0], method = args[1], advice = args[2];\n        method = base.prototype[method];\n    }\n    else {\n        method = args[0], advice = args[1];\n    }\n    return aspect_1.before(method, advice);\n}\n/**\n * The internal implementation to apply before advice when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction doBefore(method, advice) {\n    return createFactory({\n        factories: [this],\n        advice: (_a = {},\n            _a[method] = [['before', advice]],\n            _a)\n    });\n    var _a;\n}\nfunction after() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var base;\n    var method;\n    var advice;\n    if (args.length >= 3) {\n        base = args[0], method = args[1], advice = args[2];\n        method = base.prototype[method];\n    }\n    else {\n        method = args[0], advice = args[1];\n    }\n    return aspect_1.after(method, advice);\n}\n/**\n * The internal implementation to apply after advice when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction doAfter(method, advice) {\n    return createFactory({\n        factories: [this],\n        advice: (_a = {},\n            _a[method] = [['after', advice]],\n            _a)\n    });\n    var _a;\n}\nfunction around() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var base;\n    var method;\n    var advice;\n    if (args.length >= 3) {\n        base = args[0], method = args[1], advice = args[2];\n        method = base.prototype[method];\n    }\n    else {\n        method = args[0], advice = args[1];\n    }\n    return aspect_1.around(method, advice);\n}\n/**\n * The internal implementation to apply around advice when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction doAround(method, advice) {\n    return createFactory({\n        factories: [this],\n        advice: (_a = {},\n            _a[method] = [['around', advice]],\n            _a)\n    });\n    var _a;\n}\n/**\n * The internal implementation of applying aspect advice to a factory\n *\n * @param base The base factory the advice should be applied to\n * @param advice The advice map to apply to the factory\n */\nfunction aspect(base, advice) {\n    return createFactory({\n        factories: [base],\n        advice: aspectAdviceToAdviceMap(advice)\n    });\n}\nfunction create(className, base, initFunction) {\n    /* disambugate arguments */\n    if (typeof className !== 'string') {\n        initFunction = base;\n        base = className;\n        className = undefined;\n    }\n    /* Label the initFunction */\n    if (initFunction && className) {\n        assignFunctionName(initFunction, \"init\" + className);\n    }\n    var factories;\n    var proto;\n    /* If base is a compose factory, set it as the factory array */\n    if (base && isComposeFactory(base)) {\n        factories = [base];\n    }\n    else {\n        proto = typeof base === 'function' ? base.prototype : base;\n    }\n    return createFactory({\n        className: className,\n        factories: factories,\n        initFunction: initFunction,\n        proto: proto\n    });\n}\n/**\n * Internal implementation of applying static properties to a compose factory\n *\n * @param factory The factory that the static properties should be applied to\n * @param staticProperties The properties to be applied to the factory\n */\nfunction _static(base, staticProperties) {\n    return createFactory({\n        factories: [base],\n        staticProperties: staticProperties\n    });\n}\n/**\n * A factory construction utility\n *\n * @param base An ES6 Class, ComposeFactory or Object literal to use as the base for the new factory\n * @param initFunction An optional initialization function for the factory\n */\nvar compose = create;\n/* Add static methods to compose */\nlang_1.assign(compose, {\n    create: create,\n    static: _static,\n    extend: extend,\n    mixin: mixin,\n    override: override,\n    overlay: overlay,\n    from: from,\n    before: before,\n    after: after,\n    around: around,\n    aspect: aspect\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = compose;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/compose/compose.js\n// module id = 6\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./has\");\n/**\n * The default message to warn when no other is provided\n */\nvar DEFAULT_DEPRECATED_MESSAGE = 'This function will be removed in future versions.';\n/**\n * When set, globalWarn will be used instead of `console.warn`\n */\nvar globalWarn;\n/**\n * A function that will console warn that a function has been deprecated\n *\n * @param options Provide options which change the display of the message\n */\nfunction deprecated(_a) {\n    var _b = _a === void 0 ? {} : _a, message = _b.message, name = _b.name, warn = _b.warn, url = _b.url;\n    /* istanbul ignore else: testing with debug off is difficult */\n    if (has_1.default('debug')) {\n        message = message || DEFAULT_DEPRECATED_MESSAGE;\n        var warning = \"DEPRECATED: \" + (name ? name + ': ' : '') + message;\n        if (url) {\n            warning += \"\\n\\n    See \" + url + \" for more details.\\n\\n\";\n        }\n        if (warn) {\n            warn(warning);\n        }\n        else if (globalWarn) {\n            globalWarn(warning);\n        }\n        else {\n            console.warn(warning);\n        }\n    }\n}\nexports.deprecated = deprecated;\n/**\n * A function that generates before advice that can be used to warn when an API has been deprecated\n *\n * @param options Provide options which change the display of the message\n */\nfunction deprecatedAdvice(options) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        deprecated(options);\n        return args;\n    };\n}\nexports.deprecatedAdvice = deprecatedAdvice;\n/**\n * A method decorator that will console warn when a method if invoked that is deprecated\n *\n * @param options Provide options which change the display of the message\n */\nfunction deprecatedDecorator(options) {\n    return function (target, propertyKey, descriptor) {\n        if (has_1.default('debug')) {\n            var originalFn_1 = descriptor.value;\n            options = options || {};\n            /* IE 10/11 don't have the name property on functions */\n            options.name = target.constructor.name ? target.constructor.name + \"#\" + propertyKey : propertyKey;\n            descriptor.value = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                deprecated(options);\n                return originalFn_1.apply(target, args);\n            };\n        }\n        return descriptor;\n    };\n}\nexports.deprecatedDecorator = deprecatedDecorator;\n/**\n * A function that will set the warn function that will be used instead of `console.warn` when\n * logging warning messages\n *\n * @param warn The function (or `undefined`) to use instead of `console.warn`\n */\nfunction setWarn(warn) {\n    globalWarn = warn;\n}\nexports.setWarn = setWarn;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/instrument.js\n// module id = 7\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar global_1 = require(\"./global\");\nvar has_1 = require(\"@dojo/shim/support/has\");\n__export(require(\"@dojo/shim/support/has\"));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = has_1.default;\nhas_1.add('object-assign', typeof global_1.default.Object.assign === 'function');\nhas_1.add('raf', typeof requestAnimationFrame === 'function');\nhas_1.add('arraybuffer', typeof global_1.default.ArrayBuffer !== 'undefined');\nhas_1.add('formdata', typeof global_1.default.FormData !== 'undefined');\nhas_1.add('xhr', typeof global_1.default.XMLHttpRequest !== 'undefined');\nhas_1.add('xhr2', has_1.default('xhr') && 'responseType' in global_1.default.XMLHttpRequest.prototype);\nhas_1.add('xhr2-blob', function () {\n    if (!has_1.default('xhr2')) {\n        return false;\n    }\n    var request = new XMLHttpRequest();\n    request.open('GET', '/', true);\n    request.responseType = 'blob';\n    request.abort();\n    return request.responseType === 'blob';\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/has.js\n// module id = 8\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar global_1 = require(\"./global\");\nvar has_1 = require(\"@dojo/has/has\");\nvar has_2 = require(\"@dojo/has/has\");\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = has_1.default;\n__export(require(\"@dojo/has/has\"));\n/* ECMAScript 6 and 7 Features */\n/*\n * Determine whether or not native Symbol exists. If it doesn't, we don't want to use\n * a few other native implementations like Map, WeakMap, Set.  Consider a polyfill that provides Symbol,\n * Map, etc in the global namespace. If the polyfill's Symbol is not compatible with our Symbol, neither\n * will be anything that uses their iterator symbol, like Map, Set, etc.\n */\n/* Symbol */\nhas_2.add('es6-symbol', typeof global_1.default.Symbol !== 'undefined' && typeof Symbol() === 'symbol');\n/* Object */\nhas_2.add('es6-object-assign', typeof Object.assign === 'function');\n/* Array */\nhas_2.add('es6-array-from', 'from' in global_1.default.Array);\nhas_2.add('es6-array-of', 'of' in global_1.default.Array);\nhas_2.add('es6-array-fill', function () {\n    if ('fill' in global_1.default.Array.prototype) {\n        /* Some versions of Safari do not properly implement this */\n        return [1].fill(9, Number.POSITIVE_INFINITY)[0] === 1;\n    }\n    return false;\n});\nhas_2.add('es6-array-findindex', 'findIndex' in global_1.default.Array.prototype);\nhas_2.add('es6-array-find', 'find' in global_1.default.Array.prototype);\nhas_2.add('es6-array-copywithin', 'copyWithin' in global_1.default.Array.prototype);\nhas_2.add('es7-array-includes', 'includes' in global_1.default.Array.prototype);\n/* String */\nhas_2.add('es6-string-raw', function () {\n    function getCallSite(callSite) {\n        var substitutions = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            substitutions[_i - 1] = arguments[_i];\n        }\n        return callSite;\n    }\n    if ('raw' in global_1.default.String) {\n        var b = 1;\n        var callSite = (_a = [\"a\\n\", \"\"], _a.raw = [\"a\\\\n\", \"\"], getCallSite(_a, b));\n        callSite.raw = ['a\\\\n'];\n        var supportsTrunc = global_1.default.String.raw(callSite, 42) === 'a:\\\\n';\n        return supportsTrunc;\n    }\n    return false;\n    var _a;\n});\nhas_2.add('es6-string-fromcodepoint', 'fromCodePoint' in global_1.default.String);\nhas_2.add('es6-string-codepointat', 'codePointAt' in global_1.default.String.prototype);\nhas_2.add('es6-string-normalize', 'normalize' in global_1.default.String.prototype);\nhas_2.add('es6-string-repeat', 'repeat' in global_1.default.String.prototype);\nhas_2.add('es6-string-startswith', 'startsWith' in global_1.default.String.prototype);\nhas_2.add('es6-string-endswith', 'endsWith' in global_1.default.String.prototype);\nhas_2.add('es6-string-includes', 'includes' in global_1.default.String.prototype);\nhas_2.add('es6-string-padstart', 'padStart' in global_1.default.String.prototype);\nhas_2.add('es6-string-padend', 'padEnd' in global_1.default.String.prototype);\n/* Math */\nhas_2.add('es6-math-acosh', typeof global_1.default.Math.acosh === 'function');\nhas_2.add('es6-math-clz32', typeof global_1.default.Math.clz32 === 'function');\nhas_2.add('es6-math-imul', function () {\n    if ('imul' in global_1.default.Math) {\n        /* Some versions of Safari on ios do not properly implement this */\n        return Math.imul(0xffffffff, 5) === -5;\n    }\n    return false;\n});\n/* Promise */\nhas_2.add('es6-promise', typeof global_1.default.Promise !== 'undefined' && has_1.default('es6-symbol'));\n/* Observable */\nhas_2.add('es-observable', typeof global_1.default.Observable !== 'undefined');\n/* Set */\nhas_2.add('es6-set', function () {\n    if (typeof global_1.default.Set === 'function') {\n        /* IE11 and older versions of Safari are missing critical ES6 Set functionality */\n        var set = new global_1.default.Set([1]);\n        return set.has(1) && 'keys' in set && typeof set.keys === 'function' && has_1.default('es6-symbol');\n    }\n    return false;\n});\n/* Map */\nhas_2.add('es6-map', function () {\n    if (typeof global_1.default.Map === 'function') {\n        /*\n        IE11 and older versions of Safari are missing critical ES6 Map functionality\n        We wrap this in a try/catch because sometimes the Map constructor exists, but does not\n        take arguments (iOS 8.4)\n         */\n        try {\n            var map = new global_1.default.Map([[0, 1]]);\n            return map.has(0) &&\n                typeof map.keys === 'function' && has_1.default('es6-symbol') &&\n                typeof map.values === 'function' &&\n                typeof map.entries === 'function';\n        }\n        catch (e) {\n            /* istanbul ignore next: not testing on iOS at the moment */\n            return false;\n        }\n    }\n    return false;\n});\n/* WeakMap */\nhas_2.add('es6-weakmap', function () {\n    if (typeof global_1.default.WeakMap !== 'undefined') {\n        /* IE11 and older versions of Safari are missing critical ES6 Map functionality */\n        var key1 = {};\n        var key2 = {};\n        var map = new global_1.default.WeakMap([[key1, 1]]);\n        Object.freeze(key1);\n        return map.get(key1) === 1 && map.set(key2, 2) === map && has_1.default('es6-symbol');\n    }\n    return false;\n});\n/* Miscellaneous features */\nhas_2.add('float32array', 'Float32Array' in global_1.default);\nhas_2.add('setimmediate', typeof global_1.default.setImmediate !== 'undefined');\nhas_2.add('postmessage', typeof postMessage === 'function');\nhas_2.add('microtasks', function () { return has_1.default('es6-promise') || has_1.default('host-node') || has_1.default('dom-mutationobserver'); });\n/* DOM Features */\nhas_2.add('dom-mutationobserver', function () { return has_1.default('host-browser') && Boolean(global_1.default.MutationObserver || global_1.default.WebKitMutationObserver); });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/support/has.js\n// module id = 9\n// module chunks = 0","\"use strict\";\nvar globalObject = (typeof global === 'undefined') ? Function('return this')() : global;\n// global spec defines a reference to the global object called 'global'\n// https://github.com/tc39/proposal-global\nif (!('global' in globalObject)) {\n    globalObject.global = globalObject;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = globalObject;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/support/global.js\n// module id = 10\n// module chunks = 0","\"use strict\";\nfunction isFeatureTestThenable(value) {\n    return value && value.then;\n}\n/**\n * A cache of results of feature tests\n */\nexports.testCache = {};\n/**\n * A cache of the un-resolved feature tests\n */\nexports.testFunctions = {};\n/**\n * A cache of unresolved thenables (probably promises)\n * @type {{}}\n */\nvar testThenables = {};\n/**\n * A reference to the global scope (`window` in a browser, `global` in NodeJS)\n */\nvar globalScope = (function () {\n    /* istanbul ignore else */\n    if (typeof window !== 'undefined') {\n        // Browsers\n        return window;\n    }\n    else if (typeof global !== 'undefined') {\n        // Node\n        return global;\n    }\n    else if (typeof self !== 'undefined') {\n        // Web workers\n        return self;\n    }\n    /* istanbul ignore next */\n    return {};\n})();\n/* Grab the staticFeatures if there are available */\nvar staticFeatures = (globalScope.DojoHasEnvironment || {}).staticFeatures;\n/* Cleaning up the DojoHasEnviornment */\nif ('DojoHasEnvironment' in globalScope) {\n    delete globalScope.DojoHasEnvironment;\n}\n/**\n * Custom type guard to narrow the `staticFeatures` to either a map or a function that\n * returns a map.\n *\n * @param value The value to guard for\n */\nfunction isStaticFeatureFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * The cache of asserted features that were available in the global scope when the\n * module loaded\n */\nvar staticCache = staticFeatures\n    ? isStaticFeatureFunction(staticFeatures)\n        ? staticFeatures.apply(globalScope)\n        : staticFeatures\n    : {};/* Providing an empty cache, if none was in the environment\n\n/**\n* AMD plugin function.\n*\n* Conditional loads modules based on a has feature test value.\n*\n* @param resourceId Gives the resolved module id to load.\n* @param require The loader require function with respect to the module that contained the plugin resource in its\n*                dependency list.\n* @param load Callback to loader that consumes result of plugin demand.\n*/\nfunction load(resourceId, require, load, config) {\n    resourceId ? require([resourceId], load) : load();\n}\nexports.load = load;\n/**\n * AMD plugin function.\n *\n * Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test\n * value(s).\n *\n * @param resourceId The id of the module\n * @param normalize Resolves a relative module id into an absolute module id\n */\nfunction normalize(resourceId, normalize) {\n    var tokens = resourceId.match(/[\\?:]|[^:\\?]*/g) || [];\n    var i = 0;\n    function get(skip) {\n        var term = tokens[i++];\n        if (term === ':') {\n            // empty string module name, resolves to null\n            return null;\n        }\n        else {\n            // postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n            if (tokens[i++] === '?') {\n                if (!skip && has(term)) {\n                    // matched the feature, get the first value from the options\n                    return get();\n                }\n                else {\n                    // did not match, get the second value, passing over the first\n                    get(true);\n                    return get(skip);\n                }\n            }\n            // a module\n            return term;\n        }\n    }\n    var id = get();\n    return id && normalize(id);\n}\nexports.normalize = normalize;\n/**\n * Check if a feature has already been registered\n *\n * @param feature the name of the feature\n */\nfunction exists(feature) {\n    var normalizedFeature = feature.toLowerCase();\n    return Boolean(normalizedFeature in staticCache || normalizedFeature in exports.testCache || exports.testFunctions[normalizedFeature]);\n}\nexports.exists = exists;\n/**\n * Register a new test for a named feature.\n *\n * @example\n * has.add('dom-addeventlistener', !!document.addEventListener);\n *\n * @example\n * has.add('touch-events', function () {\n *    return 'ontouchstart' in document\n * });\n *\n * @param feature the name of the feature\n * @param value the value reported of the feature, or a function that will be executed once on first test\n * @param overwrite if an existing value should be overwritten. Defaults to false.\n */\nfunction add(feature, value, overwrite) {\n    if (overwrite === void 0) { overwrite = false; }\n    var normalizedFeature = feature.toLowerCase();\n    if (exists(normalizedFeature) && !overwrite && !(normalizedFeature in staticCache)) {\n        throw new TypeError(\"Feature \\\"\" + feature + \"\\\" exists and overwrite not true.\");\n    }\n    if (typeof value === 'function') {\n        exports.testFunctions[normalizedFeature] = value;\n    }\n    else if (isFeatureTestThenable(value)) {\n        testThenables[feature] = value.then(function (resolvedValue) {\n            exports.testCache[feature] = resolvedValue;\n            delete testThenables[feature];\n        }, function () {\n            delete testThenables[feature];\n        });\n    }\n    else {\n        exports.testCache[normalizedFeature] = value;\n        delete exports.testFunctions[normalizedFeature];\n    }\n}\nexports.add = add;\n/**\n * Return the current value of a named feature.\n *\n * @param feature The name (if a string) or identifier (if an integer) of the feature to test.\n */\nfunction has(feature) {\n    var result;\n    var normalizedFeature = feature.toLowerCase();\n    if (normalizedFeature in staticCache) {\n        result = staticCache[normalizedFeature];\n    }\n    else if (exports.testFunctions[normalizedFeature]) {\n        result = exports.testCache[normalizedFeature] = exports.testFunctions[normalizedFeature].call(null);\n        delete exports.testFunctions[normalizedFeature];\n    }\n    else if (normalizedFeature in exports.testCache) {\n        result = exports.testCache[normalizedFeature];\n    }\n    else if (feature in testThenables) {\n        return false;\n    }\n    else {\n        throw new TypeError(\"Attempt to detect unregistered has feature \\\"\" + feature + \"\\\"\");\n    }\n    return result;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = has;\n/*\n * Out of the box feature tests\n */\n/* Environments */\n/* Used as a value to provide a debug only code path */\nadd('debug', true);\n/* Detects if the environment is \"browser like\" */\nadd('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');\n/* Detects if the environment appears to be NodeJS */\nadd('host-node', function () {\n    if (typeof process === 'object' && process.versions && process.versions.node) {\n        return process.versions.node;\n    }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/has/has.js\n// module id = 11\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 12\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./has\");\nvar slice = Array.prototype.slice;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Type guard that ensures that the value can be coerced to Object\n * to weed out host objects that do not derive from Object.\n * This function is used to check if we want to deep copy an object or not.\n * Note: In ES6 it is possible to modify an object's Symbol.toStringTag property, which will\n * change the value returned by `toString`. This is a rare edge case that is difficult to handle,\n * so it is not handled here.\n * @param  value The value to check\n * @return       If the value is coercible into an Object\n */\nfunction shouldDeepCopyObject(value) {\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\nfunction copyArray(array, inherited) {\n    return array.map(function (item) {\n        if (Array.isArray(item)) {\n            return copyArray(item, inherited);\n        }\n        return !shouldDeepCopyObject(item) ?\n            item :\n            _mixin({\n                deep: true,\n                inherited: inherited,\n                sources: [item],\n                target: {}\n            });\n    });\n}\nfunction _mixin(kwArgs) {\n    var deep = kwArgs.deep;\n    var inherited = kwArgs.inherited;\n    var target = kwArgs.target;\n    for (var _i = 0, _a = kwArgs.sources; _i < _a.length; _i++) {\n        var source = _a[_i];\n        if (source === null || source === undefined) {\n            continue;\n        }\n        for (var key in source) {\n            if (inherited || hasOwnProperty.call(source, key)) {\n                var value = source[key];\n                if (deep) {\n                    if (Array.isArray(value)) {\n                        value = copyArray(value, inherited);\n                    }\n                    else if (shouldDeepCopyObject(value)) {\n                        value = _mixin({\n                            deep: true,\n                            inherited: inherited,\n                            sources: [value],\n                            target: {}\n                        });\n                    }\n                }\n                target[key] = value;\n            }\n        }\n    }\n    return target;\n}\n/**\n * Copies the values of all enumerable own properties of one or more source objects to the target object.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable own properties will be copied to the target object\n * @return The modified target object\n */\nexports.assign = has_1.default('object-assign') ?\n    Object.assign :\n    function (target) {\n        var sources = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            sources[_i - 1] = arguments[_i];\n        }\n        return _mixin({\n            deep: false,\n            inherited: false,\n            sources: sources,\n            target: target\n        });\n    };\nfunction create(prototype) {\n    var mixins = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        mixins[_i - 1] = arguments[_i];\n    }\n    if (!mixins.length) {\n        throw new RangeError('lang.create requires at least one mixin object.');\n    }\n    var args = mixins.slice();\n    args.unshift(Object.create(prototype));\n    return exports.assign.apply(null, args);\n}\nexports.create = create;\nfunction deepAssign(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    return _mixin({\n        deep: true,\n        inherited: false,\n        sources: sources,\n        target: target\n    });\n}\nexports.deepAssign = deepAssign;\nfunction deepMixin(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    return _mixin({\n        deep: true,\n        inherited: true,\n        sources: sources,\n        target: target\n    });\n}\nexports.deepMixin = deepMixin;\n/**\n * Creates a new object using the provided source's prototype as the prototype for the new object, and then\n * deep copies the provided source's values into the new target.\n *\n * @param source The object to duplicate\n * @return The new object\n */\nfunction duplicate(source) {\n    var target = Object.create(Object.getPrototypeOf(source));\n    return deepMixin(target, source);\n}\nexports.duplicate = duplicate;\n/**\n * Determines whether two values are the same value.\n *\n * @param a First value to compare\n * @param b Second value to compare\n * @return true if the values are the same; false otherwise\n */\nfunction isIdentical(a, b) {\n    return a === b ||\n        /* both values are NaN */\n        (a !== a && b !== b);\n}\nexports.isIdentical = isIdentical;\n/**\n * Returns a function that binds a method to the specified object at runtime. This is similar to\n * `Function.prototype.bind`, but instead of a function it takes the name of a method on an object.\n * As a result, the function returned by `lateBind` will always call the function currently assigned to\n * the specified property on the object as of the moment the function it returns is called.\n *\n * @param instance The context object\n * @param method The name of the method on the context object to bind to itself\n * @param suppliedArgs An optional array of values to prepend to the `instance[method]` arguments list\n * @return The bound function\n */\nfunction lateBind(instance, method) {\n    var suppliedArgs = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        suppliedArgs[_i - 2] = arguments[_i];\n    }\n    return suppliedArgs.length ?\n        function () {\n            var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n            // TS7017\n            return instance[method].apply(instance, args);\n        } :\n        function () {\n            // TS7017\n            return instance[method].apply(instance, arguments);\n        };\n}\nexports.lateBind = lateBind;\nfunction mixin(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    return _mixin({\n        deep: false,\n        inherited: true,\n        sources: sources,\n        target: target\n    });\n}\nexports.mixin = mixin;\n/**\n * Returns a function which invokes the given function with the given arguments prepended to its argument list.\n * Like `Function.prototype.bind`, but does not alter execution context.\n *\n * @param targetFunction The function that needs to be bound\n * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list\n * @return The bound function\n */\nfunction partial(targetFunction) {\n    var suppliedArgs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        suppliedArgs[_i - 1] = arguments[_i];\n    }\n    return function () {\n        var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n        return targetFunction.apply(this, args);\n    };\n}\nexports.partial = partial;\n/**\n * Returns an object with a destroy method that, when called, calls the passed-in destructor.\n * This is intended to provide a unified interface for creating \"remove\" / \"destroy\" handlers for\n * event listeners, timers, etc.\n *\n * @param destructor A function that will be called when the handle's `destroy` method is invoked\n * @return The handle object\n */\nfunction createHandle(destructor) {\n    return {\n        destroy: function () {\n            this.destroy = function () { };\n            destructor.call(this);\n        }\n    };\n}\nexports.createHandle = createHandle;\n/**\n * Returns a single handle that can be used to destroy multiple handles simultaneously.\n *\n * @param handles An array of handles with `destroy` methods\n * @return The handle object\n */\nfunction createCompositeHandle() {\n    var handles = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        handles[_i] = arguments[_i];\n    }\n    return createHandle(function () {\n        for (var _i = 0, handles_1 = handles; _i < handles_1.length; _i++) {\n            var handle = handles_1[_i];\n            handle.destroy();\n        }\n    });\n}\nexports.createCompositeHandle = createCompositeHandle;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/lang.js\n// module id = 13\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./support/has\");\nvar util_1 = require(\"./support/util\");\nvar iterator_1 = require(\"./iterator\");\nvar number_1 = require(\"./number\");\n/**\n * Ensures a non-negative, non-infinite, safe integer.\n *\n * @param length The number to validate\n * @return A proper length\n */\nfunction toLength(length) {\n    length = Number(length);\n    if (isNaN(length)) {\n        return 0;\n    }\n    if (isFinite(length)) {\n        length = Math.floor(length);\n    }\n    // Ensure a non-negative, real, safe integer\n    return Math.min(Math.max(length, 0), number_1.MAX_SAFE_INTEGER);\n}\n/**\n * From ES6 7.1.4 ToInteger()\n *\n * @param value A value to convert\n * @return An integer\n */\nfunction toInteger(value) {\n    value = Number(value);\n    if (isNaN(value)) {\n        return 0;\n    }\n    if (value === 0 || !isFinite(value)) {\n        return value;\n    }\n    return (value > 0 ? 1 : -1) * Math.floor(Math.abs(value));\n}\n/**\n * Normalizes an offset against a given length, wrapping it if negative.\n *\n * @param value The original offset\n * @param length The total length to normalize against\n * @return If negative, provide a distance from the end (length); otherwise provide a distance from 0\n */\nfunction normalizeOffset(value, length) {\n    return value < 0 ? Math.max(length + value, 0) : Math.min(value, length);\n}\n/**\n * A namespace that contains the polyfilled functionality that is then exported below, depending on if\n * the functionality is required or not.\n */\nvar Shim;\n(function (Shim) {\n    function from(arrayLike, mapFunction, thisArg) {\n        if (arrayLike == null) {\n            throw new TypeError('from: requires an array-like object');\n        }\n        if (mapFunction && thisArg) {\n            mapFunction = mapFunction.bind(thisArg);\n        }\n        /* tslint:disable-next-line:variable-name */\n        var Constructor = this;\n        var length = toLength(arrayLike.length);\n        // Support extension\n        var array = (typeof Constructor === 'function') ? Object(new Constructor(length)) : new Array(length);\n        if (!iterator_1.isArrayLike(arrayLike) && !iterator_1.isIterable(arrayLike)) {\n            return array;\n        }\n        var i = 0;\n        iterator_1.forOf(arrayLike, function (value) {\n            array[i] = mapFunction ? mapFunction(value, i) : value;\n            i++;\n        });\n        if (arrayLike.length !== undefined) {\n            array.length = length;\n        }\n        return array;\n    }\n    Shim.from = from;\n    function of() {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        return Array.prototype.slice.call(items);\n    }\n    Shim.of = of;\n    function copyWithin(target, offset, start, end) {\n        if (target == null) {\n            throw new TypeError('copyWithin: target must be an array-like object');\n        }\n        var length = toLength(target.length);\n        offset = normalizeOffset(toInteger(offset), length);\n        start = normalizeOffset(toInteger(start), length);\n        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n        var count = Math.min(end - start, length - offset);\n        var direction = 1;\n        if (offset > start && offset < (start + count)) {\n            direction = -1;\n            start += count - 1;\n            offset += count - 1;\n        }\n        while (count > 0) {\n            if (start in target) {\n                target[offset] = target[start];\n            }\n            else {\n                delete target[offset];\n            }\n            offset += direction;\n            start += direction;\n            count--;\n        }\n        return target;\n    }\n    Shim.copyWithin = copyWithin;\n    function fill(target, value, start, end) {\n        var length = toLength(target.length);\n        var i = normalizeOffset(toInteger(start), length);\n        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n        while (i < end) {\n            target[i++] = value;\n        }\n        return target;\n    }\n    Shim.fill = fill;\n    function find(target, callback, thisArg) {\n        var index = findIndex(target, callback, thisArg);\n        return index !== -1 ? target[index] : undefined;\n    }\n    Shim.find = find;\n    function findIndex(target, callback, thisArg) {\n        var length = toLength(target.length);\n        if (!callback) {\n            throw new TypeError('find: second argument must be a function');\n        }\n        if (thisArg) {\n            callback = callback.bind(thisArg);\n        }\n        for (var i = 0; i < length; i++) {\n            if (callback(target[i], i, target)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    Shim.findIndex = findIndex;\n    function includes(target, searchElement, fromIndex) {\n        if (fromIndex === void 0) { fromIndex = 0; }\n        var len = toLength(target.length);\n        for (var i = fromIndex; i < len; ++i) {\n            var currentElement = target[i];\n            if (searchElement === currentElement ||\n                (searchElement !== searchElement && currentElement !== currentElement)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Shim.includes = includes;\n})(Shim = exports.Shim || (exports.Shim = {}));\nexports.from = has_1.default('es6-array-from')\n    ? Array.from\n    : Shim.from;\n/**\n * Creates a new array from the function parameters.\n *\n * @param arguments Any number of arguments for the array\n * @return An array from the given arguments\n */\nexports.of = has_1.default('es6-array-of')\n    ? Array.of\n    : Shim.of;\n/* ES6 Array instance methods */\n/**\n * Copies data internally within an array or array-like object.\n *\n * @param target The target array-like object\n * @param offset The index to start copying values to; if negative, it counts backwards from length\n * @param start The first (inclusive) index to copy; if negative, it counts backwards from length\n * @param end The last (exclusive) index to copy; if negative, it counts backwards from length\n * @return The target\n */\nexports.copyWithin = has_1.default('es6-array-copywithin')\n    ? util_1.wrapNative(Array.prototype.copyWithin)\n    : Shim.copyWithin;\n/**\n * Fills elements of an array-like object with the specified value.\n *\n * @param target The target to fill\n * @param value The value to fill each element of the target with\n * @param start The first index to fill\n * @param end The (exclusive) index at which to stop filling\n * @return The filled target\n */\nexports.fill = has_1.default('es6-array-fill')\n    ? util_1.wrapNative(Array.prototype.fill)\n    : Shim.fill;\n/**\n * Finds and returns the first instance matching the callback or undefined if one is not found.\n *\n * @param target An array-like object\n * @param callback A function returning if the current value matches a criteria\n * @param [thisArg] The execution context for the find function\n * @return The first element matching the callback, or undefined if one does not exist\n */\nexports.find = has_1.default('es6-array-find')\n    ? util_1.wrapNative(Array.prototype.find)\n    : Shim.find;\n/**\n * Performs a linear search and returns the first index whose value satisfies the passed callback,\n * or -1 if no values satisfy it.\n *\n * @param target An array-like object\n * @param callback A function returning true if the current value satisfies its criteria\n * @param [thisArg] The execution context for the find function\n * @return The first index whose value satisfies the passed callback, or -1 if no values satisfy it\n */\nexports.findIndex = has_1.default('es6-array-findindex')\n    ? util_1.wrapNative(Array.prototype.findIndex)\n    : Shim.findIndex;\n/* ES7 Array instance methods */\n/**\n * Determines whether an array includes a given value\n *\n * @param target the target array-like object\n * @param searchElement the item to search for\n * @param fromIndex the starting index to search from\n * @return `true` if the array includes the element, otherwise `false`\n */\nexports.includes = has_1.default('es7-array-includes')\n    ? util_1.wrapNative(Array.prototype.includes)\n    : Shim.includes;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/array.js\n// module id = 14\n// module chunks = 0","\"use strict\";\n/**\n * Helper function to generate a value property descriptor\n *\n * @param value        The value the property descriptor should be set to\n * @param enumerable   If the property should be enumberable, defaults to false\n * @param writable     If the property should be writable, defaults to true\n * @param configurable If the property should be configurable, defaults to true\n * @return             The property descriptor object\n */\nfunction getValueDescriptor(value, enumerable, writable, configurable) {\n    if (enumerable === void 0) { enumerable = false; }\n    if (writable === void 0) { writable = true; }\n    if (configurable === void 0) { configurable = true; }\n    return {\n        value: value,\n        enumerable: enumerable,\n        writable: writable,\n        configurable: configurable\n    };\n}\nexports.getValueDescriptor = getValueDescriptor;\n/**\n * A helper function which wraps a function where the first argument becomes the scope\n * of the call\n *\n * @param nativeFunction The source function to be wrapped\n */\nfunction wrapNative(nativeFunction) {\n    return function (target) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        return nativeFunction.apply(target, args);\n    };\n}\nexports.wrapNative = wrapNative;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/support/util.js\n// module id = 15\n// module chunks = 0","\"use strict\";\nvar string_1 = require(\"./string\");\nrequire(\"./Symbol\");\nvar staticDone = { done: true, value: undefined };\n/**\n * A class that provides \"shims\" an iterator interface on array like\n * objects.\n */\nvar ShimIterator = (function () {\n    function ShimIterator(list) {\n        this._nextIndex = -1;\n        if (isIterable(list)) {\n            this._nativeIterator = list[Symbol.iterator]();\n        }\n        else {\n            this._list = list;\n        }\n    }\n    ;\n    /**\n     * Return the next iteration result for the Iterator\n     */\n    ShimIterator.prototype.next = function () {\n        if (this._nativeIterator) {\n            return this._nativeIterator.next();\n        }\n        if (!this._list) {\n            return staticDone;\n        }\n        if (++this._nextIndex < this._list.length) {\n            return {\n                done: false,\n                value: this._list[this._nextIndex]\n            };\n        }\n        return staticDone;\n    };\n    ;\n    ShimIterator.prototype[Symbol.iterator] = function () {\n        return this;\n    };\n    return ShimIterator;\n}());\nexports.ShimIterator = ShimIterator;\n/**\n * A type guard for checking if something has an Iterable interface\n *\n * @param value The value to type guard against\n */\nfunction isIterable(value) {\n    return value && typeof value[Symbol.iterator] === 'function';\n}\nexports.isIterable = isIterable;\n/**\n * A type guard for checking if something is ArrayLike\n *\n * @param value The value to type guard against\n */\nfunction isArrayLike(value) {\n    return value && typeof value.length === 'number';\n}\nexports.isArrayLike = isArrayLike;\n/**\n * Returns the iterator for an object\n *\n * @param iterable The iterable object to return the iterator for\n */\nfunction get(iterable) {\n    if (isIterable(iterable)) {\n        return iterable[Symbol.iterator]();\n    }\n    else if (isArrayLike(iterable)) {\n        return new ShimIterator(iterable);\n    }\n}\nexports.get = get;\n/**\n * Shims the functionality of `for ... of` blocks\n *\n * @param iterable The object the provides an interator interface\n * @param callback The callback which will be called for each item of the iterable\n * @param thisArg Optional scope to pass the callback\n */\nfunction forOf(iterable, callback, thisArg) {\n    var broken = false;\n    function doBreak() {\n        broken = true;\n    }\n    /* We need to handle iteration of double byte strings properly */\n    if (!isIterable(iterable) && typeof iterable === 'string') {\n        var l = iterable.length;\n        for (var i = 0; i < l; ++i) {\n            var char = iterable[i];\n            if ((i + 1) < l) {\n                var code = char.charCodeAt(0);\n                if ((code >= string_1.HIGH_SURROGATE_MIN) && (code <= string_1.HIGH_SURROGATE_MAX)) {\n                    char += iterable[++i];\n                }\n            }\n            callback.call(thisArg, char, iterable, doBreak);\n            if (broken) {\n                return;\n            }\n        }\n    }\n    else {\n        var iterator = get(iterable);\n        if (iterator) {\n            var result = iterator.next();\n            while (!result.done) {\n                callback.call(thisArg, result.value, iterable, doBreak);\n                if (broken) {\n                    return;\n                }\n                result = iterator.next();\n            }\n        }\n    }\n}\nexports.forOf = forOf;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/iterator.js\n// module id = 16\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./support/has\");\nvar util_1 = require(\"./support/util\");\n/**\n * The minimum location of high surrogates\n */\nexports.HIGH_SURROGATE_MIN = 0xD800;\n/**\n * The maximum location of high surrogates\n */\nexports.HIGH_SURROGATE_MAX = 0xDBFF;\n/**\n * The minimum location of low surrogates\n */\nexports.LOW_SURROGATE_MIN = 0xDC00;\n/**\n * The maximum location of low surrogates\n */\nexports.LOW_SURROGATE_MAX = 0xDFFF;\nvar Shim;\n(function (Shim) {\n    /**\n     * Validates that text is defined, and normalizes position (based on the given default if the input is NaN).\n     * Used by startsWith, includes, and endsWith.\n     *\n     * @return Normalized position.\n     */\n    function normalizeSubstringArgs(name, text, search, position, isEnd) {\n        if (isEnd === void 0) { isEnd = false; }\n        if (text == null) {\n            throw new TypeError('string.' + name + ' requires a valid string to search against.');\n        }\n        var length = text.length;\n        position = position !== position ? (isEnd ? length : 0) : position;\n        return [text, String(search), Math.min(Math.max(position, 0), length)];\n    }\n    function raw(callSite) {\n        var substitutions = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            substitutions[_i - 1] = arguments[_i];\n        }\n        var rawStrings = callSite.raw;\n        var result = '';\n        var numSubstitutions = substitutions.length;\n        if (callSite == null || callSite.raw == null) {\n            throw new TypeError('string.raw requires a valid callSite object with a raw value');\n        }\n        for (var i = 0, length_1 = rawStrings.length; i < length_1; i++) {\n            result += rawStrings[i] + (i < numSubstitutions && i < length_1 - 1 ? substitutions[i] : '');\n        }\n        return result;\n    }\n    Shim.raw = raw;\n    function fromCodePoint() {\n        var codePoints = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            codePoints[_i] = arguments[_i];\n        }\n        // Adapted from https://github.com/mathiasbynens/String.fromCodePoint\n        var length = arguments.length;\n        if (!length) {\n            return '';\n        }\n        var fromCharCode = String.fromCharCode;\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var index = -1;\n        var result = '';\n        while (++index < length) {\n            var codePoint = Number(arguments[index]);\n            // Code points must be finite integers within the valid range\n            var isValid = isFinite(codePoint) && Math.floor(codePoint) === codePoint &&\n                codePoint >= 0 && codePoint <= 0x10FFFF;\n            if (!isValid) {\n                throw RangeError('string.fromCodePoint: Invalid code point ' + codePoint);\n            }\n            if (codePoint <= 0xFFFF) {\n                // BMP code point\n                codeUnits.push(codePoint);\n            }\n            else {\n                // Astral code point; split in surrogate halves\n                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                codePoint -= 0x10000;\n                var highSurrogate = (codePoint >> 10) + exports.HIGH_SURROGATE_MIN;\n                var lowSurrogate = (codePoint % 0x400) + exports.LOW_SURROGATE_MIN;\n                codeUnits.push(highSurrogate, lowSurrogate);\n            }\n            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                result += fromCharCode.apply(null, codeUnits);\n                codeUnits.length = 0;\n            }\n        }\n        return result;\n    }\n    Shim.fromCodePoint = fromCodePoint;\n    function codePointAt(text, position) {\n        if (position === void 0) { position = 0; }\n        // Adapted from https://github.com/mathiasbynens/String.prototype.codePointAt\n        if (text == null) {\n            throw new TypeError('string.codePointAt requries a valid string.');\n        }\n        var length = text.length;\n        if (position !== position) {\n            position = 0;\n        }\n        if (position < 0 || position >= length) {\n            return undefined;\n        }\n        // Get the first code unit\n        var first = text.charCodeAt(position);\n        if (first >= exports.HIGH_SURROGATE_MIN && first <= exports.HIGH_SURROGATE_MAX && length > position + 1) {\n            // Start of a surrogate pair (high surrogate and there is a next code unit); check for low surrogate\n            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            var second = text.charCodeAt(position + 1);\n            if (second >= exports.LOW_SURROGATE_MIN && second <= exports.LOW_SURROGATE_MAX) {\n                return (first - exports.HIGH_SURROGATE_MIN) * 0x400 + second - exports.LOW_SURROGATE_MIN + 0x10000;\n            }\n        }\n        return first;\n    }\n    Shim.codePointAt = codePointAt;\n    /* TODO: Missing normalize */\n    function repeat(text, count) {\n        if (count === void 0) { count = 0; }\n        // Adapted from https://github.com/mathiasbynens/String.prototype.repeat\n        if (text == null) {\n            throw new TypeError('string.repeat requires a valid string.');\n        }\n        if (count !== count) {\n            count = 0;\n        }\n        if (count < 0 || count === Infinity) {\n            throw new RangeError('string.repeat requires a non-negative finite count.');\n        }\n        var result = '';\n        while (count) {\n            if (count % 2) {\n                result += text;\n            }\n            if (count > 1) {\n                text += text;\n            }\n            count >>= 1;\n        }\n        return result;\n    }\n    Shim.repeat = repeat;\n    function startsWith(text, search, position) {\n        if (position === void 0) { position = 0; }\n        search = String(search);\n        _a = normalizeSubstringArgs('startsWith', text, search, position), text = _a[0], search = _a[1], position = _a[2];\n        var end = position + search.length;\n        if (end > text.length) {\n            return false;\n        }\n        return text.slice(position, end) === search;\n        var _a;\n    }\n    Shim.startsWith = startsWith;\n    function endsWith(text, search, endPosition) {\n        if (endPosition == null) {\n            endPosition = text.length;\n        }\n        _a = normalizeSubstringArgs('endsWith', text, search, endPosition, true), text = _a[0], search = _a[1], endPosition = _a[2];\n        var start = endPosition - search.length;\n        if (start < 0) {\n            return false;\n        }\n        return text.slice(start, endPosition) === search;\n        var _a;\n    }\n    Shim.endsWith = endsWith;\n    function includes(text, search, position) {\n        if (position === void 0) { position = 0; }\n        _a = normalizeSubstringArgs('includes', text, search, position), text = _a[0], search = _a[1], position = _a[2];\n        return text.indexOf(search, position) !== -1;\n        var _a;\n    }\n    Shim.includes = includes;\n    function padEnd(text, maxLength, fillString) {\n        if (fillString === void 0) { fillString = ' '; }\n        if (text === null || text === undefined) {\n            throw new TypeError('string.repeat requires a valid string.');\n        }\n        if (maxLength === Infinity) {\n            throw new RangeError('string.padEnd requires a non-negative finite count.');\n        }\n        if (maxLength === null || maxLength === undefined || maxLength < 0) {\n            maxLength = 0;\n        }\n        var strText = String(text);\n        var padding = maxLength - strText.length;\n        if (padding > 0) {\n            strText += repeat(fillString, Math.floor(padding / fillString.length)) + fillString.slice(0, padding % fillString.length);\n        }\n        return strText;\n    }\n    Shim.padEnd = padEnd;\n    function padStart(text, maxLength, fillString) {\n        if (fillString === void 0) { fillString = ' '; }\n        if (text === null || text === undefined) {\n            throw new TypeError('string.repeat requires a valid string.');\n        }\n        if (maxLength === Infinity) {\n            throw new RangeError('string.padStart requires a non-negative finite count.');\n        }\n        if (maxLength === null || maxLength === undefined || maxLength < 0) {\n            maxLength = 0;\n        }\n        var strText = String(text);\n        var padding = maxLength - strText.length;\n        if (padding > 0) {\n            strText = repeat(fillString, Math.floor(padding / fillString.length)) + fillString.slice(0, padding % fillString.length) + strText;\n        }\n        return strText;\n    }\n    Shim.padStart = padStart;\n    /* TODO: Provide an iterator for a string to mimic [Symbol.iterator]? */\n})(Shim = exports.Shim || (exports.Shim = {}));\n/**\n * A tag function for template strings to get the template string's raw string form.\n *\n * @param callSite Call site object (or a template string in TypeScript, which will transpile to one)\n * @param substitutions Values to substitute within the template string (TypeScript will generate these automatically)\n * @return String containing the raw template string with variables substituted\n *\n * @example\n * // Within TypeScript; logs 'The answer is:\\\\n42'\n * let answer = 42;\n * console.log(string.raw`The answer is:\\n${answer}`);\n *\n * @example\n * // The same example as above, but directly specifying a JavaScript object and substitution\n * console.log(string.raw({ raw: [ 'The answer is:\\\\n', '' ] }, 42));\n */\nexports.raw = has_1.default('es6-string-raw')\n    ? String.raw\n    : Shim.raw;\n/**\n * Returns the UTF-16 encoded code point value of a given position in a string.\n *\n * @param text The string containing the element whose code point is to be determined\n * @param position Position of an element within the string to retrieve the code point value from\n * @return A non-negative integer representing the UTF-16 encoded code point value\n */\nexports.fromCodePoint = has_1.default('es6-string-fromcodepoint')\n    ? String.fromCodePoint\n    : Shim.fromCodePoint;\n/**\n * Returns the UTF-16 encoded code point value of a given position in a string.\n *\n * @param text The string containing the element whose code point is to be determined\n * @param position Position of an element within the string to retrieve the code point value from\n * @return A non-negative integer representing the UTF-16 encoded code point value\n */\nexports.codePointAt = has_1.default('es6-string-codepointat')\n    ? util_1.wrapNative(String.prototype.codePointAt)\n    : Shim.codePointAt;\n/**\n * Returns a string containing the given string repeated the specified number of times.\n *\n * @param text The string to repeat\n * @param count The number of times to repeat the string\n * @return A string containing the input string repeated count times\n */\nexports.repeat = has_1.default('es6-string-repeat')\n    ? util_1.wrapNative(String.prototype.repeat)\n    : Shim.repeat;\n/**\n * Determines whether a string begins with the given substring (optionally starting from a given index).\n *\n * @param text The string to look for the search string within\n * @param search The string to search for\n * @param position The index to begin searching at\n * @return Boolean indicating if the search string was found at the beginning of the given string\n */\nexports.startsWith = has_1.default('es6-string-startswith')\n    ? util_1.wrapNative(String.prototype.startsWith)\n    : Shim.startsWith;\n/**\n * Determines whether a string ends with the given substring.\n *\n * @param text The string to look for the search string within\n * @param search The string to search for\n * @param endPosition The index searching should stop before (defaults to text.length)\n * @return Boolean indicating if the search string was found at the end of the given string\n */\nexports.endsWith = has_1.default('es6-string-endswith')\n    ? util_1.wrapNative(String.prototype.endsWith)\n    : Shim.endsWith;\n/**\n * Determines whether a string includes the given substring (optionally starting from a given index).\n *\n * @param text The string to look for the search string within\n * @param search The string to search for\n * @param position The index to begin searching at\n * @return Boolean indicating if the search string was found within the given string\n */\nexports.includes = has_1.default('es6-string-includes')\n    ? util_1.wrapNative(String.prototype.includes)\n    : Shim.includes;\n/**\n * Pads the beginning of a string with a fill string until the string is a certain length.\n *\n * @param text          The string to pad\n * @param maxLength     The desired length of the string\n * @param fillString    The string to be repeated (fully or partially) until text is the maximum length\n *\n * @return A string that is at least the maximum length specified, padded in the front if necessary.\n */\nexports.padStart = has_1.default('es6-string-padstart')\n    ? util_1.wrapNative(String.prototype.padStart)\n    : Shim.padStart;\n/**\n * Pads the end of a string with a fill string until the string is a certain length.\n *\n * @param text          The string to pad\n * @param maxLength     The desired length of the string\n * @param fillString    The string to be repeated (fully or partially) until text is the maximum length\n *\n * @return A string that is at least the maximum length specified, padded at the end if necessary.\n */\nexports.padEnd = has_1.default('es6-string-padend')\n    ? util_1.wrapNative(String.prototype.padEnd)\n    : Shim.padEnd;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/string.js\n// module id = 17\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./support/has\");\nvar global_1 = require(\"./support/global\");\nvar util_1 = require(\"./support/util\");\nvar Shim;\n(function (Shim) {\n    /* tslint:disable-next-line:variable-name */\n    var Symbol;\n    /* tslint:disable-next-line:variable-name */\n    var InternalSymbol;\n    var defineProperties = Object.defineProperties;\n    var defineProperty = Object.defineProperty;\n    var create = Object.create;\n    var objPrototype = Object.prototype;\n    var globalSymbols = {};\n    var getSymbolName = (function () {\n        var created = create(null);\n        return function (desc) {\n            var postfix = 0;\n            var name;\n            while (created[String(desc) + (postfix || '')]) {\n                ++postfix;\n            }\n            desc += String(postfix || '');\n            created[desc] = true;\n            name = '@@' + desc;\n            // FIXME: Temporary guard until the duplicate execution when testing can be\n            // pinned down.\n            if (!Object.getOwnPropertyDescriptor(objPrototype, name)) {\n                defineProperty(objPrototype, name, {\n                    set: function (value) {\n                        defineProperty(this, name, util_1.getValueDescriptor(value));\n                    }\n                });\n            }\n            return name;\n        };\n    }());\n    InternalSymbol = function Symbol(description) {\n        if (this instanceof InternalSymbol) {\n            throw new TypeError('TypeError: Symbol is not a constructor');\n        }\n        return Symbol(description);\n    };\n    Symbol = function Symbol(description) {\n        if (this instanceof Symbol) {\n            throw new TypeError('TypeError: Symbol is not a constructor');\n        }\n        var sym = Object.create(InternalSymbol.prototype);\n        description = (description === undefined ? '' : String(description));\n        return defineProperties(sym, {\n            __description__: util_1.getValueDescriptor(description),\n            __name__: util_1.getValueDescriptor(getSymbolName(description))\n        });\n    };\n    /**\n     * A custom guard function that determines if an object is a symbol or not\n     * @param  {any}       value The value to check to see if it is a symbol or not\n     * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)\n     */\n    function isSymbol(value) {\n        return (value && ((typeof value === 'symbol') || (value['@@toStringTag'] === 'Symbol'))) || false;\n    }\n    Shim.isSymbol = isSymbol;\n    /**\n     * Throws if the value is not a symbol, used internally within the Shim\n     * @param  {any}    value The value to check\n     * @return {symbol}       Returns the symbol or throws\n     */\n    function validateSymbol(value) {\n        if (!isSymbol(value)) {\n            throw new TypeError(value + ' is not a symbol');\n        }\n        return value;\n    }\n    /* Decorate the Symbol function with the appropriate properties */\n    defineProperty(Symbol, 'for', util_1.getValueDescriptor(function (key) {\n        if (globalSymbols[key]) {\n            return globalSymbols[key];\n        }\n        return (globalSymbols[key] = Symbol(String(key)));\n    }));\n    defineProperties(Symbol, {\n        keyFor: util_1.getValueDescriptor(function (sym) {\n            var key;\n            validateSymbol(sym);\n            for (key in globalSymbols) {\n                if (globalSymbols[key] === sym) {\n                    return key;\n                }\n            }\n        }),\n        hasInstance: util_1.getValueDescriptor(Symbol.for('hasInstance'), false, false),\n        isConcatSpreadable: util_1.getValueDescriptor(Symbol.for('isConcatSpreadable'), false, false),\n        iterator: util_1.getValueDescriptor(Symbol.for('iterator'), false, false),\n        match: util_1.getValueDescriptor(Symbol.for('match'), false, false),\n        observable: util_1.getValueDescriptor(Symbol.for('observable'), false, false),\n        replace: util_1.getValueDescriptor(Symbol.for('replace'), false, false),\n        search: util_1.getValueDescriptor(Symbol.for('search'), false, false),\n        species: util_1.getValueDescriptor(Symbol.for('species'), false, false),\n        split: util_1.getValueDescriptor(Symbol.for('split'), false, false),\n        toPrimitive: util_1.getValueDescriptor(Symbol.for('toPrimitive'), false, false),\n        toStringTag: util_1.getValueDescriptor(Symbol.for('toStringTag'), false, false),\n        unscopables: util_1.getValueDescriptor(Symbol.for('unscopables'), false, false)\n    });\n    /* Decorate the InternalSymbol object */\n    defineProperties(InternalSymbol.prototype, {\n        constructor: util_1.getValueDescriptor(Symbol),\n        toString: util_1.getValueDescriptor(function () { return this.__name__; }, false, false)\n    });\n    /* Decorate the Symbol.prototype */\n    defineProperties(Symbol.prototype, {\n        toString: util_1.getValueDescriptor(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),\n        valueOf: util_1.getValueDescriptor(function () { return validateSymbol(this); })\n    });\n    defineProperty(Symbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(function () { return validateSymbol(this); }));\n    defineProperty(Symbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor('Symbol', false, false, true));\n    defineProperty(InternalSymbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(Symbol.prototype[Symbol.toPrimitive], false, false, true));\n    defineProperty(InternalSymbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor(Symbol.prototype[Symbol.toStringTag], false, false, true));\n    /* tslint:disable-next-line:variable-name */\n    Shim.Exposed = Symbol;\n})(Shim = exports.Shim || (exports.Shim = {}));\n/* tslint:disable-next-line:variable-name */\nvar SymbolShim = has_1.default('es6-symbol') ? global_1.default.Symbol : global_1.default.Symbol = Shim.Exposed;\n/**\n * Fill any missing well known symbols if the native Symbol is missing them\n */\n['hasInstance', 'isConcatSpreadable', 'iterator', 'species', 'replace', 'search', 'split', 'match', 'toPrimitive',\n    'toStringTag', 'unscopables', 'observable'].forEach(function (wellKnown) {\n    if (!Symbol[wellKnown]) {\n        Object.defineProperty(Symbol, wellKnown, util_1.getValueDescriptor(Symbol.for(wellKnown), false, false));\n    }\n});\nexports.isSymbol = Shim.isSymbol;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SymbolShim;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/Symbol.js\n// module id = 18\n// module chunks = 0","\"use strict\";\nvar global_1 = require(\"./support/global\");\n/**\n * The smallest interval between two representable numbers.\n */\nexports.EPSILON = 1;\n/**\n * The maximum safe integer in JavaScript\n */\nexports.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n/**\n * The minimum safe integer in JavaScript\n */\nexports.MIN_SAFE_INTEGER = -exports.MAX_SAFE_INTEGER;\n/**\n * Determines whether the passed value is NaN without coersion.\n *\n * @param value The value to test\n * @return true if the value is NaN, false if it is not\n */\nfunction isNaN(value) {\n    return typeof value === 'number' && global_1.default.isNaN(value);\n}\nexports.isNaN = isNaN;\n/**\n * Determines whether the passed value is a finite number without coersion.\n *\n * @param value The value to test\n * @return true if the value is finite, false if it is not\n */\nfunction isFinite(value) {\n    return typeof value === 'number' && global_1.default.isFinite(value);\n}\nexports.isFinite = isFinite;\n/**\n * Determines whether the passed value is an integer.\n *\n * @param value The value to test\n * @return true if the value is an integer, false if it is not\n */\nfunction isInteger(value) {\n    return isFinite(value) && Math.floor(value) === value;\n}\nexports.isInteger = isInteger;\n/**\n * Determines whether the passed value is an integer that is 'safe,' meaning:\n *   1. it can be expressed as an IEEE-754 double precision number\n *   2. it has a one-to-one mapping to a mathematical integer, meaning its\n *      IEEE-754 representation cannot be the result of rounding any other\n *      integer to fit the IEEE-754 representation\n *\n * @param value The value to test\n * @return true if the value is an integer, false if it is not\n */\nfunction isSafeInteger(value) {\n    return isInteger(value) && Math.abs(value) <= exports.MAX_SAFE_INTEGER;\n}\nexports.isSafeInteger = isSafeInteger;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/number.js\n// module id = 19\n// module chunks = 0","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\"use strict\";\nvar decorators_1 = require(\"./support/decorators\");\nvar global_1 = require(\"./support/global\");\nvar iterator_1 = require(\"./iterator\");\nrequire(\"./Symbol\");\nvar Shim;\n(function (Shim) {\n    var DELETED = {};\n    function getUID() {\n        return Math.floor(Math.random() * 100000000);\n    }\n    var generateName = (function () {\n        var startId = Math.floor(Date.now() % 100000000);\n        return function generateName() {\n            return '__wm' + getUID() + (startId++ + '__');\n        };\n    })();\n    var WeakMap = (function () {\n        function WeakMap(iterable) {\n            var _this = this;\n            this[Symbol.toStringTag] = 'WeakMap';\n            Object.defineProperty(this, '_name', {\n                value: generateName()\n            });\n            this._frozenEntries = [];\n            if (iterable) {\n                iterator_1.forOf(iterable, function (_a) {\n                    var key = _a[0], value = _a[1];\n                    return _this.set(key, value);\n                });\n            }\n        }\n        WeakMap.prototype._getFrozenEntryIndex = function (key) {\n            for (var i = 0; i < this._frozenEntries.length; i++) {\n                if (this._frozenEntries[i].key === key) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n        WeakMap.prototype.delete = function (key) {\n            if (key === undefined || key === null) {\n                return false;\n            }\n            var entry = key[this._name];\n            if (entry && entry.key === key && entry.value !== DELETED) {\n                entry.value = DELETED;\n                return true;\n            }\n            var frozenIndex = this._getFrozenEntryIndex(key);\n            if (frozenIndex >= 0) {\n                this._frozenEntries.splice(frozenIndex, 1);\n                return true;\n            }\n            return false;\n        };\n        WeakMap.prototype.get = function (key) {\n            if (key === undefined || key === null) {\n                return undefined;\n            }\n            var entry = key[this._name];\n            if (entry && entry.key === key && entry.value !== DELETED) {\n                return entry.value;\n            }\n            var frozenIndex = this._getFrozenEntryIndex(key);\n            if (frozenIndex >= 0) {\n                return this._frozenEntries[frozenIndex].value;\n            }\n        };\n        WeakMap.prototype.has = function (key) {\n            if (key === undefined || key === null) {\n                return false;\n            }\n            var entry = key[this._name];\n            if (Boolean(entry && entry.key === key && entry.value !== DELETED)) {\n                return true;\n            }\n            var frozenIndex = this._getFrozenEntryIndex(key);\n            if (frozenIndex >= 0) {\n                return true;\n            }\n            return false;\n        };\n        WeakMap.prototype.set = function (key, value) {\n            if (!key || (typeof key !== 'object' && typeof key !== 'function')) {\n                throw new TypeError('Invalid value used as weak map key');\n            }\n            var entry = key[this._name];\n            if (!entry || entry.key !== key) {\n                entry = Object.create(null, {\n                    key: { value: key }\n                });\n                if (Object.isFrozen(key)) {\n                    this._frozenEntries.push(entry);\n                }\n                else {\n                    Object.defineProperty(key, this._name, {\n                        value: entry\n                    });\n                }\n            }\n            entry.value = value;\n            return this;\n        };\n        return WeakMap;\n    }());\n    Shim.WeakMap = WeakMap;\n})(Shim || (Shim = {}));\nvar WeakMap = (function () {\n    /* istanbul ignore next */\n    function WeakMap(iterable) {\n        /* istanbul ignore next */\n        this[Symbol.toStringTag] = 'WeakMap';\n    }\n    /* istanbul ignore next */\n    WeakMap.prototype.delete = function (key) { throw new Error(); };\n    /* istanbul ignore next */\n    WeakMap.prototype.get = function (key) { throw new Error(); };\n    /* istanbul ignore next */\n    WeakMap.prototype.has = function (key) { throw new Error(); };\n    /* istanbul ignore next */\n    WeakMap.prototype.set = function (key, value) { throw new Error(); };\n    return WeakMap;\n}());\nWeakMap = __decorate([\n    decorators_1.hasClass('es6-weakmap', global_1.default.WeakMap, Shim.WeakMap)\n], WeakMap);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = WeakMap;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/WeakMap.js\n// module id = 20\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./has\");\n/**\n * A class decorator that provides either a native class or a shimmed class based on a feature\n * test\n * @param feature The has feature to check\n * @param trueClass The class to use if feature test returns `true`\n * @param falseClass The class to use if the feature test returns `false` or is not defined\n */\nfunction hasClass(feature, trueClass, falseClass) {\n    return function (target) {\n        return has_1.default(feature) ? trueClass : falseClass;\n    };\n}\nexports.hasClass = hasClass;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/support/decorators.js\n// module id = 21\n// module chunks = 0","\"use strict\";\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\n/**\n * Types of advice\n */\nvar AdviceType;\n(function (AdviceType) {\n    AdviceType[AdviceType[\"Before\"] = 0] = \"Before\";\n    AdviceType[AdviceType[\"After\"] = 1] = \"After\";\n    AdviceType[AdviceType[\"Around\"] = 2] = \"Around\";\n})(AdviceType = exports.AdviceType || (exports.AdviceType = {}));\n/**\n * A weak map of dispatchers used to apply the advice\n */\nvar dispatchAdviceMap = new WeakMap_1.default();\n/**\n * Returns the dispatcher function for a given joinPoint (method/function)\n *\n * @param joinPoint The function that is to be advised\n */\nfunction getDispatcher(joinPoint) {\n    function dispatcher() {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var _a = dispatchAdviceMap.get(dispatcher), before = _a.before, after = _a.after, joinPoint = _a.joinPoint;\n        if (before) {\n            args = before.reduce(function (previousArgs, advice) {\n                var currentArgs = advice.apply(_this, previousArgs);\n                return currentArgs || previousArgs;\n            }, args);\n        }\n        var result = joinPoint.apply(this, args);\n        if (after) {\n            result = after.reduce(function (previousResult, advice) {\n                return advice.apply(_this, [previousResult].concat(args));\n            }, result);\n        }\n        return result;\n    }\n    /* We want to \"clone\" the advice that has been applied already, if this\n     * joinPoint is already advised */\n    if (dispatchAdviceMap.has(joinPoint)) {\n        var adviceMap = dispatchAdviceMap.get(joinPoint);\n        var before_1 = adviceMap.before, after_1 = adviceMap.after;\n        if (before_1) {\n            before_1 = before_1.slice(0);\n        }\n        if (after_1) {\n            after_1 = after_1.slice(0);\n        }\n        dispatchAdviceMap.set(dispatcher, {\n            joinPoint: adviceMap.joinPoint,\n            before: before_1,\n            after: after_1\n        });\n    }\n    else {\n        dispatchAdviceMap.set(dispatcher, { joinPoint: joinPoint });\n    }\n    return dispatcher;\n}\n/**\n * Advise a join point (function) with supplied advice\n *\n * @param joinPoint The function to be advised\n * @param type The type of advice to be applied\n * @param advice The advice to apply\n */\nfunction advise(joinPoint, type, advice) {\n    var dispatcher;\n    if (type === AdviceType.Around) {\n        dispatcher = getDispatcher(advice.apply(this, [joinPoint]));\n    }\n    else {\n        dispatcher = getDispatcher(joinPoint);\n        var adviceMap = dispatchAdviceMap.get(dispatcher);\n        if (type === AdviceType.Before) {\n            (adviceMap.before || (adviceMap.before = [])).unshift(advice);\n        }\n        else {\n            (adviceMap.after || (adviceMap.after = [])).push(advice);\n        }\n    }\n    return dispatcher;\n}\n/**\n * Apply advice *before* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The before advice\n */\nfunction before(joinPoint, advice) {\n    return advise(joinPoint, AdviceType.Before, advice);\n}\nexports.before = before;\n/**\n * Apply advice *after* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The after advice\n */\nfunction after(joinPoint, advice) {\n    return advise(joinPoint, AdviceType.After, advice);\n}\nexports.after = after;\n/**\n * Apply advice *around* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The around advice\n */\nfunction around(joinPoint, advice) {\n    return advise(joinPoint, AdviceType.Around, advice);\n}\nexports.around = around;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/compose/aspect.js\n// module id = 22\n// module chunks = 0","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\"use strict\";\nvar global_1 = require(\"./support/global\");\nvar queue_1 = require(\"./support/queue\");\nvar iterator_1 = require(\"./iterator\");\nrequire(\"./Symbol\");\nvar decorators_1 = require(\"./support/decorators\");\nvar Shim;\n(function (Shim) {\n    /**\n     * Returns true if a given value has a `then` method.\n     * @param {any} value The value to check if is Thenable\n     * @returns {is Thenable<T>} A type guard if the value is thenable\n     */\n    function isThenable(value) {\n        return value && typeof value.then === 'function';\n    }\n    Shim.isThenable = isThenable;\n    /**\n     * Promise is a partial implementation of the ES2015 Promise specification. It relies on Promise to do some safety\n     * checks such as verifying that a Promise isn't resolved with itself. This class is exported for testability, and is\n     * not intended to be used directly.\n     *\n     * @borrows Promise.all as Promise.all\n     * @borrows Promise.race as Promise.race\n     * @borrows Promise.reject as Promise.reject\n     * @borrows Promise.resolve as Promise.resolve\n     * @borrows Promise#catch as Promise#catch\n     * @borrows Promise#then as Promise#then\n     */\n    var Promise = (function () {\n        /**\n         * Creates a new Promise.\n         *\n         * @constructor\n         *\n         * @param executor\n         * The executor function is called immediately when the Promise is instantiated. It is responsible for\n         * starting the asynchronous operation when it is invoked.\n         *\n         * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n         * successfully, or the `reject` function when the operation fails.\n         */\n        function Promise(executor) {\n            var _this = this;\n            /**\n             * The current state of this promise.\n             */\n            this.state = 1 /* Pending */;\n            this[Symbol.toStringTag] = 'Promise';\n            /**\n             * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n             */\n            var isChained = false;\n            /**\n             * Whether or not this promise is in a resolved state.\n             */\n            var isResolved = function () {\n                return _this.state !== 1 /* Pending */ || isChained;\n            };\n            /**\n             * Callbacks that should be invoked once the asynchronous operation has completed.\n             */\n            var callbacks = [];\n            /**\n             * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n             * enqueues callbacks for execution on the next event loop turn.\n             */\n            var whenFinished = function (callback) {\n                if (callbacks) {\n                    callbacks.push(callback);\n                }\n            };\n            /**\n             * Settles this promise.\n             *\n             * @param newState The resolved state for this promise.\n             * @param {T|any} value The resolved value for this promise.\n             */\n            var settle = function (newState, value) {\n                // A promise can only be settled once.\n                if (_this.state !== 1 /* Pending */) {\n                    return;\n                }\n                _this.state = newState;\n                _this.resolvedValue = value;\n                whenFinished = queue_1.queueMicroTask;\n                // Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n                // wait an extra turn.\n                if (callbacks && callbacks.length > 0) {\n                    queue_1.queueMicroTask(function () {\n                        if (callbacks) {\n                            var count = callbacks.length;\n                            for (var i = 0; i < count; ++i) {\n                                callbacks[i].call(null);\n                            }\n                            callbacks = null;\n                        }\n                    });\n                }\n            };\n            /**\n             * Resolves this promise.\n             *\n             * @param newState The resolved state for this promise.\n             * @param {T|any} value The resolved value for this promise.\n             */\n            var resolve = function (newState, value) {\n                if (isResolved()) {\n                    return;\n                }\n                if (isThenable(value)) {\n                    value.then(settle.bind(null, 0 /* Fulfilled */), settle.bind(null, 2 /* Rejected */));\n                    isChained = true;\n                }\n                else {\n                    settle(newState, value);\n                }\n            };\n            this.then = function (onFulfilled, onRejected) {\n                return new Promise(function (resolve, reject) {\n                    // whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n                    // promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n                    // event loop.\n                    whenFinished(function () {\n                        var callback = _this.state === 2 /* Rejected */ ? onRejected : onFulfilled;\n                        if (typeof callback === 'function') {\n                            try {\n                                resolve(callback(_this.resolvedValue));\n                            }\n                            catch (error) {\n                                reject(error);\n                            }\n                        }\n                        else if (_this.state === 2 /* Rejected */) {\n                            reject(_this.resolvedValue);\n                        }\n                        else {\n                            resolve(_this.resolvedValue);\n                        }\n                    });\n                });\n            };\n            try {\n                executor(resolve.bind(null, 0 /* Fulfilled */), resolve.bind(null, 2 /* Rejected */));\n            }\n            catch (error) {\n                settle(2 /* Rejected */, error);\n            }\n        }\n        Promise.all = function (iterable) {\n            return new this(function (resolve, reject) {\n                var values = [];\n                var complete = 0;\n                var total = 0;\n                var populating = true;\n                function fulfill(index, value) {\n                    values[index] = value;\n                    ++complete;\n                    finish();\n                }\n                function finish() {\n                    if (populating || complete < total) {\n                        return;\n                    }\n                    resolve(values);\n                }\n                function processItem(index, item) {\n                    ++total;\n                    if (isThenable(item)) {\n                        // If an item Promise rejects, this Promise is immediately rejected with the item\n                        // Promise's rejection error.\n                        item.then(fulfill.bind(null, index), reject);\n                    }\n                    else {\n                        Promise.resolve(item).then(fulfill.bind(null, index));\n                    }\n                }\n                var i = 0;\n                iterator_1.forOf(iterable, function (value) {\n                    processItem(i, value);\n                    i++;\n                });\n                populating = false;\n                finish();\n            });\n        };\n        Promise.race = function (iterable) {\n            return new this(function (resolve, reject) {\n                iterator_1.forOf(iterable, function (item) {\n                    if (item instanceof Promise) {\n                        // If a Promise item rejects, this Promise is immediately rejected with the item\n                        // Promise's rejection error.\n                        item.then(resolve, reject);\n                    }\n                    else {\n                        Promise.resolve(item).then(resolve);\n                    }\n                });\n            });\n        };\n        Promise.reject = function (reason) {\n            return new this(function (resolve, reject) {\n                reject(reason);\n            });\n        };\n        Promise.resolve = function (value) {\n            return new this(function (resolve) {\n                resolve(value);\n            });\n        };\n        Promise.prototype.catch = function (onRejected) {\n            return this.then(undefined, onRejected);\n        };\n        return Promise;\n    }());\n    Shim.Promise = Promise;\n})(Shim || (Shim = {}));\nvar Promise = (function () {\n    /**\n     * Creates a new Promise.\n     *\n     * @constructor\n     *\n     * @param executor\n     * The executor function is called immediately when the Promise is instantiated. It is responsible for\n     * starting the asynchronous operation when it is invoked.\n     *\n     * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n     * successfully, or the `reject` function when the operation fails.\n     */\n    /* istanbul ignore next */\n    function Promise(executor) {\n    }\n    /**\n     * Converts an iterable object containing promises into a single promise that resolves to a new iterable object\n     * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the\n     * iterable. Iterable values that are not promises are converted to promises using Promise.resolve.\n     *\n     * @example\n     * Promise.all([ Promise.resolve('foo'), 'bar' ]).then(function (value) {\n     *     value[0] === 'foo'; // true\n     *     value[1] === 'bar'; // true\n     * });\n     *\n     * @example\n     * Promise.all({\n     *     foo: Promise.resolve('foo'),\n     *     bar: 'bar'\n     * }).then((value) => {\n     *     value.foo === 'foo'; // true\n     *     value.bar === 'bar'; // true\n     * });\n     */\n    /* istanbul ignore next */\n    Promise.all = function (iterable) {\n        throw new Error();\n    };\n    ;\n    /**\n     * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of\n     * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in\n     * the iterable that are not Promises are converted to Promises with Promise.resolve.\n     *\n     * @example\n     * Promise.race([ Promise.resolve('foo'), Promise.resolve('bar') ]).then((value) => {\n     *     value === 'foo'; // true\n     * });\n     *\n     * @example\n     * Promise.race({\n     *     foo: Promise.resolve('foo'),\n     *     bar: Promise.resolve('bar')\n     * }).then((value) => {\n     *     value === 'foo'; // true\n     * });\n     */\n    /* istanbul ignore next */\n    Promise.race = function (iterable) {\n        throw new Error();\n    };\n    /**\n     * Creates a new promise that is rejected with the given error.\n     */\n    /* istanbul ignore next */\n    Promise.reject = function (reason) {\n        throw new Error();\n    };\n    /* istanbul ignore next */\n    Promise.resolve = function (value) {\n        throw new Error();\n    };\n    /* istanbul ignore next */\n    Promise.prototype.catch = function (onRejected) {\n        throw new Error();\n    };\n    /* istanbul ignore next */\n    Promise.prototype.then = function (onFulfilled, onRejected) {\n        throw new Error();\n    };\n    return Promise;\n}());\nPromise = __decorate([\n    decorators_1.hasClass('es6-promise', global_1.default.Promise, Shim.Promise)\n], Promise);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Promise;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/Promise.js\n// module id = 23\n// module chunks = 0","\"use strict\";\nvar global_1 = require(\"./global\");\nvar has_1 = require(\"./has\");\n/**\n * Executes a task\n * @param item The task to execute\n */\nfunction executeTask(item) {\n    if (item && item.isActive) {\n        item.callback();\n    }\n}\n/**\n * Get a handle to be able to remove an item from the queue\n */\nfunction getQueueHandle(item, destructor) {\n    return {\n        destroy: function () {\n            this.destroy = function () { };\n            if (item) {\n                item.isActive = false;\n            }\n            if (destructor) {\n                destructor();\n            }\n        }\n    };\n}\nvar microTasks = [];\nvar microTaskQueued = false;\nvar checkMicroTaskQueue = function () { };\n/**\n * Schedules a callback to the macrotask queue.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexports.queueTask = (function () {\n    var destructor;\n    var enqueue;\n    /* IE and Edge's setImmediate does not always resolve as a macro task, sometimes as a microtask */\n    if (has_1.default('postmessage')) {\n        var queue_1 = [];\n        addEventListener('message', function (event) {\n            // Confirm that the event was triggered by the current window and by this particular implementation.\n            if (event.source === global_1.default && event.data === 'dojo-queue-message') {\n                event.stopPropagation();\n                if (queue_1.length) {\n                    executeTask(queue_1.shift());\n                }\n            }\n        });\n        enqueue = function (item) {\n            queue_1.push(item);\n            postMessage('dojo-queue-message', '*');\n        };\n    }\n    else if (has_1.default('setimmediate')) {\n        destructor = clearImmediate;\n        enqueue = function (item) {\n            return setImmediate(executeTask.bind(null, item));\n        };\n    }\n    else {\n        destructor = clearTimeout;\n        enqueue = function (item) {\n            return setTimeout(executeTask.bind(null, item), 0);\n        };\n    }\n    function queueTask(callback) {\n        var item = {\n            isActive: true,\n            callback: callback\n        };\n        var id = enqueue(item);\n        return getQueueHandle(item, destructor && function () {\n            destructor(id);\n        });\n    }\n    ;\n    // TODO: Use aspect.before when it is available.\n    return has_1.default('microtasks') ? queueTask : function (callback) {\n        checkMicroTaskQueue();\n        return queueTask(callback);\n    };\n})();\ncheckMicroTaskQueue = !has_1.default('microtasks')\n    ? function () {\n        if (!microTaskQueued) {\n            microTaskQueued = true;\n            exports.queueTask(function () {\n                microTaskQueued = false;\n                if (microTasks.length) {\n                    var item = void 0;\n                    while (item = microTasks.shift()) {\n                        executeTask(item);\n                    }\n                }\n            });\n        }\n    } : checkMicroTaskQueue;\n/**\n * Schedules a callback to the microtask queue.\n *\n * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native\n * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask\n * registered with `queueTask` or `queueAnimationTask`.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexports.queueMicroTask = (function () {\n    var enqueue;\n    if (has_1.default('host-node')) {\n        enqueue = function (item) {\n            process.nextTick(executeTask.bind(null, item));\n        };\n    }\n    else if (has_1.default('es6-promise') && !has_1.default('setimmediate') && !has_1.default('host-node')) {\n        enqueue = function (item) {\n            global_1.default.Promise.resolve(item).then(executeTask);\n        };\n    }\n    else if (has_1.default('dom-mutationobserver')) {\n        /* tslint:disable-next-line:variable-name */\n        var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;\n        var node_1 = document.createElement('div');\n        var queue_2 = [];\n        var observer = new HostMutationObserver(function () {\n            while (queue_2.length > 0) {\n                var item = queue_2.shift();\n                if (item && item.isActive) {\n                    item.callback();\n                }\n            }\n        });\n        observer.observe(node_1, { attributes: true });\n        enqueue = function (item) {\n            queue_2.push(item);\n            node_1.setAttribute('queueStatus', '1');\n        };\n    }\n    else {\n        enqueue = function (item) {\n            checkMicroTaskQueue();\n            microTasks.push(item);\n        };\n    }\n    return function (callback) {\n        var item = {\n            isActive: true,\n            callback: callback\n        };\n        enqueue(item);\n        return getQueueHandle(item);\n    };\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/support/queue.js\n// module id = 24\n// module chunks = 0","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 25\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/setimmediate/setImmediate.js\n// module id = 26\n// module chunks = 0","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['exports'], factory);\n    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n        // CommonJS\n        factory(exports);\n    } else {\n        // Browser globals\n        factory(root.maquette = {});\n    }\n}(this, function (exports) {\n    'use strict';\n    ;\n    ;\n    ;\n    ;\n    var NAMESPACE_W3 = 'http://www.w3.org/';\n    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\n    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n    // Utilities\n    var emptyArray = [];\n    var extend = function (base, overrides) {\n        var result = {};\n        Object.keys(base).forEach(function (key) {\n            result[key] = base[key];\n        });\n        if (overrides) {\n            Object.keys(overrides).forEach(function (key) {\n                result[key] = overrides[key];\n            });\n        }\n        return result;\n    };\n    // Hyperscript helper functions\n    var same = function (vnode1, vnode2) {\n        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n            return false;\n        }\n        if (vnode1.properties && vnode2.properties) {\n            if (vnode1.properties.key !== vnode2.properties.key) {\n                return false;\n            }\n            return vnode1.properties.bind === vnode2.properties.bind;\n        }\n        return !vnode1.properties && !vnode2.properties;\n    };\n    var toTextVNode = function (data) {\n        return {\n            vnodeSelector: '',\n            properties: undefined,\n            children: undefined,\n            text: data.toString(),\n            domNode: null\n        };\n    };\n    var appendChildren = function (parentSelector, insertions, main) {\n        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\n            var item = insertions[i];\n            if (Array.isArray(item)) {\n                appendChildren(parentSelector, item, main);\n            } else {\n                if (item !== null && item !== undefined) {\n                    if (!item.hasOwnProperty('vnodeSelector')) {\n                        item = toTextVNode(item);\n                    }\n                    main.push(item);\n                }\n            }\n        }\n    };\n    // Render helper functions\n    var missingTransition = function () {\n        throw new Error('Provide a transitions object to the projectionOptions to do animations');\n    };\n    var DEFAULT_PROJECTION_OPTIONS = {\n        namespace: undefined,\n        eventHandlerInterceptor: undefined,\n        styleApplyer: function (domNode, styleName, value) {\n            // Provides a hook to add vendor prefixes for browsers that still need it.\n            domNode.style[styleName] = value;\n        },\n        transitions: {\n            enter: missingTransition,\n            exit: missingTransition\n        }\n    };\n    var applyDefaultProjectionOptions = function (projectorOptions) {\n        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n    };\n    var checkStyleValue = function (styleValue) {\n        if (typeof styleValue !== 'string') {\n            throw new Error('Style values must be strings');\n        }\n    };\n    var setProperties = function (domNode, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            /* tslint:disable:no-var-keyword: edge case */\n            var propValue = properties[propName];\n            /* tslint:enable:no-var-keyword */\n            if (propName === 'className') {\n                throw new Error('Property \"className\" is not supported, use \"class\".');\n            } else if (propName === 'class') {\n                propValue.split(/\\s+/).forEach(function (token) {\n                    return domNode.classList.add(token);\n                });\n            } else if (propName === 'classes') {\n                // object with string keys and boolean values\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    if (propValue[className]) {\n                        domNode.classList.add(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                // object with string keys and string (!) values\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var styleValue = propValue[styleName];\n                    if (styleValue) {\n                        checkStyleValue(styleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n                    }\n                }\n            } else if (propName === 'key') {\n                continue;\n            } else if (propValue === null || propValue === undefined) {\n                continue;\n            } else {\n                var type = typeof propValue;\n                if (type === 'function') {\n                    if (propName.lastIndexOf('on', 0) === 0) {\n                        if (eventHandlerInterceptor) {\n                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers\n                        }\n                        if (propName === 'oninput') {\n                            (function () {\n                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n                                var oldPropValue = propValue;\n                                propValue = function (evt) {\n                                    evt.target['oninput-value'] = evt.target.value;\n                                    // may be HTMLTextAreaElement as well\n                                    oldPropValue.apply(this, [evt]);\n                                };\n                            }());\n                        }\n                        domNode[propName] = propValue;\n                    }\n                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                    } else {\n                        domNode.setAttribute(propName, propValue);\n                    }\n                } else {\n                    domNode[propName] = propValue;\n                }\n            }\n        }\n    };\n    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var propertiesUpdated = false;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            // assuming that properties will be nullified instead of missing is by design\n            var propValue = properties[propName];\n            var previousValue = previousProperties[propName];\n            if (propName === 'class') {\n                if (previousValue !== propValue) {\n                    throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n                }\n            } else if (propName === 'classes') {\n                var classList = domNode.classList;\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    var on = !!propValue[className];\n                    var previousOn = !!previousValue[className];\n                    if (on === previousOn) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (on) {\n                        classList.add(className);\n                    } else {\n                        classList.remove(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var newStyleValue = propValue[styleName];\n                    var oldStyleValue = previousValue[styleName];\n                    if (newStyleValue === oldStyleValue) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (newStyleValue) {\n                        checkStyleValue(newStyleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n                    } else {\n                        projectionOptions.styleApplyer(domNode, styleName, '');\n                    }\n                }\n            } else {\n                if (!propValue && typeof previousValue === 'string') {\n                    propValue = '';\n                }\n                if (propName === 'value') {\n                    if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n                        domNode[propName] = propValue;\n                        // Reset the value, even if the virtual DOM did not change\n                        domNode['oninput-value'] = undefined;\n                    }\n                    // else do not update the domNode, otherwise the cursor position would be changed\n                    if (propValue !== previousValue) {\n                        propertiesUpdated = true;\n                    }\n                } else if (propValue !== previousValue) {\n                    var type = typeof propValue;\n                    if (type === 'function') {\n                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');\n                    }\n                    if (type === 'string' && propName !== 'innerHTML') {\n                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                        } else {\n                            domNode.setAttribute(propName, propValue);\n                        }\n                    } else {\n                        if (domNode[propName] !== propValue) {\n                            domNode[propName] = propValue;\n                        }\n                    }\n                    propertiesUpdated = true;\n                }\n            }\n        }\n        return propertiesUpdated;\n    };\n    var findIndexOfChild = function (children, sameAs, start) {\n        if (sameAs.vnodeSelector !== '') {\n            // Never scan for text-nodes\n            for (var i = start; i < children.length; i++) {\n                if (same(children[i], sameAs)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    var nodeAdded = function (vNode, transitions) {\n        if (vNode.properties) {\n            var enterAnimation = vNode.properties.enterAnimation;\n            if (enterAnimation) {\n                if (typeof enterAnimation === 'function') {\n                    enterAnimation(vNode.domNode, vNode.properties);\n                } else {\n                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n                }\n            }\n        }\n    };\n    var nodeToRemove = function (vNode, transitions) {\n        var domNode = vNode.domNode;\n        if (vNode.properties) {\n            var exitAnimation = vNode.properties.exitAnimation;\n            if (exitAnimation) {\n                domNode.style.pointerEvents = 'none';\n                var removeDomNode = function () {\n                    if (domNode.parentNode) {\n                        domNode.parentNode.removeChild(domNode);\n                    }\n                };\n                if (typeof exitAnimation === 'function') {\n                    exitAnimation(domNode, removeDomNode, vNode.properties);\n                    return;\n                } else {\n                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n                    return;\n                }\n            }\n        }\n        if (domNode.parentNode) {\n            domNode.parentNode.removeChild(domNode);\n        }\n    };\n    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n        var childNode = childNodes[indexToCheck];\n        if (childNode.vnodeSelector === '') {\n            return;    // Text nodes need not be distinguishable\n        }\n        var properties = childNode.properties;\n        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;\n        if (!key) {\n            for (var i = 0; i < childNodes.length; i++) {\n                if (i !== indexToCheck) {\n                    var node = childNodes[i];\n                    if (same(node, childNode)) {\n                        if (operation === 'added') {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n                        } else {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n                        }\n                    }\n                }\n            }\n        }\n    };\n    var createDom;\n    var updateDom;\n    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n        if (oldChildren === newChildren) {\n            return false;\n        }\n        oldChildren = oldChildren || emptyArray;\n        newChildren = newChildren || emptyArray;\n        var oldChildrenLength = oldChildren.length;\n        var newChildrenLength = newChildren.length;\n        var transitions = projectionOptions.transitions;\n        var oldIndex = 0;\n        var newIndex = 0;\n        var i;\n        var textUpdated = false;\n        while (newIndex < newChildrenLength) {\n            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n            var newChild = newChildren[newIndex];\n            if (oldChild !== undefined && same(oldChild, newChild)) {\n                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n                oldIndex++;\n            } else {\n                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n                if (findOldIndex >= 0) {\n                    // Remove preceding missing children\n                    for (i = oldIndex; i < findOldIndex; i++) {\n                        nodeToRemove(oldChildren[i], transitions);\n                        checkDistinguishable(oldChildren, i, vnode, 'removed');\n                    }\n                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n                    oldIndex = findOldIndex + 1;\n                } else {\n                    // New child\n                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n                    nodeAdded(newChild, transitions);\n                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\n                }\n            }\n            newIndex++;\n        }\n        if (oldChildrenLength > oldIndex) {\n            // Remove child fragments\n            for (i = oldIndex; i < oldChildrenLength; i++) {\n                nodeToRemove(oldChildren[i], transitions);\n                checkDistinguishable(oldChildren, i, vnode, 'removed');\n            }\n        }\n        return textUpdated;\n    };\n    var addChildren = function (domNode, children, projectionOptions) {\n        if (!children) {\n            return;\n        }\n        for (var i = 0; i < children.length; i++) {\n            createDom(children[i], domNode, undefined, projectionOptions);\n        }\n    };\n    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n        addChildren(domNode, vnode.children, projectionOptions);\n        // children before properties, needed for value property of <select>.\n        if (vnode.text) {\n            domNode.textContent = vnode.text;\n        }\n        setProperties(domNode, vnode.properties, projectionOptions);\n        if (vnode.properties && vnode.properties.afterCreate) {\n            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [\n                domNode,\n                projectionOptions,\n                vnode.vnodeSelector,\n                vnode.properties,\n                vnode.children\n            ]);\n        }\n    };\n    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n        var domNode, i, c, start = 0, type, found;\n        var vnodeSelector = vnode.vnodeSelector;\n        if (vnodeSelector === '') {\n            domNode = vnode.domNode = document.createTextNode(vnode.text);\n            if (insertBefore !== undefined) {\n                parentNode.insertBefore(domNode, insertBefore);\n            } else {\n                parentNode.appendChild(domNode);\n            }\n        } else {\n            for (i = 0; i <= vnodeSelector.length; ++i) {\n                c = vnodeSelector.charAt(i);\n                if (i === vnodeSelector.length || c === '.' || c === '#') {\n                    type = vnodeSelector.charAt(start - 1);\n                    found = vnodeSelector.slice(start, i);\n                    if (type === '.') {\n                        domNode.classList.add(found);\n                    } else if (type === '#') {\n                        domNode.id = found;\n                    } else {\n                        if (found === 'svg') {\n                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n                        }\n                        if (projectionOptions.namespace !== undefined) {\n                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n                        } else {\n                            domNode = vnode.domNode = document.createElement(found);\n                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {\n                                // IE8 and older don't support setting input type after the DOM Node has been added to the document\n                                domNode.setAttribute('type', vnode.properties.type);\n                            }\n                        }\n                        if (insertBefore !== undefined) {\n                            parentNode.insertBefore(domNode, insertBefore);\n                        } else {\n                            parentNode.appendChild(domNode);\n                        }\n                    }\n                    start = i + 1;\n                }\n            }\n            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n        }\n    };\n    updateDom = function (previous, vnode, projectionOptions) {\n        var domNode = previous.domNode;\n        var textUpdated = false;\n        if (previous === vnode) {\n            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette\n        }\n        var updated = false;\n        if (vnode.vnodeSelector === '') {\n            if (vnode.text !== previous.text) {\n                var newVNode = document.createTextNode(vnode.text);\n                domNode.parentNode.replaceChild(newVNode, domNode);\n                vnode.domNode = newVNode;\n                textUpdated = true;\n                return textUpdated;\n            }\n        } else {\n            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n            }\n            if (previous.text !== vnode.text) {\n                updated = true;\n                if (vnode.text === undefined) {\n                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably\n                } else {\n                    domNode.textContent = vnode.text;\n                }\n            }\n            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n            if (vnode.properties && vnode.properties.afterUpdate) {\n                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [\n                    domNode,\n                    projectionOptions,\n                    vnode.vnodeSelector,\n                    vnode.properties,\n                    vnode.children\n                ]);\n            }\n        }\n        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n        }\n        vnode.domNode = previous.domNode;\n        return textUpdated;\n    };\n    var createProjection = function (vnode, projectionOptions) {\n        return {\n            update: function (updatedVnode) {\n                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n                }\n                updateDom(vnode, updatedVnode, projectionOptions);\n                vnode = updatedVnode;\n            },\n            domNode: vnode.domNode\n        };\n    };\n    ;\n    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.\n    exports.h = function (selector) {\n        var properties = arguments[1];\n        if (typeof selector !== 'string') {\n            throw new Error();\n        }\n        var childIndex = 1;\n        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n            childIndex = 2;\n        } else {\n            // Optional properties argument was omitted\n            properties = undefined;\n        }\n        var text = undefined;\n        var children = undefined;\n        var argsLength = arguments.length;\n        // Recognize a common special case where there is only a single text node\n        if (argsLength === childIndex + 1) {\n            var onlyChild = arguments[childIndex];\n            if (typeof onlyChild === 'string') {\n                text = onlyChild;\n            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n                text = onlyChild[0];\n            }\n        }\n        if (text === undefined) {\n            children = [];\n            for (; childIndex < argsLength; childIndex++) {\n                var child = arguments[childIndex];\n                if (child === null || child === undefined) {\n                    continue;\n                } else if (Array.isArray(child)) {\n                    appendChildren(selector, child, children);\n                } else if (child.hasOwnProperty('vnodeSelector')) {\n                    children.push(child);\n                } else {\n                    children.push(toTextVNode(child));\n                }\n            }\n        }\n        return {\n            vnodeSelector: selector,\n            properties: properties,\n            children: children,\n            text: text === '' ? undefined : text,\n            domNode: null\n        };\n    };\n    /**\n * Contains simple low-level utility functions to manipulate the real DOM.\n */\n    exports.dom = {\n        /**\n     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n     * its [[Projection.domNode|domNode]] property.\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection.\n     * @returns The [[Projection]] which also contains the DOM Node that was created.\n     */\n        create: function (vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Appends a new childnode to the DOM which is generated from a [[VNode]].\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param parentNode - The parent node for the new childNode.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n     * @returns The [[Projection]] that was created.\n     */\n        append: function (parentNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, parentNode, undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Inserts a new DOM node which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param beforeNode - The node that the DOM Node is inserted before.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n     * NOTE: [[VNode]] objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        insertBefore: function (beforeNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n     * This means that the virtual DOM and the real DOM will have one overlapping element.\n     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n     * may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        merge: function (element, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            vnode.domNode = element;\n            initPropertiesAndChildren(element, vnode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        }\n    };\n    /**\n * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n * For more information, see [[CalculationCache]].\n *\n * @param <Result> The type of the value that is cached.\n */\n    exports.createCache = function () {\n        var cachedInputs = undefined;\n        var cachedOutcome = undefined;\n        var result = {\n            invalidate: function () {\n                cachedOutcome = undefined;\n                cachedInputs = undefined;\n            },\n            result: function (inputs, calculation) {\n                if (cachedInputs) {\n                    for (var i = 0; i < inputs.length; i++) {\n                        if (cachedInputs[i] !== inputs[i]) {\n                            cachedOutcome = undefined;\n                        }\n                    }\n                }\n                if (!cachedOutcome) {\n                    cachedOutcome = calculation();\n                    cachedInputs = inputs;\n                }\n                return cachedOutcome;\n            }\n        };\n        return result;\n    };\n    /**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n *\n * @param <Source>       The type of source items. A database-record for instance.\n * @param <Target>       The type of target items. A [[Component]] for instance.\n * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n *                       to the `callback` argument in `Array.map(callback)`.\n * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n */\n    exports.createMapping = function (getSourceKey, createResult, updateResult) {\n        var keys = [];\n        var results = [];\n        return {\n            results: results,\n            map: function (newSources) {\n                var newKeys = newSources.map(getSourceKey);\n                var oldTargets = results.slice();\n                var oldIndex = 0;\n                for (var i = 0; i < newSources.length; i++) {\n                    var source = newSources[i];\n                    var sourceKey = newKeys[i];\n                    if (sourceKey === keys[oldIndex]) {\n                        results[i] = oldTargets[oldIndex];\n                        updateResult(source, oldTargets[oldIndex], i);\n                        oldIndex++;\n                    } else {\n                        var found = false;\n                        for (var j = 1; j < keys.length + 1; j++) {\n                            var searchIndex = (oldIndex + j) % keys.length;\n                            if (keys[searchIndex] === sourceKey) {\n                                results[i] = oldTargets[searchIndex];\n                                updateResult(newSources[i], oldTargets[searchIndex], i);\n                                oldIndex = searchIndex + 1;\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            results[i] = createResult(source, i);\n                        }\n                    }\n                }\n                results.length = newSources.length;\n                keys = newKeys;\n            }\n        };\n    };\n    /**\n * Creates a [[Projector]] instance using the provided projectionOptions.\n *\n * For more information, see [[Projector]].\n *\n * @param projectionOptions   Options that influence how the DOM is rendered and updated.\n */\n    exports.createProjector = function (projectorOptions) {\n        var projector;\n        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n            return function () {\n                // intercept function calls (event handlers) to do a render afterwards.\n                projector.scheduleRender();\n                return eventHandler.apply(properties.bind || this, arguments);\n            };\n        };\n        var renderCompleted = true;\n        var scheduled;\n        var stopped = false;\n        var projections = [];\n        var renderFunctions = [];\n        // matches the projections array\n        var doRender = function () {\n            scheduled = undefined;\n            if (!renderCompleted) {\n                return;    // The last render threw an error, it should be logged in the browser console.\n            }\n            renderCompleted = false;\n            for (var i = 0; i < projections.length; i++) {\n                var updatedVnode = renderFunctions[i]();\n                projections[i].update(updatedVnode);\n            }\n            renderCompleted = true;\n        };\n        projector = {\n            renderNow: doRender,\n            scheduleRender: function () {\n                if (!scheduled && !stopped) {\n                    scheduled = requestAnimationFrame(doRender);\n                }\n            },\n            stop: function () {\n                if (scheduled) {\n                    cancelAnimationFrame(scheduled);\n                    scheduled = undefined;\n                }\n                stopped = true;\n            },\n            resume: function () {\n                stopped = false;\n                renderCompleted = true;\n                projector.scheduleRender();\n            },\n            append: function (parentNode, renderMaquetteFunction) {\n                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            insertBefore: function (beforeNode, renderMaquetteFunction) {\n                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            merge: function (domNode, renderMaquetteFunction) {\n                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            replace: function (domNode, renderMaquetteFunction) {\n                var vnode = renderMaquetteFunction();\n                createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n                domNode.parentNode.removeChild(domNode);\n                projections.push(createProjection(vnode, projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            detach: function (renderMaquetteFunction) {\n                for (var i = 0; i < renderFunctions.length; i++) {\n                    if (renderFunctions[i] === renderMaquetteFunction) {\n                        renderFunctions.splice(i, 1);\n                        return projections.splice(i, 1)[0];\n                    }\n                }\n                throw new Error('renderMaquetteFunction was not found');\n            }\n        };\n        return projector;\n    };\n}));\n//# sourceMappingURL=maquette.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/maquette/dist/maquette.js\n// module id = 27\n// module chunks = 0","\"use strict\";\nvar lang_1 = require(\"@dojo/core/lang\");\nvar Symbol_1 = require(\"@dojo/shim/Symbol\");\nvar maquette_1 = require(\"maquette\");\nvar FactoryRegistry_1 = require(\"./FactoryRegistry\");\n/**\n * The symbol intifier for a WNode type\n */\nexports.WNODE = Symbol_1.default('Identifier for a WNode.');\n/**\n * The symbol intifier for a HNode type\n */\nexports.HNODE = Symbol_1.default('Identifier for a HNode.');\n/**\n * Helper function that returns true if the `DNode` is a `WNode` using the `type` property\n */\nfunction isWNode(child) {\n    return Boolean(child && (typeof child !== 'string') && child.type === exports.WNODE);\n}\nexports.isWNode = isWNode;\n/**\n * Helper function that returns true if the `DNode` is a `Node` using the `type` property\n */\nfunction isHNode(child) {\n    return Boolean(child && (typeof child !== 'string') && child.type === exports.HNODE);\n}\nexports.isHNode = isHNode;\nexports.registry = new FactoryRegistry_1.default();\nfunction w(factory, properties, children) {\n    if (children === void 0) { children = []; }\n    return {\n        children: children,\n        factory: factory,\n        properties: properties,\n        type: exports.WNODE\n    };\n}\nexports.w = w;\nfunction v(tag, propertiesOrChildren, children) {\n    if (propertiesOrChildren === void 0) { propertiesOrChildren = {}; }\n    if (children === void 0) { children = []; }\n    if (Array.isArray(propertiesOrChildren)) {\n        children = propertiesOrChildren;\n        propertiesOrChildren = {};\n    }\n    return {\n        children: children,\n        render: function (options) {\n            if (options === void 0) { options = {}; }\n            return maquette_1.h(tag, lang_1.assign(options, propertiesOrChildren), this.children);\n        },\n        type: exports.HNODE\n    };\n}\nexports.v = v;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widget-core/d.js\n// module id = 28\n// module chunks = 0","\"use strict\";\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar Map_1 = require(\"@dojo/shim/Map\");\nvar FactoryRegistry = (function () {\n    function FactoryRegistry() {\n        this.registry = new Map_1.default();\n    }\n    FactoryRegistry.prototype.has = function (factoryLabel) {\n        return this.registry.has(factoryLabel);\n    };\n    FactoryRegistry.prototype.define = function (factoryLabel, registryItem) {\n        if (this.registry.has(factoryLabel)) {\n            throw new Error(\"factory has already been registered for '\" + factoryLabel + \"'\");\n        }\n        this.registry.set(factoryLabel, registryItem);\n    };\n    FactoryRegistry.prototype.get = function (factoryLabel) {\n        var _this = this;\n        if (!this.has(factoryLabel)) {\n            return null;\n        }\n        var item = this.registry.get(factoryLabel);\n        if (compose_1.isComposeFactory(item) || item instanceof Promise_1.default) {\n            return item;\n        }\n        var promise = item();\n        this.registry.set(factoryLabel, promise);\n        return promise.then(function (factory) {\n            _this.registry.set(factoryLabel, factory);\n            return factory;\n        }, function (error) {\n            throw error;\n        });\n    };\n    return FactoryRegistry;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = FactoryRegistry;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widget-core/FactoryRegistry.js\n// module id = 29\n// module chunks = 0","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\"use strict\";\nvar decorators_1 = require(\"./support/decorators\");\nvar global_1 = require(\"./support/global\");\nvar iterator_1 = require(\"./iterator\");\nvar object_1 = require(\"./object\");\nrequire(\"./Symbol\");\nvar Shim;\n(function (Shim) {\n    /**\n     * An implementation analogous to the Map specification in ES2015.\n     */\n    var Map = (function () {\n        /**\n         * Creates a new Map\n         *\n         * @constructor\n         *\n         * @param iterator\n         * Array or iterator containing two-item tuples used to initially populate the map.\n         * The first item in each tuple corresponds to the key of the map entry.\n         * The second item corresponds to the value of the map entry.\n         */\n        function Map(iterable) {\n            var _this = this;\n            this._keys = [];\n            this._values = [];\n            this[Symbol.toStringTag] = 'Map';\n            if (iterable) {\n                iterator_1.forOf(iterable, function (value) {\n                    _this.set(value[0], value[1]);\n                });\n            }\n        }\n        /**\n         * An alternative to Array.prototype.indexOf using Object.is\n         * to check for equality. See http://mzl.la/1zuKO2V\n         */\n        Map.prototype._indexOfKey = function (keys, key) {\n            for (var i = 0, length_1 = keys.length; i < length_1; i++) {\n                if (object_1.is(keys[i], key)) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n        Object.defineProperty(Map.prototype, \"size\", {\n            /**\n             * Returns the number of key / value pairs in the Map.\n             *\n             * @return the number of key / value pairs in the Map\n             */\n            get: function () {\n                return this._keys.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Deletes all keys and their associated values.\n         */\n        Map.prototype.clear = function () {\n            this._keys.length = this._values.length = 0;\n        };\n        /**\n         * Deletes a given key and its associated value.\n         *\n         * @param key The key to delete\n         * @return true if the key exists, false if it does not\n         */\n        Map.prototype.delete = function (key) {\n            var index = this._indexOfKey(this._keys, key);\n            if (index < 0) {\n                return false;\n            }\n            this._keys.splice(index, 1);\n            this._values.splice(index, 1);\n            return true;\n        };\n        /**\n         * Returns an iterator that yields each key/value pair as an array.\n         *\n         * @return An iterator for each key/value pair in the instance.\n         */\n        Map.prototype.entries = function () {\n            var _this = this;\n            var values = this._keys.map(function (key, i) {\n                return [key, _this._values[i]];\n            });\n            return new iterator_1.ShimIterator(values);\n        };\n        /**\n         * Executes a given function for each map entry. The function\n         * is invoked with three arguments: the element value, the\n         * element key, and the associated Map instance.\n         *\n         * @param callback The function to execute for each map entry,\n         * @param context The value to use for `this` for each execution of the calback\n         */\n        Map.prototype.forEach = function (callback, context) {\n            var keys = this._keys;\n            var values = this._values;\n            for (var i = 0, length_2 = keys.length; i < length_2; i++) {\n                callback.call(context, values[i], keys[i], this);\n            }\n        };\n        /**\n         * Returns the value associated with a given key.\n         *\n         * @param key The key to look up\n         * @return The value if one exists or undefined\n         */\n        Map.prototype.get = function (key) {\n            var index = this._indexOfKey(this._keys, key);\n            return index < 0 ? undefined : this._values[index];\n        };\n        /**\n         * Checks for the presence of a given key.\n         *\n         * @param key The key to check for\n         * @return true if the key exists, false if it does not\n         */\n        Map.prototype.has = function (key) {\n            return this._indexOfKey(this._keys, key) > -1;\n        };\n        /**\n         * Returns an iterator that yields each key in the map.\n         *\n         * @return An iterator containing the instance's keys.\n         */\n        Map.prototype.keys = function () {\n            return new iterator_1.ShimIterator(this._keys);\n        };\n        /**\n         * Sets the value associated with a given key.\n         *\n         * @param key The key to define a value to\n         * @param value The value to assign\n         * @return The Map instance\n         */\n        Map.prototype.set = function (key, value) {\n            var index = this._indexOfKey(this._keys, key);\n            index = index < 0 ? this._keys.length : index;\n            this._keys[index] = key;\n            this._values[index] = value;\n            return this;\n        };\n        /**\n         * Returns an iterator that yields each value in the map.\n         *\n         * @return An iterator containing the instance's values.\n         */\n        Map.prototype.values = function () {\n            return new iterator_1.ShimIterator(this._values);\n        };\n        Map.prototype[Symbol.iterator] = function () {\n            return this.entries();\n        };\n        return Map;\n    }());\n    Shim.Map = Map;\n})(Shim = exports.Shim || (exports.Shim = {}));\nvar Map = (function () {\n    /* istanbul ignore next */\n    function Map(iterable) {\n        /* istanbul ignore next */\n        this[Symbol.toStringTag] = 'Map';\n    }\n    ;\n    Object.defineProperty(Map.prototype, \"size\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error('Abstract method'); },\n        enumerable: true,\n        configurable: true\n    });\n    ;\n    /* istanbul ignore next */\n    Map.prototype.clear = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.delete = function (key) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.entries = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.forEach = function (callback, context) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.get = function (key) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.has = function (key) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.keys = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.set = function (key, value) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.values = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype[Symbol.iterator] = function () { throw new Error('Abstract method'); };\n    ;\n    return Map;\n}());\nMap = __decorate([\n    decorators_1.hasClass('es6-map', global_1.default.Map, Shim.Map)\n], Map);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Map;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/Map.js\n// module id = 30\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./support/has\");\nvar Symbol_1 = require(\"./Symbol\");\nvar Shim;\n(function (Shim) {\n    function is(value1, value2) {\n        if (value1 === value2) {\n            return value1 !== 0 || 1 / value1 === 1 / value2; // -0\n        }\n        return value1 !== value1 && value2 !== value2; // NaN\n    }\n    Shim.is = is;\n    function getOwnPropertySymbols(o) {\n        return Object.getOwnPropertyNames(o).filter(function (key) { return Boolean(key.match(/^@@.+/)); })\n            .map(function (key) { return Symbol.for(key.substring(2)); });\n    }\n    Shim.getOwnPropertySymbols = getOwnPropertySymbols;\n    function getOwnPropertyNames(o) {\n        return Object.getOwnPropertyNames(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });\n    }\n    Shim.getOwnPropertyNames = getOwnPropertyNames;\n    function symbolAwareKeys(o) {\n        return Object.keys(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });\n    }\n    Shim.symbolAwareKeys = symbolAwareKeys;\n    function getOwnPropertyDescriptor(o, prop) {\n        if (Symbol_1.isSymbol(prop)) {\n            return Object.getOwnPropertyDescriptor(o, prop);\n        }\n        else {\n            return Object.getOwnPropertyDescriptor(o, prop);\n        }\n    }\n    Shim.getOwnPropertyDescriptor = getOwnPropertyDescriptor;\n    function values(o) {\n        return exports.keys(o).map(function (key) { return o[key]; });\n    }\n    Shim.values = values;\n    function entries(o) {\n        return exports.keys(o).map(function (key) { return [key, o[key]]; });\n    }\n    Shim.entries = entries;\n})(Shim || (Shim = {}));\n/**\n * Determines whether two values are the same value.\n *\n * @param value1 The first value to compare\n * @param value2 The second value to compare\n * @return true if the values are the same; false otherwise\n */\nexports.is = 'is' in Object\n    ? Object.is\n    : Shim.is;\n/**\n * Detect if there is native support for Symbol properties in Object\n */\nvar hasGetOwnPropertySymbols = has_1.default('es6-symbol') && 'getOwnPropertySymbols' in Object;\n/**\n * Returns an array of own properties who key is a symbol\n *\n * @param o The object to return the properties for\n */\nexports.getOwnPropertySymbols = hasGetOwnPropertySymbols\n    ? Object.getOwnPropertySymbols\n    : Shim.getOwnPropertySymbols;\n/**\n * Returns an array of own properties who key is a string\n *\n * @param o The object to return the properties for\n */\n/* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n * when there is no support for symbols */\nexports.getOwnPropertyNames = hasGetOwnPropertySymbols\n    ? Object.getOwnPropertyNames\n    : Shim.getOwnPropertyNames;\n/**\n * Returns the names of the enumerable properties and methods of an object.\n * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n */\n/* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n * when there is no support for symbols */\nexports.keys = hasGetOwnPropertySymbols\n    ? Object.keys\n    : Shim.symbolAwareKeys;\n/**\n * Returns the values of the enumerable properties and methods of an object.\n * @param o Object that contains the properties and methods.\n */\nexports.values = 'values' in Object\n    ? Object.values\n    : Shim.values;\n/**\n * Returns the keys and values of the enumerable properties and methods of an object. Each entry will be returned as an\n * array holding the [key, value].\n * @param o Object that contains the properties and methods.\n */\nexports.entries = 'entries' in Object\n    ? Object.entries\n    : Shim.entries;\nexports.getOwnPropertyDescriptor = hasGetOwnPropertySymbols\n    ? Object.getOwnPropertyDescriptor\n    : Shim.getOwnPropertyDescriptor;\nfunction getOwnPropertyDescriptorsWrapper(o) {\n    var descriptors = exports.getOwnPropertyNames(o).reduce(function (descriptors, key) {\n        descriptors[key] = exports.getOwnPropertyDescriptor(o, key);\n        return descriptors;\n    }, {});\n    exports.getOwnPropertySymbols(o).forEach(function (sym) {\n        descriptors[sym] = exports.getOwnPropertyDescriptor(o, sym);\n    });\n    return descriptors;\n}\n/* Return descriptors for enumerable and non enumerable properties on an object */\nexports.getOwnPropertyDescriptors = 'getOwnPropertyDescriptors' in Object\n    ? Object.getOwnPropertyDescriptors\n    : getOwnPropertyDescriptorsWrapper;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/object.js\n// module id = 31\n// module chunks = 0","import createRoute from '@dojo/routing/createRoute';\nimport createRouter from '@dojo/routing/createRouter';\nimport { Parameters } from '@dojo/routing/interfaces';\nimport createHashHistory from '@dojo/routing/history/createHashHistory';\n\nimport { filter as filterAction } from './actions/userActions';\n\ninterface FilterParameters extends Parameters {\n\tfilter: 'active' | 'all' | 'completed';\n}\n\nconst filterRoute = createRoute<FilterParameters>({\n\tpath: '/{filter}',\n\n\tparams([filter]) {\n\t\tswitch (filter) {\n\t\t\tcase 'active':\n\t\t\t\treturn { filter: 'active' };\n\t\t\tcase 'all':\n\t\t\t\treturn { filter: 'all' };\n\t\t\tcase 'completed':\n\t\t\t\treturn { filter: 'completed' };\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t},\n\n\texec(request) {\n\t\tconst { filter } = request.params;\n\t\treturn filterAction({ filter });\n\t}\n});\n\nconst router = createRouter({ history: createHashHistory() });\nrouter.append(filterRoute);\n\nexport default router;\n\n\n\n// WEBPACK FOOTER //\n// ./src/routes.ts","\"use strict\";\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar UrlSearchParams_1 = require(\"@dojo/core/UrlSearchParams\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar createRouter_1 = require(\"./createRouter\");\nvar path_1 = require(\"./lib/path\");\nvar privateStateMap = new WeakMap_1.default();\n// Store parent relationships in a separate map, since it's the parent that adds entries to this map. Parents shouldn't\n// change the private state of their children.\nvar parentMap = new WeakMap_1.default();\nvar noop = function () { };\nfunction computeDefaultParams(parameters, searchParameters, fromPathname, searchParams) {\n    var params = {};\n    parameters.forEach(function (name, index) {\n        params[name] = fromPathname[index];\n    });\n    searchParameters.forEach(function (name) {\n        var value = searchParams.get(name);\n        if (value !== undefined) {\n            params[name] = value;\n        }\n    });\n    return params;\n}\nvar createRoute = compose_1.default({\n    get parent() {\n        return parentMap.get(this);\n    },\n    get path() {\n        return privateStateMap.get(this).path;\n    },\n    append: function (add) {\n        var _this = this;\n        var routes = privateStateMap.get(this).routes;\n        var append = function (route) {\n            if (createRouter_1.hasBeenAppended(route)) {\n                throw new Error('Cannot append route that has already been appended');\n            }\n            routes.push(route);\n            parentMap.set(route, _this);\n        };\n        if (Array.isArray(add)) {\n            for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {\n                var route = add_1[_i];\n                append(route);\n            }\n        }\n        else {\n            append(add);\n        }\n    },\n    link: function (params) {\n        return createRouter_1.findRouter(this).link(this, params);\n    },\n    match: function (segments, hasTrailingSlash, searchParams) {\n        var _a = privateStateMap.get(this), computeParams = _a.computeParams, path = _a.path, trailingSlashMustMatch = _a.trailingSlashMustMatch;\n        var result = path_1.match(path, segments);\n        if (result === null) {\n            return null;\n        }\n        if (!result.hasRemaining && trailingSlashMustMatch && path.trailingSlash !== hasTrailingSlash) {\n            return null;\n        }\n        // Only extract the search params defined in the route's path.\n        var knownSearchParams = path.searchParameters.reduce(function (list, name) {\n            var value = searchParams.getAll(name);\n            if (value !== undefined) {\n                list[name] = value;\n            }\n            return list;\n        }, {});\n        var params = computeParams(result.values, new UrlSearchParams_1.default(knownSearchParams));\n        if (params === null) {\n            return null;\n        }\n        return {\n            hasRemaining: result.hasRemaining,\n            offset: result.offset,\n            params: params,\n            rawPathValues: result.values,\n            rawSearchParams: knownSearchParams\n        };\n    },\n    select: function (context, segments, hasTrailingSlash, searchParams) {\n        var _a = privateStateMap.get(this), exec = _a.exec, index = _a.index, fallback = _a.fallback, guard = _a.guard, path = _a.path, routes = _a.routes;\n        var matchResult = this.match(segments, hasTrailingSlash, searchParams);\n        // Return early if possible.\n        if (!matchResult || matchResult.hasRemaining && routes.length === 0 && !fallback) {\n            return [];\n        }\n        var params = matchResult.params;\n        if (guard) {\n            var guardResult = guard({ context: context, params: params });\n            if (typeof guardResult === 'string') {\n                return guardResult;\n            }\n            if (!guardResult) {\n                return [];\n            }\n        }\n        var handler = exec;\n        var redirect;\n        var remainingSelection;\n        var selected = false;\n        if (matchResult.hasRemaining) {\n            // Match the remaining segments. Return a hierarchy if nested routes were selected.\n            var remainingSegments_1 = segments.slice(matchResult.offset);\n            selected = routes.some(function (nested) {\n                var nestedResult = nested.select(context, remainingSegments_1, hasTrailingSlash, searchParams);\n                if (typeof nestedResult === 'string') {\n                    redirect = nestedResult;\n                    return true;\n                }\n                if (nestedResult.length > 0) {\n                    remainingSelection = nestedResult;\n                    return true;\n                }\n                return false;\n            });\n            // No remaining segments matched, only select this route if a fallback handler was specified.\n            if (!selected && fallback) {\n                selected = true;\n                handler = fallback;\n            }\n        }\n        else {\n            selected = true;\n            if (index) {\n                handler = index;\n            }\n        }\n        if (!selected) {\n            return [];\n        }\n        if (redirect !== undefined) {\n            return redirect;\n        }\n        var rawPathValues = matchResult.rawPathValues, rawSearchParams = matchResult.rawSearchParams;\n        var selection = {\n            // Use a noop handler if exec was not provided. Something needs to be returned otherwise the router may\n            // think no routes were selected.\n            handler: handler || noop,\n            path: path,\n            params: params,\n            rawPathValues: rawPathValues,\n            rawSearchParams: rawSearchParams,\n            route: this\n        };\n        return remainingSelection ? [selection].concat(remainingSelection) : [selection];\n    }\n}, function (instance, _a) {\n    var _b = _a === void 0 ? {} : _a, exec = _b.exec, fallback = _b.fallback, guard = _b.guard, index = _b.index, computeParams = _b.params, path = _b.path, _c = _b.trailingSlashMustMatch, trailingSlashMustMatch = _c === void 0 ? true : _c;\n    if (path && /#/.test(path)) {\n        throw new TypeError('Path must not contain \\'#\\'');\n    }\n    var deconstructedPath = path_1.deconstruct(path || '/');\n    var parameters = deconstructedPath.parameters, searchParameters = deconstructedPath.searchParameters;\n    if (computeParams) {\n        if (parameters.length === 0 && searchParameters.length === 0) {\n            throw new TypeError('Can\\'t specify params() if path doesn\\'t contain any');\n        }\n    }\n    else {\n        computeParams = function (fromPathname, searchParams) {\n            return computeDefaultParams(parameters, searchParameters, fromPathname, searchParams);\n        };\n    }\n    privateStateMap.set(instance, {\n        computeParams: computeParams,\n        exec: exec,\n        fallback: fallback,\n        guard: guard,\n        index: index,\n        path: deconstructedPath,\n        routes: [],\n        trailingSlashMustMatch: trailingSlashMustMatch\n    });\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createRoute;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/routing/createRoute.js\n// module id = 33\n// module chunks = 0","\"use strict\";\nvar lang_1 = require(\"./lang\");\n/**\n * Parses a query string, returning a ParamList object.\n */\nfunction parseQueryString(input) {\n    var query = {};\n    for (var _i = 0, _a = input.split('&'); _i < _a.length; _i++) {\n        var entry = _a[_i];\n        var indexOfFirstEquals = entry.indexOf('=');\n        var key = void 0;\n        var value = '';\n        if (indexOfFirstEquals >= 0) {\n            key = entry.slice(0, indexOfFirstEquals);\n            value = entry.slice(indexOfFirstEquals + 1);\n        }\n        else {\n            key = entry;\n        }\n        key = key ? decodeURIComponent(key) : '';\n        value = value ? decodeURIComponent(value) : '';\n        if (key in query) {\n            query[key].push(value);\n        }\n        else {\n            query[key] = [value];\n        }\n    }\n    return query;\n}\n/**\n * Represents a set of URL query search parameters.\n */\nvar UrlSearchParams = (function () {\n    /**\n     * Constructs a new UrlSearchParams from a query string, an object of parameters and values, or another\n     * UrlSearchParams.\n     */\n    function UrlSearchParams(input) {\n        var list;\n        if (input instanceof UrlSearchParams) {\n            // Copy the incoming UrlSearchParam's internal list\n            list = lang_1.duplicate(input._list);\n        }\n        else if (typeof input === 'object') {\n            // Copy the incoming object, assuming its property values are either arrays or strings\n            list = {};\n            for (var key in input) {\n                var value = input[key];\n                if (Array.isArray(value)) {\n                    list[key] = value.length ? value.slice() : [''];\n                }\n                else if (value == null) {\n                    list[key] = [''];\n                }\n                else {\n                    list[key] = [value];\n                }\n            }\n        }\n        else if (typeof input === 'string') {\n            // Parse the incoming string as a query string\n            list = parseQueryString(input);\n        }\n        else {\n            list = {};\n        }\n        Object.defineProperty(this, '_list', { value: list });\n    }\n    /**\n     * Appends a new value to the set of values for a key.\n     * @param key The key to add a value for\n     * @param value The value to add\n     */\n    UrlSearchParams.prototype.append = function (key, value) {\n        if (!this.has(key)) {\n            this.set(key, value);\n        }\n        else {\n            var values = this._list[key];\n            if (values) {\n                values.push(value);\n            }\n        }\n    };\n    /**\n     * Deletes all values for a key.\n     * @param key The key whose values are to be removed\n     */\n    UrlSearchParams.prototype.delete = function (key) {\n        // Set to undefined rather than deleting the key, for better consistency across browsers.\n        // If a deleted key is re-added, most browsers put it at the end of iteration order, but IE maintains\n        // its original position.  This approach maintains the original position everywhere.\n        this._list[key] = undefined;\n    };\n    /**\n     * Returns the first value associated with a key.\n     * @param key The key to return the first value for\n     * @return The first string value for the key\n     */\n    UrlSearchParams.prototype.get = function (key) {\n        if (!this.has(key)) {\n            return undefined;\n        }\n        var value = this._list[key];\n        return value ? value[0] : undefined;\n    };\n    /**\n     * Returns all the values associated with a key.\n     * @param key The key to return all values for\n     * @return An array of strings containing all values for the key\n     */\n    UrlSearchParams.prototype.getAll = function (key) {\n        if (!this.has(key)) {\n            return undefined;\n        }\n        return this._list[key];\n    };\n    /**\n     * Returns true if a key has been set to any value, false otherwise.\n     * @param key The key to test for existence\n     * @return A boolean indicating if the key has been set\n     */\n    UrlSearchParams.prototype.has = function (key) {\n        return Array.isArray(this._list[key]);\n    };\n    /**\n     * Returns an array of all keys which have been set.\n     * @return An array of strings containing all keys set in the UrlSearchParams instance\n     */\n    UrlSearchParams.prototype.keys = function () {\n        var keys = [];\n        for (var key in this._list) {\n            if (this.has(key)) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    };\n    /**\n     * Sets the value associated with a key.\n     * @param key The key to set the value of\n     */\n    UrlSearchParams.prototype.set = function (key, value) {\n        this._list[key] = [value];\n    };\n    /**\n     * Returns this object's data as an encoded query string.\n     * @return A string in application/x-www-form-urlencoded format containing all of the set keys/values\n     */\n    UrlSearchParams.prototype.toString = function () {\n        var query = [];\n        for (var key in this._list) {\n            if (!this.has(key)) {\n                continue;\n            }\n            var values = this._list[key];\n            if (values) {\n                var encodedKey = encodeURIComponent(key);\n                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n                    var value = values_1[_i];\n                    query.push(encodedKey + (value ? ('=' + encodeURIComponent(value)) : ''));\n                }\n            }\n        }\n        return query.join('&');\n    };\n    return UrlSearchParams;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = UrlSearchParams;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/UrlSearchParams.js\n// module id = 34\n// module chunks = 0","\"use strict\";\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar createEvented_1 = require(\"@dojo/compose/bases/createEvented\");\nvar Task_1 = require(\"@dojo/core/async/Task\");\nvar on_1 = require(\"@dojo/core/on\");\nvar UrlSearchParams_1 = require(\"@dojo/core/UrlSearchParams\");\nvar array_1 = require(\"@dojo/shim/array\");\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar path_1 = require(\"./lib/path\");\nvar parentMap = new WeakMap_1.default();\n/**\n * Whether the route has been appended to another route or router.\n */\nfunction hasBeenAppended(route) {\n    return parentMap.has(route) || route.parent !== undefined;\n}\nexports.hasBeenAppended = hasBeenAppended;\n/**\n * Finds the router whose route hierarchy the route has been appended to.\n *\n * Throws if the route was not appended to any router.\n */\nfunction findRouter(route) {\n    while (route.parent) {\n        route = route.parent;\n    }\n    var router = parentMap.get(route);\n    if (!router) {\n        throw new Error('Cannot generate link for route that is not in the hierarchy');\n    }\n    else {\n        return router;\n    }\n}\nexports.findRouter = findRouter;\nvar privateStateMap = new WeakMap_1.default();\n// istanbul ignore next\nvar noop = function () { };\nfunction createDeferral() {\n    // Use noop since TypeScript doesn't know we're assigning cancel and resume in the promise executor.\n    var cancel = noop;\n    var resume = noop;\n    var promise = new Promise_1.default(function (resolve, reject) {\n        cancel = reject;\n        // Wrap resolve to avoid resume being called with a thenable if type checking is not used.\n        resume = function () { return resolve(); };\n    });\n    return { cancel: cancel, promise: promise, resume: resume };\n}\nfunction reportError(router, context, path, error) {\n    router.emit({\n        context: context,\n        error: error,\n        path: path,\n        target: router,\n        type: 'error'\n    });\n}\nfunction catchRejection(router, context, path, thenable) {\n    if (thenable) {\n        Promise_1.default.resolve(thenable).catch(function (error) {\n            reportError(router, context, path, error);\n        });\n    }\n}\nvar createRouter = compose_1.default.mixin(createEvented_1.default, {\n    mixin: {\n        append: function (add) {\n            var _this = this;\n            var routes = privateStateMap.get(this).routes;\n            var append = function (route) {\n                if (hasBeenAppended(route)) {\n                    throw new Error('Cannot append route that has already been appended');\n                }\n                routes.push(route);\n                parentMap.set(route, _this);\n            };\n            if (Array.isArray(add)) {\n                for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {\n                    var route = add_1[_i];\n                    append(route);\n                }\n            }\n            else {\n                append(add);\n            }\n        },\n        dispatch: function (context, path) {\n            var _this = this;\n            var state = privateStateMap.get(this);\n            var dispatchFromStart = state.dispatchFromStart;\n            // Reset, any further calls can't have come from start(). This is necessary since the navstart listeners\n            // may call dispatch() themselves.\n            state.dispatchFromStart = false;\n            var canceled = false;\n            var cancel = function () {\n                canceled = true;\n            };\n            var deferrals = [];\n            this.emit({\n                cancel: cancel,\n                defer: function () {\n                    var _a = createDeferral(), cancel = _a.cancel, promise = _a.promise, resume = _a.resume;\n                    deferrals.push(promise);\n                    return { cancel: cancel, resume: resume };\n                },\n                path: path,\n                target: this,\n                type: 'navstart'\n            });\n            // Synchronous cancelation.\n            if (canceled) {\n                return Task_1.default.resolve({ success: false });\n            }\n            var _a = path_1.parse(path), searchParams = _a.searchParams, segments = _a.segments, trailingSlash = _a.trailingSlash;\n            return new Task_1.default(function (resolve, reject) {\n                // *Always* start dispatching in a future turn, even if there were no deferrals.\n                Promise_1.default.all(deferrals).then(function () {\n                    // The cancel() function used in the NavigationStartEvent is reused as the Task canceler.\n                    // Strictly speaking any navstart listener can cancel the dispatch asynchronously, as long as it\n                    // manages to do so before this turn.\n                    if (canceled) {\n                        return { success: false };\n                    }\n                    var fallback = state.fallback, routes = state.routes;\n                    var redirect;\n                    var dispatched = routes.some(function (route) {\n                        var result = route.select(context, segments, trailingSlash, searchParams);\n                        if (typeof result === 'string') {\n                            redirect = result;\n                            return true;\n                        }\n                        if (result.length === 0) {\n                            return false;\n                        }\n                        // Update the selected routes after selecting new routes, but before invoking the handlers.\n                        // This means the original value is available to guard() and params() functions, and the\n                        // new value when the newly selected routes are executed.\n                        //\n                        // Reset selected routes if not dispatched from start().\n                        state.currentSelection = dispatchFromStart ? result : [];\n                        for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {\n                            var _a = result_1[_i], handler = _a.handler, params = _a.params;\n                            catchRejection(_this, context, path, handler({ context: context, params: params }));\n                        }\n                        return true;\n                    });\n                    // Reset the selected routes if the dispatch was unsuccessful, or if a redirect was requested.\n                    if (!dispatched || redirect !== undefined) {\n                        state.currentSelection = [];\n                    }\n                    if (!dispatched && fallback) {\n                        catchRejection(_this, context, path, fallback({ context: context, params: {} }));\n                        return { success: false };\n                    }\n                    var result = { success: dispatched };\n                    if (redirect !== undefined) {\n                        result.redirect = redirect;\n                    }\n                    return result;\n                }, \n                // When deferrals are canceled their corresponding promise is rejected. Ensure the task resolves\n                // with `false` instead of being rejected too.\n                function () {\n                    return { success: false };\n                }).then(resolve, function (error) {\n                    reportError(_this, context, path, error);\n                    reject(error);\n                });\n            }, cancel);\n        },\n        link: function (route, params) {\n            if (params === void 0) { params = {}; }\n            var _a = privateStateMap.get(this), history = _a.history, roots = _a.routes, currentSelection = _a.currentSelection;\n            var hierarchy = [route];\n            for (var parent_1 = route.parent; parent_1 !== undefined; parent_1 = parent_1.parent) {\n                hierarchy.unshift(parent_1);\n            }\n            if (!array_1.includes(roots, hierarchy[0])) {\n                throw new Error('Cannot generate link for route that is not in the hierarchy');\n            }\n            var addLeadingSlash = hierarchy[0].path.leadingSlash;\n            var addTrailingSlash = false;\n            var segments = [];\n            var searchParams = new UrlSearchParams_1.default();\n            hierarchy\n                .map(function (route, index) {\n                var path = route.path;\n                var currentPathValues;\n                var currentSearchParams;\n                var selection = currentSelection[index];\n                if (selection && selection.route === route) {\n                    currentPathValues = selection.rawPathValues;\n                    currentSearchParams = selection.rawSearchParams;\n                }\n                return { currentPathValues: currentPathValues, currentSearchParams: currentSearchParams, path: path };\n            })\n                .forEach(function (_a) {\n                var currentPathValues = _a.currentPathValues, currentSearchParams = _a.currentSearchParams, path = _a.path;\n                var expectedSegments = path.expectedSegments, searchParameters = path.searchParameters, trailingSlash = path.trailingSlash;\n                addTrailingSlash = trailingSlash;\n                var namedOffset = 0;\n                for (var _i = 0, expectedSegments_1 = expectedSegments; _i < expectedSegments_1.length; _i++) {\n                    var segment = expectedSegments_1[_i];\n                    if (path_1.isNamedSegment(segment)) {\n                        var value = params[segment.name];\n                        if (typeof value === 'string') {\n                            segments.push(value);\n                        }\n                        else if (Array.isArray(value)) {\n                            if (value.length === 1) {\n                                segments.push(value[0]);\n                            }\n                            else {\n                                throw new TypeError(\"Cannot generate link, multiple values for parameter '\" + segment.name + \"'\");\n                            }\n                        }\n                        else if (currentPathValues) {\n                            segments.push(currentPathValues[namedOffset]);\n                        }\n                        else {\n                            throw new Error(\"Cannot generate link, missing parameter '\" + segment.name + \"'\");\n                        }\n                        namedOffset++;\n                    }\n                    else {\n                        segments.push(segment.literal);\n                    }\n                }\n                for (var _b = 0, searchParameters_1 = searchParameters; _b < searchParameters_1.length; _b++) {\n                    var key = searchParameters_1[_b];\n                    // Don't repeat the search parameter if a previous route in the hierarchy has already appended\n                    // it.\n                    if (searchParams.has(key)) {\n                        continue;\n                    }\n                    var value = params[key];\n                    if (typeof value === 'string') {\n                        searchParams.append(key, value);\n                    }\n                    else if (Array.isArray(value)) {\n                        for (var _c = 0, value_1 = value; _c < value_1.length; _c++) {\n                            var item = value_1[_c];\n                            searchParams.append(key, item);\n                        }\n                    }\n                    else if (currentSearchParams) {\n                        for (var _d = 0, _e = currentSearchParams[key]; _d < _e.length; _d++) {\n                            var item = _e[_d];\n                            searchParams.append(key, item);\n                        }\n                    }\n                    else {\n                        throw new Error(\"Cannot generate link, missing search parameter '\" + key + \"'\");\n                    }\n                }\n            });\n            var pathname = segments.join('/');\n            if (addLeadingSlash) {\n                pathname = '/' + pathname;\n            }\n            if (addTrailingSlash) {\n                pathname += '/';\n            }\n            if (history) {\n                pathname = history.prefix(pathname);\n            }\n            var search = searchParams.toString();\n            var path = search ? pathname + \"?\" + search : pathname;\n            return path;\n        },\n        replacePath: function (path) {\n            var history = privateStateMap.get(this).history;\n            if (!history) {\n                throw new Error('Cannot replace path, router was created without a history manager');\n            }\n            history.replace(path);\n        },\n        setPath: function (path) {\n            var history = privateStateMap.get(this).history;\n            if (!history) {\n                throw new Error('Cannot set path, router was created without a history manager');\n            }\n            history.set(path);\n        },\n        start: function (_a) {\n            var _this = this;\n            var dispatchCurrent = (_a === void 0 ? { dispatchCurrent: true } : _a).dispatchCurrent;\n            var state = privateStateMap.get(this);\n            if (state.started) {\n                throw new Error('start can only be called once');\n            }\n            state.started = true;\n            var contextFactory = state.contextFactory, history = state.history;\n            if (!history) {\n                return {\n                    pause: function () { },\n                    resume: function () { },\n                    destroy: function () { }\n                };\n            }\n            var lastDispatch;\n            var redirectCount = 0;\n            var redirecting = false;\n            var dispatch = function (path) {\n                if (lastDispatch) {\n                    lastDispatch.cancel();\n                }\n                // Reset redirect count if the dispatch was triggered by a non-redirect history change. This allows\n                // a route's exec / fallback / index handler to change the history, setting off a new flurry of\n                // redirects, without being encumbered by the number of redirects that led to that route being selected.\n                if (!redirecting) {\n                    redirectCount = 0;\n                }\n                // Signal to dispatch() that it was called from here.\n                state.dispatchFromStart = true;\n                var context = contextFactory();\n                lastDispatch = _this.dispatch(context, path).then(function (dispatchResult) {\n                    var _a = dispatchResult || { success: false }, success = _a.success, _b = _a.redirect, redirect = _b === void 0 ? undefined : _b;\n                    if (success && redirect !== undefined) {\n                        redirectCount++;\n                        if (redirectCount > 20) {\n                            var error = new Error('More than 20 redirects, giving up');\n                            reportError(_this, context, path, error);\n                            throw error;\n                        }\n                        redirecting = true;\n                        // The history manager MUST emit the change event synchronously.\n                        history.replace(redirect);\n                        redirecting = false;\n                    }\n                    return dispatchResult;\n                });\n            };\n            var listener = on_1.pausable(history, 'change', function (event) {\n                dispatch(event.value);\n            });\n            this.own(listener);\n            if (dispatchCurrent) {\n                dispatch(history.current);\n            }\n            return listener;\n        }\n    },\n    initialize: function (instance, _a) {\n        var _b = _a === void 0 ? {} : _a, context = _b.context, fallback = _b.fallback, history = _b.history;\n        var contextFactory;\n        if (typeof context === 'function') {\n            contextFactory = context;\n        }\n        else if (typeof context === 'undefined') {\n            contextFactory = function () {\n                return {};\n            };\n        }\n        else {\n            // Assign to a constant since the context variable may be changed after the function is defined,\n            // which would violate its typing.\n            var sharedContext_1 = context;\n            contextFactory = function () { return sharedContext_1; };\n        }\n        if (history) {\n            instance.own(history);\n        }\n        privateStateMap.set(instance, {\n            contextFactory: contextFactory,\n            currentSelection: [],\n            dispatchFromStart: false,\n            fallback: fallback,\n            history: history,\n            routes: []\n        });\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createRouter;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/routing/createRouter.js\n// module id = 35\n// module chunks = 0","\"use strict\";\nvar aspect_1 = require(\"@dojo/core/aspect\");\nvar Map_1 = require(\"@dojo/shim/Map\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar createDestroyable_1 = require(\"./createDestroyable\");\n/**\n * A weak map that contains a map of the listeners for an `Evented`\n */\nvar listenersMap = new WeakMap_1.default();\n/**\n * A guard which determines if the value is `Actionable`\n *\n * @param value The value to guard against\n */\nfunction isActionable(value) {\n    return Boolean(value && typeof value.do === 'function');\n}\n/**\n * An internal function that always returns an EventedCallback\n *\n * @param listener Either a `EventedCallback` or an `Actionable`\n */\nfunction resolveListener(listener) {\n    return isActionable(listener) ? function (event) { return listener.do({ event: event }); } : listener;\n}\nexports.resolveListener = resolveListener;\n/**\n * Internal function to convert an array of handles to a single handle\n *\n * @param handles The array of handles to convert into a signle handle\n * @return The single handle\n */\nfunction handlesArraytoHandle(handles) {\n    return {\n        destroy: function () {\n            handles.forEach(function (handle) { return handle.destroy(); });\n        }\n    };\n}\n/**\n * Creates a new instance of an `Evented`\n */\nvar createEvented = createDestroyable_1.default\n    .mixin({\n    className: 'Evented',\n    mixin: {\n        emit: function (event) {\n            var method = listenersMap.get(this).get(event.type);\n            if (method) {\n                method.call(this, event);\n            }\n        },\n        on: function () {\n            var _this = this;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var listenerMap = listenersMap.get(this);\n            if (args.length === 2) {\n                var _a = args, type_1 = _a[0], listeners = _a[1];\n                if (Array.isArray(listeners)) {\n                    var handles = listeners.map(function (listener) { return aspect_1.on(listenerMap, type_1, resolveListener(listener)); });\n                    return handlesArraytoHandle(handles);\n                }\n                else {\n                    return aspect_1.on(listenerMap, type_1, resolveListener(listeners));\n                }\n            }\n            else if (args.length === 1) {\n                var listenerMapArg_1 = args[0];\n                var handles = Object.keys(listenerMapArg_1).map(function (type) { return _this.on(type, listenerMapArg_1[type]); });\n                return handlesArraytoHandle(handles);\n            }\n            else {\n                throw new TypeError('Invalid arguments');\n            }\n        }\n    },\n    initialize: function (instance, options) {\n        listenersMap.set(instance, new Map_1.default());\n        if (options && options.listeners) {\n            instance.own(instance.on(options.listeners));\n        }\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createEvented;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/compose/bases/createEvented.js\n// module id = 36\n// module chunks = 0","\"use strict\";\nvar lang_1 = require(\"./lang\");\n/**\n * An internal type guard that determines if an value is MapLike or not\n *\n * @param value The value to guard against\n */\nfunction isMapLike(value) {\n    return value && typeof value.get === 'function' && typeof value.set === 'function';\n}\n/**\n * A UID for tracking advice ordering\n */\nvar nextId = 0;\n/**\n * Internal function that advises a join point\n *\n * @param dispatcher The current advice dispatcher\n * @param type The type of before or after advice to apply\n * @param advice The advice to apply\n * @param receiveArguments If true, the advice will receive the arguments passed to the join point\n * @return The handle that will remove the advice\n */\nfunction advise(dispatcher, type, advice, receiveArguments) {\n    var previous = dispatcher && dispatcher[type];\n    var advised = {\n        id: nextId++,\n        advice: advice,\n        receiveArguments: receiveArguments\n    };\n    if (previous) {\n        if (type === 'after') {\n            // add the listener to the end of the list\n            // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n            while (previous.next && (previous = previous.next)) { }\n            previous.next = advised;\n            advised.previous = previous;\n        }\n        else {\n            // add to the beginning\n            if (dispatcher) {\n                dispatcher.before = advised;\n            }\n            advised.next = previous;\n            previous.previous = advised;\n        }\n    }\n    else {\n        dispatcher && (dispatcher[type] = advised);\n    }\n    advice = previous = undefined;\n    return lang_1.createHandle(function () {\n        var _a = (advised || {}), _b = _a.previous, previous = _b === void 0 ? undefined : _b, _c = _a.next, next = _c === void 0 ? undefined : _c;\n        if (dispatcher && !previous && !next) {\n            dispatcher[type] = undefined;\n        }\n        else {\n            if (previous) {\n                previous.next = next;\n            }\n            else {\n                dispatcher && (dispatcher[type] = next);\n            }\n            if (next) {\n                next.previous = previous;\n            }\n        }\n        if (advised) {\n            delete advised.advice;\n        }\n        dispatcher = advised = undefined;\n    });\n}\n/**\n * An internal function that resolves or creates the dispatcher for a given join point\n *\n * @param target The target object or map\n * @param methodName The name of the method that the dispatcher should be resolved for\n * @return The dispatcher\n */\nfunction getDispatcher(target, methodName) {\n    var existing = isMapLike(target) ? target.get(methodName) : target && target[methodName];\n    var dispatcher;\n    if (!existing || existing.target !== target) {\n        /* There is no existing dispatcher, therefore we will create one */\n        dispatcher = function () {\n            var executionId = nextId;\n            var args = arguments;\n            var results;\n            var before = dispatcher.before;\n            while (before) {\n                if (before.advice) {\n                    args = before.advice.apply(this, args) || args;\n                }\n                before = before.next;\n            }\n            if (dispatcher.around && dispatcher.around.advice) {\n                results = dispatcher.around.advice(this, args);\n            }\n            var after = dispatcher.after;\n            while (after && after.id < executionId) {\n                if (after.advice) {\n                    if (after.receiveArguments) {\n                        var newResults = after.advice.apply(this, args);\n                        results = newResults === undefined ? results : newResults;\n                    }\n                    else {\n                        results = after.advice.call(this, results, args);\n                    }\n                }\n                after = after.next;\n            }\n            return results;\n        };\n        if (isMapLike(target)) {\n            target.set(methodName, dispatcher);\n        }\n        else {\n            target && (target[methodName] = dispatcher);\n        }\n        if (existing) {\n            dispatcher.around = {\n                advice: function (target, args) {\n                    return existing.apply(target, args);\n                }\n            };\n        }\n        dispatcher.target = target;\n    }\n    else {\n        dispatcher = existing;\n    }\n    return dispatcher;\n}\n/**\n * Attaches \"after\" advice to be executed after the original method.\n * The advising function will receive the original method's return value and arguments object.\n * The value it returns will be returned from the method when it is called (even if the return value is undefined).\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original method's return value and arguments object\n * @return A handle which will remove the aspect when destroy is called\n */\nfunction after(target, methodName, advice) {\n    return advise(getDispatcher(target, methodName), 'after', advice);\n}\nexports.after = after;\n/**\n * Attaches \"around\" advice around the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original function\n * @return A handle which will remove the aspect when destroy is called\n */\nfunction around(target, methodName, advice) {\n    var dispatcher = getDispatcher(target, methodName);\n    var previous = dispatcher.around;\n    var advised;\n    if (advice) {\n        advised = advice(function () {\n            if (previous && previous.advice) {\n                return previous.advice(this, arguments);\n            }\n        });\n    }\n    dispatcher.around = {\n        advice: function (target, args) {\n            return advised ? advised.apply(target, args) : previous && previous.advice && previous.advice(target, args);\n        }\n    };\n    return lang_1.createHandle(function () {\n        advised = dispatcher = undefined;\n    });\n}\nexports.around = around;\n/**\n * Attaches \"before\" advice to be executed before the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n * @return A handle which will remove the aspect when destroy is called\n */\nfunction before(target, methodName, advice) {\n    return advise(getDispatcher(target, methodName), 'before', advice);\n}\nexports.before = before;\n/**\n * Attaches advice to be executed after the original method.\n * The advising function will receive the same arguments as the original method.\n * The value it returns will be returned from the method when it is called *unless* its return value is undefined.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original method\n * @return A handle which will remove the aspect when destroy is called\n */\nfunction on(target, methodName, advice) {\n    return advise(getDispatcher(target, methodName), 'after', advice, true);\n}\nexports.on = on;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/aspect.js\n// module id = 37\n// module chunks = 0","\"use strict\";\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar compose_1 = require(\"../compose\");\n/**\n * A reference to a function that always returns a promise which resolves to false\n */\nfunction noop() {\n    return Promise_1.default.resolve(false);\n}\n/**\n * A reference to a function that throws, used to replace the `own()` method after\n * destruction\n */\nfunction destroyed() {\n    throw new Error('Call made to destroyed method');\n}\n/**\n * A weak map for *owning* handles on instances\n */\nvar handlesWeakMap = new WeakMap_1.default();\n/**\n * A type guard that determines if the value is a Destroyable\n *\n * @param value The value to guard for\n */\nfunction isDestroyable(value) {\n    return Boolean(value && 'destroy' in value && typeof value.destroy === 'function');\n}\nexports.isDestroyable = isDestroyable;\n/**\n * A mixin which adds the concepts of being able to *destroy* handles which the instance\n * *owns*\n */\nvar createDestroyable = compose_1.default('Destroyable', {\n    own: function (handle) {\n        var handles = handlesWeakMap.get(this);\n        handles.push(handle);\n        return {\n            destroy: function () {\n                handles.splice(handles.indexOf(handle));\n                handle.destroy();\n            }\n        };\n    },\n    destroy: function () {\n        var _this = this;\n        return new Promise_1.default(function (resolve) {\n            handlesWeakMap.get(_this).forEach(function (handle) {\n                handle && handle.destroy && handle.destroy();\n            });\n            _this.destroy = noop;\n            _this.own = destroyed;\n            resolve(true);\n        });\n    }\n}, function (instance) {\n    handlesWeakMap.set(instance, []);\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createDestroyable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/compose/bases/createDestroyable.js\n// module id = 38\n// module chunks = 0","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\"use strict\";\nvar ExtensiblePromise_1 = require(\"./ExtensiblePromise\");\n/**\n * A type guard that determines if `value` is a `Task`\n * @param value The value to guard\n */\nfunction isTask(value) {\n    return Boolean(value && typeof value.cancel === 'function' && Array.isArray(value.children) && isThenable(value));\n}\nexports.isTask = isTask;\n/**\n * Returns true if a given value has a `then` method.\n * @param {any} value The value to check if is Thenable\n * @returns {is Thenable<T>} A type guard if the value is thenable\n */\nfunction isThenable(value) {\n    return value && typeof value.then === 'function';\n}\nexports.isThenable = isThenable;\n/**\n * Task is an extension of Promise that supports cancellation and the Task#finally method.\n */\nvar Task = (function (_super) {\n    __extends(Task, _super);\n    /**\n     * @constructor\n     *\n     * Create a new task. Executor is run immediately. The canceler will be called when the task is canceled.\n     *\n     * @param executor Method that initiates some task\n     * @param canceler Method to call when the task is canceled\n     *\n     */\n    function Task(executor, canceler) {\n        var _this = this;\n        // we have to initialize these to avoid a compiler error of using them before they are initialized\n        var superResolve = function () { };\n        var superReject = function () { };\n        _this = _super.call(this, function (resolve, reject) {\n            superResolve = resolve;\n            superReject = reject;\n        }) || this;\n        _this._state = 1 /* Pending */;\n        _this.children = [];\n        _this.canceler = function () {\n            if (canceler) {\n                canceler();\n            }\n            _this._cancel();\n        };\n        // Don't let the Task resolve if it's been canceled\n        try {\n            executor(function (value) {\n                if (_this._state === 3 /* Canceled */) {\n                    return;\n                }\n                _this._state = 0 /* Fulfilled */;\n                superResolve(value);\n            }, function (reason) {\n                if (_this._state === 3 /* Canceled */) {\n                    return;\n                }\n                _this._state = 2 /* Rejected */;\n                superReject(reason);\n            });\n        }\n        catch (reason) {\n            _this._state = 2 /* Rejected */;\n            superReject(reason);\n        }\n        return _this;\n    }\n    /**\n     * Return a Task that resolves when one of the passed in objects have resolved\n     *\n     * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns {Task}\n     */\n    Task.race = function (iterable) {\n        return _super.race.call(this, iterable);\n    };\n    /**\n     * Return a rejected promise wrapped in a Task\n     *\n     * @param {Error?} reason    The reason for the rejection\n     * @returns {Task}\n     */\n    Task.reject = function (reason) {\n        return new this(function (resolve, reject) { return reject(reason); });\n    };\n    Task.resolve = function (value) {\n        return new this(function (resolve, reject) { return resolve(value); });\n    };\n    Task.all = function (iterable) {\n        return _super.all.call(this, iterable);\n    };\n    Object.defineProperty(Task.prototype, \"state\", {\n        get: function () {\n            return this._state;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Propagates cancellation down through a Task tree. The Task's state is immediately set to canceled. If a Thenable\n     * finally task was passed in, it is resolved before calling this Task's finally callback; otherwise, this Task's\n     * finally callback is immediately executed. `_cancel` is called for each child Task, passing in the value returned\n     * by this Task's finally callback or a Promise chain that will eventually resolve to that value.\n     */\n    Task.prototype._cancel = function (finallyTask) {\n        var _this = this;\n        this._state = 3 /* Canceled */;\n        var runFinally = function () {\n            try {\n                return _this._finally();\n            }\n            catch (error) {\n            }\n        };\n        if (this._finally) {\n            if (isThenable(finallyTask)) {\n                finallyTask = finallyTask.then(runFinally, runFinally);\n            }\n            else {\n                finallyTask = runFinally();\n            }\n        }\n        this.children.forEach(function (child) {\n            child._cancel(finallyTask);\n        });\n    };\n    /**\n     * Immediately cancels this task if it has not already resolved. This Task and any descendants are synchronously set\n     * to the Canceled state and any `finally` added downstream from the canceled Task are invoked.\n     */\n    Task.prototype.cancel = function () {\n        if (this._state === 1 /* Pending */) {\n            this.canceler();\n        }\n    };\n    Task.prototype.catch = function (onRejected) {\n        return this.then(undefined, onRejected);\n    };\n    /**\n     * Allows for cleanup actions to be performed after resolution of a Promise.\n     */\n    Task.prototype.finally = function (callback) {\n        // if this task is already canceled, call the task\n        if (this._state === 3 /* Canceled */) {\n            return Task.resolve(callback());\n        }\n        var task = this.then(function (value) { return Task.resolve(callback()).then(function () { return value; }); }, function (reason) { return Task.resolve(callback()).then(function () {\n            throw reason;\n        }); });\n        // Keep a reference to the callback; it will be called if the Task is canceled\n        task._finally = callback;\n        return task;\n    };\n    Task.prototype.then = function (onFulfilled, onRejected) {\n        var _this = this;\n        // FIXME\n        // tslint:disable-next-line:no-var-keyword\n        var task = _super.prototype.then.call(this, \n        // Don't call the onFulfilled or onRejected handlers if this Task is canceled\n        function (value) {\n            if (task._state === 3 /* Canceled */) {\n                return;\n            }\n            if (onFulfilled) {\n                return onFulfilled(value);\n            }\n            return value;\n        }, function (error) {\n            if (task._state === 3 /* Canceled */) {\n                return;\n            }\n            if (onRejected) {\n                return onRejected(error);\n            }\n            throw error;\n        });\n        task.canceler = function () {\n            // If task's parent (this) hasn't been resolved, cancel it; downward propagation will start at the first\n            // unresolved parent\n            if (_this._state === 1 /* Pending */) {\n                _this.cancel();\n            }\n            else {\n                task._cancel();\n            }\n        };\n        // Keep track of child Tasks for propogating cancelation back down the chain\n        this.children.push(task);\n        return task;\n    };\n    return Task;\n}(ExtensiblePromise_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Task;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/async/Task.js\n// module id = 39\n// module chunks = 0","\"use strict\";\nvar iterator_1 = require(\"@dojo/shim/iterator\");\nvar Promise_1 = require(\"@dojo/shim/Promise\");\n/**\n * Take a list of values, and if any are ExtensiblePromise objects, insert the wrapped Promise in its place,\n * otherwise use the original object. We use this to help use the native Promise methods like `all` and `race`.\n *\n * @param iterable    The list of objects to iterate over\n * @returns {any[]}    The list of objects, as an array, with ExtensiblePromises being replaced by Promises.\n */\nfunction unwrapPromises(iterable) {\n    var unwrapped = [];\n    iterator_1.forOf(iterable, function (item) {\n        unwrapped.push(item instanceof ExtensiblePromise ? item._promise : item);\n    });\n    return unwrapped;\n}\n/**\n * An extensible base to allow Promises to be extended in ES5. This class basically wraps a native Promise object,\n * giving an API like a native promise.\n */\nvar ExtensiblePromise = (function () {\n    /**\n     * Creates a new extended Promise.\n     *\n     * @constructor\n     *\n     * @param executor\n     * The executor function is called immediately when the Promise is instantiated. It is responsible for\n     * starting the asynchronous operation when it is invoked.\n     *\n     * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n     * successfully, or the `reject` function when the operation fails.\n     */\n    function ExtensiblePromise(executor) {\n        this._promise = new Promise_1.default(executor);\n    }\n    /**\n     * Return a rejected promise wrapped in an ExtensiblePromise\n     *\n     * @param {Error?} reason    The reason for the rejection\n     * @returns {ExtensiblePromise}\n     */\n    ExtensiblePromise.reject = function (reason) {\n        return new this(function (resolve, reject) { return reject(reason); });\n    };\n    ExtensiblePromise.resolve = function (value) {\n        return new this(function (resolve, reject) { return resolve(value); });\n    };\n    ExtensiblePromise.all = function (iterable) {\n        if (!iterator_1.isArrayLike(iterable) && !iterator_1.isIterable(iterable)) {\n            var promiseKeys_1 = Object.keys(iterable);\n            return new this(function (resolve, reject) {\n                Promise_1.default.all(promiseKeys_1.map(function (key) { return iterable[key]; })).then(function (promiseResults) {\n                    var returnValue = {};\n                    promiseResults.forEach(function (value, index) {\n                        returnValue[promiseKeys_1[index]] = value;\n                    });\n                    resolve(returnValue);\n                }, reject);\n            });\n        }\n        return new this(function (resolve, reject) {\n            Promise_1.default.all(unwrapPromises(iterable)).then(resolve, reject);\n        });\n    };\n    /**\n     * Return a ExtensiblePromise that resolves when one of the passed in objects have resolved\n     *\n     * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns {ExtensiblePromise}\n     */\n    ExtensiblePromise.race = function (iterable) {\n        return new this(function (resolve, reject) {\n            Promise_1.default.race(unwrapPromises(iterable)).then(resolve, reject);\n        });\n    };\n    ExtensiblePromise.prototype.catch = function (onRejected) {\n        return this.then(undefined, onRejected);\n    };\n    ExtensiblePromise.prototype.then = function (onFulfilled, onRejected) {\n        var _this = this;\n        var e = function (resolve, reject) {\n            function handler(rejected, valueOrError) {\n                var callback = rejected ? onRejected : onFulfilled;\n                if (typeof callback === 'function') {\n                    try {\n                        resolve(callback(valueOrError));\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                }\n                else if (rejected) {\n                    reject(valueOrError);\n                }\n                else {\n                    resolve(valueOrError);\n                }\n            }\n            _this._promise.then(handler.bind(null, false), handler.bind(null, true));\n        };\n        return new this.constructor(e);\n    };\n    return ExtensiblePromise;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ExtensiblePromise;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/async/ExtensiblePromise.js\n// module id = 40\n// module chunks = 0","\"use strict\";\nvar lang_1 = require(\"./lang\");\nfunction emit(target, event) {\n    if (target.dispatchEvent &&\n        ((target.ownerDocument && target.ownerDocument.createEvent) ||\n            (target.document && target.document.createEvent) ||\n            target.createEvent) /* matches document */) {\n        var nativeEvent = (target.ownerDocument || target.document || target).createEvent('HTMLEvents');\n        nativeEvent.initEvent(event.type, Boolean(event.bubbles), Boolean(event.cancelable));\n        for (var key in event) {\n            if (!(key in nativeEvent)) {\n                nativeEvent[key] = event[key];\n            }\n        }\n        return target.dispatchEvent(nativeEvent);\n    }\n    if (target.emit) {\n        if (target.removeListener) {\n            // Node.js EventEmitter\n            target.emit(event.type, event);\n            return false;\n        }\n        else if (target.on) {\n            // Dojo Evented or similar\n            target.emit(event);\n            return false;\n        }\n    }\n    throw new Error('Target must be an event emitter');\n}\nexports.emit = emit;\nfunction on(target, type, listener, capture) {\n    if (Array.isArray(type)) {\n        var handles = type.map(function (type) {\n            return on(target, type, listener, capture);\n        });\n        return lang_1.createCompositeHandle.apply(void 0, handles);\n    }\n    var callback = function () {\n        listener.apply(this, arguments);\n    };\n    // DOM EventTarget\n    if (target.addEventListener && target.removeEventListener) {\n        target.addEventListener(type, callback, capture);\n        return lang_1.createHandle(function () {\n            target.removeEventListener(type, callback, capture);\n        });\n    }\n    if (target.on) {\n        // EventEmitter\n        if (target.removeListener) {\n            target.on(type, callback);\n            return lang_1.createHandle(function () {\n                target.removeListener(type, callback);\n            });\n        }\n        else if (target.emit) {\n            return target.on(type, listener);\n        }\n    }\n    throw new TypeError('Unknown event emitter object');\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = on;\nfunction once(target, type, listener, capture) {\n    // FIXME\n    // tslint:disable-next-line:no-var-keyword\n    var handle = on(target, type, function () {\n        handle.destroy();\n        return listener.apply(this, arguments);\n    }, capture);\n    return handle;\n}\nexports.once = once;\nfunction pausable(target, type, listener, capture) {\n    var paused;\n    var handle = on(target, type, function () {\n        if (!paused) {\n            return listener.apply(this, arguments);\n        }\n    }, capture);\n    handle.pause = function () {\n        paused = true;\n    };\n    handle.resume = function () {\n        paused = false;\n    };\n    return handle;\n}\nexports.pausable = pausable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/on.js\n// module id = 41\n// module chunks = 0","\"use strict\";\nvar UrlSearchParams_1 = require(\"@dojo/core/UrlSearchParams\");\n/**\n * Parses a path\n * @param path The path to parse.\n * @return The search params, pathname segments, and whether it ended with a trailing slash.\n */\nfunction parse(path) {\n    var tokens = path.split(/([/?#])/).filter(Boolean);\n    var pathnameTokens = tokens;\n    var searchParams;\n    var searchStart = tokens.indexOf('?');\n    var hashStart = tokens.indexOf('#');\n    if (searchStart >= 0) {\n        if (hashStart >= 0) {\n            // Either `/foo?bar#baz` or `/foo#bar?baz`\n            pathnameTokens = tokens.slice(0, Math.min(searchStart, hashStart));\n            searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1, hashStart).join(''));\n        }\n        else {\n            // `/foo?bar`\n            pathnameTokens = tokens.slice(0, searchStart);\n            searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1).join(''));\n        }\n    }\n    else {\n        searchParams = new UrlSearchParams_1.default();\n        if (hashStart >= 0) {\n            // `/foo#bar`\n            pathnameTokens = tokens.slice(0, hashStart);\n        }\n    }\n    var segments = pathnameTokens.filter(function (t) { return t !== '/'; });\n    var trailingSlash = pathnameTokens[pathnameTokens.length - 1] === '/' && segments.length > 0;\n    return {\n        searchParams: searchParams,\n        segments: segments,\n        trailingSlash: trailingSlash\n    };\n}\nexports.parse = parse;\n/**\n * Determines whether a DeconstructedPath is a (partial) match for given pathname segments.\n * @param expectedSegments Part of a DeconstructedPath object.\n * @param segments Pathname segments as returned by `parse()`\n * @return A result object.\n */\nfunction match(_a, segments) {\n    var expectedSegments = _a.expectedSegments;\n    if (expectedSegments.length === 0) {\n        return {\n            hasRemaining: segments.length > 0,\n            offset: 0,\n            values: []\n        };\n    }\n    if (expectedSegments.length > segments.length) {\n        return null;\n    }\n    var isMatch = true;\n    var values = [];\n    for (var i = 0; isMatch && i < expectedSegments.length; i++) {\n        var value = segments[i];\n        var expected = expectedSegments[i];\n        if (isNamedSegment(expected)) {\n            values.push(value);\n        }\n        else if (expected.literal !== value) {\n            isMatch = false;\n        }\n    }\n    if (!isMatch) {\n        return null;\n    }\n    return {\n        hasRemaining: expectedSegments.length < segments.length,\n        offset: expectedSegments.length,\n        values: values\n    };\n}\nexports.match = match;\n/**\n * Determine whether the segment is a NamedSegment.\n *\n * @param segment The segment to be checked\n * @return true if the segment is a NamedSegment, false otherwise\n */\nfunction isNamedSegment(segment) {\n    return segment.name !== undefined;\n}\nexports.isNamedSegment = isNamedSegment;\n/**\n * Deconstruct a route path into its constituent parts.\n * @param path The path to deconstruct.\n * @return An object describing the path's constituent parts.\n */\nfunction deconstruct(path) {\n    var expectedSegments = [];\n    var parameters = [];\n    var searchParameters = [];\n    var trailingSlash = false;\n    var tokens = path.split(/([/{}?&])/).filter(Boolean);\n    var leadingSlash = tokens[0] === '/';\n    var i = 0;\n    var consume = function () { return tokens[i++]; };\n    var peek = function () { return tokens[i]; };\n    var inSearchComponent = false;\n    while (i < tokens.length) {\n        var t = consume();\n        switch (t) {\n            case '{': {\n                var name_1 = consume();\n                if (!name_1 || name_1 === '}') {\n                    throw new TypeError('Parameter must have a name');\n                }\n                // Reserve : for future use, e.g. including type data in the parameter declaration.\n                if (name_1 === '{' || name_1 === '&' || /:/.test(name_1)) {\n                    throw new TypeError('Parameter name must not contain \\'{\\', \\'&\\' or \\':\\'');\n                }\n                if (parameters.indexOf(name_1) !== -1 || searchParameters.indexOf(name_1) !== -1) {\n                    throw new TypeError(\"Parameter must have a unique name, got '\" + name_1 + \"'\");\n                }\n                var closing = consume();\n                if (!closing || closing !== '}') {\n                    throw new TypeError(\"Parameter name must be followed by '}', got '\" + closing + \"'\");\n                }\n                var separator = peek();\n                if (separator) {\n                    if (inSearchComponent) {\n                        if (separator !== '&') {\n                            throw new TypeError(\"Search parameter must be followed by '&', got '\" + separator + \"'\");\n                        }\n                    }\n                    else if (separator !== '/' && separator !== '?') {\n                        throw new TypeError(\"Parameter must be followed by '/' or '?', got '\" + separator + \"'\");\n                    }\n                }\n                if (inSearchComponent) {\n                    searchParameters.push(name_1);\n                }\n                else {\n                    parameters.push(name_1);\n                    expectedSegments.push(Object.freeze({ name: name_1 }));\n                }\n                break;\n            }\n            case '?':\n            case '/':\n                if (inSearchComponent) {\n                    throw new TypeError(\"Expected parameter in search component, got '\" + t + \"'\");\n                }\n                if (t === '?') {\n                    inSearchComponent = true;\n                    if (expectedSegments.length === 0) {\n                        throw new TypeError('Path must contain at least one segment');\n                    }\n                }\n                if (t === '/') {\n                    var next_1 = peek();\n                    if (next_1 === '/') {\n                        throw new TypeError('Path segment must not be empty');\n                    }\n                    if (expectedSegments.length > 0 && (!next_1 || next_1 === '?')) {\n                        trailingSlash = true;\n                    }\n                }\n                break;\n            case '&':\n                if (!inSearchComponent) {\n                    throw new TypeError('Path segment must not contain \\'&\\'');\n                }\n                var next = peek();\n                if (next === '&') {\n                    throw new TypeError('Expected parameter in search component, got \\'&\\'');\n                }\n                break;\n            default:\n                if (inSearchComponent) {\n                    throw new TypeError(\"Expected parameter in search component, got '\" + t + \"'\");\n                }\n                expectedSegments.push(Object.freeze({ literal: t }));\n        }\n    }\n    return Object.freeze({\n        expectedSegments: Object.freeze(expectedSegments),\n        leadingSlash: leadingSlash,\n        parameters: Object.freeze(parameters),\n        searchParameters: Object.freeze(searchParameters),\n        trailingSlash: trailingSlash\n    });\n}\nexports.deconstruct = deconstruct;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/routing/lib/path.js\n// module id = 42\n// module chunks = 0","\"use strict\";\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar createEvented_1 = require(\"@dojo/compose/bases/createEvented\");\nvar global_1 = require(\"@dojo/core/global\");\nvar on_1 = require(\"@dojo/core/on\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar privateStateMap = new WeakMap_1.default();\nvar createHashHistory = compose_1.default.mixin(createEvented_1.default, {\n    mixin: {\n        get current() {\n            return privateStateMap.get(this).current;\n        },\n        prefix: function (path) {\n            return \"#\" + path;\n        },\n        set: function (path) {\n            var privateState = privateStateMap.get(this);\n            if (privateState.current === path) {\n                return;\n            }\n            privateState.current = path;\n            privateState.browserLocation.hash = this.prefix(path);\n            this.emit({\n                type: 'change',\n                value: path\n            });\n        },\n        replace: function (path) {\n            var privateState = privateStateMap.get(this);\n            if (privateState.current === path) {\n                return;\n            }\n            privateState.current = path;\n            var _a = privateState.browserLocation, pathname = _a.pathname, search = _a.search;\n            privateState.browserLocation.replace(pathname + search + this.prefix(path));\n            this.emit({\n                type: 'change',\n                value: path\n            });\n        }\n    },\n    initialize: function (instance, _a) {\n        var window = (_a === void 0 ? { window: global_1.default } : _a).window;\n        var browserLocation = window.location;\n        var privateState = {\n            current: browserLocation.hash.slice(1),\n            browserLocation: browserLocation\n        };\n        privateStateMap.set(instance, privateState);\n        instance.own(on_1.default(window, 'hashchange', function () {\n            var path = browserLocation.hash.slice(1);\n            // Ignore hashchange for the current path. Guards against browsers firing hashchange when the history\n            // manager sets the hash.\n            if (path !== privateState.current) {\n                privateState.current = path;\n                instance.emit({\n                    type: 'change',\n                    value: path\n                });\n            }\n        }));\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createHashHistory;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/routing/history/createHashHistory.js\n// module id = 43\n// module chunks = 0","import { assign } from '@dojo/core/lang';\nimport widgetStore from '../stores/widgetStore';\nimport { addTodo, deleteCompleted, deleteTodo, toggleAll, updateTodo } from './todoStoreActions';\nimport { TodoItemProperties } from '../widgets/createTodoItem';\n\ninterface FormEvent extends Event {\n\ttarget: HTMLInputElement;\n}\n\ninterface FormInputEvent extends KeyboardEvent {\n\ttarget: HTMLInputElement;\n}\n\nexport const todoInput = function(this: any, { which, target: { value: label } }: FormInputEvent) {\n\tif (which === 13 && label) {\n\t\taddTodo({ label, completed: false });\n\t\twidgetStore.patch({ id: 'todo-app', todo: '' });\n\t\tthis.invalidate();\n\t}\n};\n\nfunction toggleEditing(todos: TodoItemProperties[], todoId: string, editing: boolean): TodoItemProperties[] {\n\treturn todos\n\t\t.filter((todo) => todo.id === todoId)\n\t\t.map((todo) => {\n\t\t\ttodo.editing = true;\n\t\t\treturn todo;\n\t\t});\n}\n\nexport const todoEdit = function(this: any, event: KeyboardEvent | MouseEvent) {\n\tconst { properties: { id } } = this;\n\tif (event.type === 'keypress' && event.which !== 13 && event.which !== 32) {\n\t\treturn;\n\t}\n\twidgetStore.get('todo-app').then((todoListState: any) => {\n\t\tconst { todos } = todoListState;\n\t\ttodoListState.todos = toggleEditing(todos, id, true);\n\t\treturn widgetStore.patch({ id: 'todo-app', todoListState });\n\t});\n};\n\nexport const todoEditInput = function(this: any, event: FormInputEvent) {\n\tconst { properties: { id } } = this;\n\tif (event.which === 13) {\n\t\ttodoSave.call(this, event);\n\t}\n\telse if (event.which === 27) {\n\t\twidgetStore.get('todo-app').then((todoListState: any) => {\n\t\t\ttodoListState.todos = toggleEditing(todoListState.todos, id, false);\n\t\t\twidgetStore.patch({ id: 'todo-app', todoListState });\n\t\t});\n\t}\n};\n\nexport const todoSave = function(this: any, event: FormInputEvent) {\n\tconst { properties } = this;\n\tif (!event.target.value) {\n\t\tdeleteTodo(properties);\n\t}\n\telse {\n\t\tupdateTodo(assign({}, properties, { label: event.target.value, editing: false }));\n\t}\n};\n\nexport const todoRemove = function(this: any) {\n\tconst { properties } = this;\n\tdeleteTodo({ id: properties.id });\n};\n\nexport const todoToggleComplete = function(this: any) {\n\tconst { properties } = this;\n\tupdateTodo({ id: properties.id, completed: !properties.completed });\n};\n\nexport const filter = function(this: any, { filter }: { filter: 'active' | 'all' | 'completed' }) {\n\tconst { state: { activeFilter = filter } = { } } = this;\n\twidgetStore.patch({ id: 'todo-app', activeFilter });\n};\n\nexport const todoToggleAll = function(event: FormEvent) {\n\ttoggleAll({ checked: event.target.checked });\n};\n\nexport const clearCompleted = function() {\n\tdeleteCompleted();\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions/userActions.ts","import { createObservableStore } from '@dojo/stores/store/mixins/createObservableStoreMixin';\n\nexport default createObservableStore({\n\tdata: [\n\t\t{\n\t\t\tid: 'todo-app',\n\t\t\ttodo: '',\n\t\t\ttodos: [],\n\t\t\tcompletedCount: 0,\n\t\t\tactiveCount: 0,\n\t\t\tactiveFilter: 'all',\n\t\t\tallCompleted: false\n\t\t}\n\t]\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/stores/widgetStore.ts","\"use strict\";\nvar createStore_1 = require(\"../createStore\");\nvar Observable_1 = require(\"@dojo/core/Observable\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar Map_1 = require(\"@dojo/shim/Map\");\nvar Set_1 = require(\"@dojo/shim/Set\");\nvar aspect_1 = require(\"@dojo/compose/aspect\");\nvar util_1 = require(\"@dojo/core/util\");\n/**\n * Combines several sequential deltas into a single delta.\n * It performs several checks to remove redundant data.\n * \t- Checks for repeated copies items with the same ID in\n * \tadds and updates, or just the same ID in deletes, and keeps\n * \tonly the last.\n * \t- Checks for deletes followed by adds or updates and replaces with a\n * \tsingle update\n * \t- Checks for adds followed by deletes and removes both\n * \t- Checks for updates followed by deletes and removes the update\n * @param instance The instance that can identify these items\n * @param currentUpdate The current store delta\n * @param newUpdate The new update to merge\n * @returns The merged delta\n */\nfunction mergeDeltas(instance, currentUpdate, newUpdate) {\n    /**\n     * Takes the last instance of an item repeated in the list\n     * @param items Added or updated items\n     * @returns The added or updated items with repeated items replaced by only the latest version of the item\n     */\n    function takeLastItem(items) {\n        var found = {};\n        var ids = instance.identify(items);\n        return items.reverse().filter(function (_, index) {\n            var id = ids[index];\n            var exists = Boolean(found[id]);\n            found[id] = true;\n            return !exists;\n        }).reverse();\n    }\n    /**\n     * Takes the last instance of an id repeated in the list\n     * @param ids IDs of deleted items\n     * @returns The list with duplicates removed\n     */\n    function takeLastId(ids) {\n        var found = {};\n        return ids.reverse().filter(function (id) {\n            var exists = Boolean(found[id]);\n            found[id] = true;\n            return !exists;\n        }).reverse();\n    }\n    /**\n     * Removes updates for items that were later deleted\n     * @param newDeletes Deletes from delta(s) after the updates\n     * @param oldUpdates Updates from delta(s) before the deletes\n     * @return The updates without updates for subsequently deleted items\n     */\n    function removeOutdatedItems(newDeletes, oldUpdates) {\n        var deletedIds = newDeletes.reduce(function (prev, next) {\n            prev.set(next, null);\n            return prev;\n        }, new Map_1.default());\n        var ids = instance.identify(oldUpdates);\n        return oldUpdates.filter(function (_, index) {\n            return !deletedIds.has(ids[index]);\n        });\n    }\n    /**\n     * Finds cases where an older update has an add, and a newer update has a delete, and removes\n     * both, since the net effect is that the operations are cancelled out\n     * @param newDeletes Deletes form delta(s) after the adds\n     * @param oldAdds Adds from delta(s) before the deletes\n     * @returns An object with the filtered adds and deletes\n     */\n    function removeCancellingUpdates(newDeletes, oldAdds) {\n        var deletedIds = newDeletes.reduce(function (prev, next) {\n            prev.set(next, null);\n            return prev;\n        }, new Map_1.default());\n        var ids = instance.identify(oldAdds);\n        var addIds = ids.reduce(function (prev, next) {\n            prev.set(next, null);\n            return prev;\n        }, new Map_1.default());\n        return {\n            oldAdds: oldAdds.filter(function (_, index) {\n                return !deletedIds.has(ids[index]);\n            }),\n            newDeletes: newDeletes.filter(function (id) { return !addIds.has(id); })\n        };\n    }\n    /**\n     * Finds places where an item was deleted and then added or updated, and removes the delete. If the item was added,\n     * the add is also replaced with an update since it should already exist in the collection receiving the updates,\n     * as it will never receive the delete\n     * @param oldDeletes - Deletes from delta(s) before the adds and updates\n     * @param newAdds - Adds from delta(s) after the deletes\n     * @param newUpdates - Updates from delta(s) after the deletes\n     * @returns An object containing the updated deletes, adds, and updates\n     */\n    function convertReplacementToUpdate(oldDeletes, newAdds, newUpdates) {\n        var deletes = oldDeletes.reduce(function (prev, next) {\n            prev.set(next, null);\n            return prev;\n        }, new Map_1.default());\n        var addIds = instance.identify(newAdds);\n        var updateIds = instance.identify(newUpdates);\n        var adds = addIds.concat(updateIds).reduce(function (prev, next) {\n            prev.set(next, null);\n            return prev;\n        }, new Map_1.default());\n        var updatedUpdates = newUpdates.slice();\n        return {\n            oldDeletes: oldDeletes.filter(function (id) { return !adds.has(id); }),\n            newAdds: newAdds.filter(function (item, index) {\n                var shouldKeep = !deletes.has(addIds[index]);\n                if (!shouldKeep) {\n                    // Always add it to the beginning, because it may have been updated as well, but the add\n                    // has to have come first.\n                    updatedUpdates.unshift(item);\n                }\n                return shouldKeep;\n            }),\n            newUpdates: updatedUpdates\n        };\n    }\n    var _a = convertReplacementToUpdate(currentUpdate.deletes, newUpdate.adds, newUpdate.updates), oldDeletes = _a.oldDeletes, newAdds = _a.newAdds, newUpdates = _a.newUpdates;\n    var oldUpdates = removeOutdatedItems(newUpdate.deletes, currentUpdate.updates);\n    var _b = removeCancellingUpdates(newUpdate.deletes, currentUpdate.adds), newDeletes = _b.newDeletes, oldAdds = _b.oldAdds;\n    return {\n        updates: takeLastItem(oldUpdates.concat(newUpdates)),\n        adds: takeLastItem(oldAdds.concat(newAdds)),\n        deletes: takeLastId(oldDeletes.concat(newDeletes)),\n        beforeAll: currentUpdate.beforeAll,\n        afterAll: newUpdate.afterAll\n    };\n}\nexports.mergeDeltas = mergeDeltas;\nvar instanceStateMap = new WeakMap_1.default();\n/**\n * Takes a collection of items and creates a new copy modified according to the provided updates. This can be used to\n * attempt to track updates in the local collection when fetching after each update is disabled.\n * @param store\n * @param state\n * @param data\n * @param update\n * @returns A new collection with the modifications specified by the update\n */\nfunction addUpdateDelete(store, state, data, update) {\n    var newData = data.slice();\n    update.adds.forEach(function (item) {\n        newData.push(item);\n    });\n    store.identify(update.updates).forEach(function (id, index) {\n        if (state.localIndex.has(id)) {\n            newData[state.localIndex.get(id)] = update.updates[index];\n        }\n        else {\n            newData.push(update.updates[index]);\n        }\n    });\n    update.deletes.sort().reverse().forEach(function (id) {\n        if (state.localIndex.has(id)) {\n            newData.splice(state.localIndex.get(id), 1);\n        }\n    });\n    return newData;\n}\n/**\n * Build a map of ids to indices for the provided collection. This requires that the array of IDs is either what\n * the index if for, or that the array of items the IDs represent is in the same order, which is already the case\n * if the IDs were generated using the Store's identify function.\n * @param ids - The IDS to build the index for\n * @returns An index mapping ids to indices\n */\nfunction buildIndex(ids) {\n    return ids.reduce(function (map, id, index) {\n        map.set(id, index);\n        return map;\n    }, new Map_1.default());\n}\nexports.buildIndex = buildIndex;\n/**\n * Merges the latest queued updates, updates the local data and index based on the latest data,\n * sends out updates to observers, and then removes observers that unsubscribed during the update process from the list\n * of observers. If after is provided, it is assumed that that is the latest data for the store, if it is not provided\n * the local data is updated according to the merged delta and that is used as the new local data.\n * @param store\n * @param after - Optional array of items containing the latest data for the store.\n */\nfunction sendUpdates(store, after) {\n    var state = instanceStateMap.get(store);\n    var storeDelta = state.queuedUpdate || {\n        updates: [],\n        adds: [],\n        deletes: [],\n        beforeAll: [],\n        afterAll: []\n    };\n    state.queuedUpdate = undefined;\n    after = after || addUpdateDelete(store, state, state.localData, storeDelta);\n    storeDelta.beforeAll = state.localData;\n    storeDelta.afterAll = after;\n    state.localData = after;\n    state.localIndex = buildIndex(store.identify(after));\n    state.observers.forEach(function (observer) {\n        observer.next({\n            updates: storeDelta.updates.slice(),\n            adds: storeDelta.adds.slice(),\n            deletes: storeDelta.deletes.slice(),\n            beforeAll: storeDelta.beforeAll.slice(),\n            afterAll: storeDelta.afterAll.slice()\n        });\n    });\n}\n/**\n * Determines whether this is a single observer or a set entry\n * @param observer\n * @returns {boolean}\n */\nfunction isObserverEntry(observer) {\n    return observer.observes instanceof Set_1.default;\n}\n/**\n * Determines whether this is a single observer or a set entry\n * @param observer\n * @returns {boolean}\n */\nfunction isObserver(observer) {\n    return !isObserverEntry(observer);\n}\n/**\n * Iterates through the provided items and/or IDs and notifies observers. If items is provided, then the\n * observers for that item, and the observers for sets of items that include that are updated. If items is null, then\n * these are delete notifications for observers of multiple items. In this case, no update is sent to individual\n * observers, and observers of sets receive `ItemUpdate` objects with the IDs of the deleted items and an undefined item\n *\n * @param items Items to send updates for, or null if these are delete notifications for item set observers\n * @param ids - IDs of the items, should be in the same order as items\n * @param state\n * @param store\n */\nfunction notifyItemObservers(items, ids, state, store) {\n    function notify(id, after) {\n        if (state.itemObservers.has(id)) {\n            state.itemObservers.get(id).map(function (observerOrEntry) {\n                if (isObserverEntry(observerOrEntry)) {\n                    return observerOrEntry.observer;\n                }\n                else {\n                    return null;\n                }\n            }).filter(function (observerEntry) {\n                return observerEntry;\n            }).forEach(function (observer) {\n                observer.next({\n                    item: after,\n                    id: id\n                });\n            });\n            if (after) {\n                state.itemObservers.get(id).map(function (observerOrEntry) {\n                    if (isObserver(observerOrEntry)) {\n                        return observerOrEntry;\n                    }\n                    else {\n                        return null;\n                    }\n                }).filter(function (observer) {\n                    return observer;\n                }).forEach(function (observer) {\n                    observer.next(after);\n                });\n            }\n        }\n    }\n    if (items) {\n        items.forEach(function (after, index) {\n            var id = ids[index] || store.identify(after);\n            notify(id, after);\n        });\n    }\n    else {\n        ids.forEach(function (id) {\n            notify(id, undefined);\n        });\n    }\n}\n/**\n * Queues the appropriate update and then either starts up a fetch or just triggers sending the updates depending\n * on the `fetchAroundUpdates` property\n * @param state\n * @param store\n * @param updates Updated items\n * @param adds Added items\n * @param deletes Deleted IDs\n */\nfunction sendUpdatesOrFetch(state, store, updates, adds, deletes) {\n    var newUpdate = {\n        updates: updates,\n        adds: adds,\n        deletes: deletes,\n        beforeAll: [],\n        afterAll: []\n    };\n    state.queuedUpdate = state.queuedUpdate ? mergeDeltas(store, state.queuedUpdate, newUpdate) : newUpdate;\n    if (state.fetchAroundUpdates) {\n        state.fetchAndSendUpdates(store);\n    }\n    else {\n        sendUpdates(store);\n    }\n}\nfunction createObservableStoreMixin() {\n    return {\n        mixin: {\n            observe: function (idOrIds) {\n                if (idOrIds) {\n                    var self_1 = this;\n                    var state_1 = instanceStateMap.get(self_1);\n                    if (Array.isArray(idOrIds)) {\n                        var ids_1 = idOrIds;\n                        var idSet_1 = new Set_1.default(ids_1);\n                        var observable = new Observable_1.Observable(function subscribe(observer) {\n                            var observerEntry = {\n                                observes: idSet_1,\n                                observer: observer\n                            };\n                            ids_1.forEach(function (id) {\n                                if (state_1.itemObservers.has(id)) {\n                                    state_1.itemObservers.get(id).push(observerEntry);\n                                }\n                                else {\n                                    state_1.itemObservers.set(id, [observerEntry]);\n                                }\n                            });\n                            var foundIds = new Set_1.default();\n                            observer.next = aspect_1.after(observer.next, function (result, itemUpdate) {\n                                foundIds.add(itemUpdate.id);\n                                return result;\n                            });\n                            self_1.get(ids_1).then(function (items) {\n                                if (foundIds.size !== ids_1.length) {\n                                    var retrievedIdSet_1 = new Set_1.default(self_1.identify(items));\n                                    var missingItemIds = ids_1.filter(function (id) { return !retrievedIdSet_1.has(id); });\n                                    if (retrievedIdSet_1.size !== idSet_1.size || missingItemIds.length) {\n                                        observer.error(new Error(\"ID(s) \\\"\" + missingItemIds + \"\\\" not found in store\"));\n                                    }\n                                    else {\n                                        items.forEach(function (item, index) { return observer.next({\n                                            item: item,\n                                            id: ids_1[index]\n                                        }); });\n                                    }\n                                }\n                            });\n                        });\n                        return observable;\n                    }\n                    else {\n                        var id_1 = idOrIds;\n                        return new Observable_1.Observable(function subscribe(observer) {\n                            self_1.get(id_1).then(function (item) {\n                                if (!item) {\n                                    observer.error(new Error(\"ID \\\"\" + id_1 + \"\\\" not found in store\"));\n                                }\n                                else {\n                                    if (state_1.itemObservers.has(id_1)) {\n                                        state_1.itemObservers.get(id_1).push(observer);\n                                    }\n                                    else {\n                                        state_1.itemObservers.set(id_1, [observer]);\n                                    }\n                                    observer.next(item);\n                                }\n                            });\n                        });\n                    }\n                }\n                else {\n                    return instanceStateMap.get(this).storeObservable;\n                }\n            }\n        },\n        aspectAdvice: {\n            after: {\n                /**\n                 * After fetching, sends updates if no query was used. If a custom query was used then the data retrieved\n                 * is not indicative of the local data and can't be used. We shouldn't apply the query locally because we\n                 * have no knowledge of the underlying storage implementation or the amount of data and it may be too much\n                 * data to retrieve or update in memory. If this is the initialFetch, don't update since that update\n                 * will be sent to each subscriber at the time of subscription. If we're not sending updates, still set\n                 * the local data and index to the newly retrieved data.\n                 * @param result\n                 * @param query\n                 * @returns {Promise<T[]>}\n                 */\n                fetch: function (result, query) {\n                    var _this = this;\n                    if (!query) {\n                        result.then(function (data) {\n                            var state = instanceStateMap.get(_this);\n                            if (result !== state.initialFetch) {\n                                sendUpdates(_this, data);\n                            }\n                            else {\n                                state.localData = data;\n                                state.localIndex = buildIndex(_this.identify(data));\n                            }\n                        }, \n                        // Ignore errors here, they should be handled by the caller not observers\n                        function () { });\n                    }\n                    return result;\n                },\n                /**\n                 * After the put is completed, notify the item observers, and then either queue a fetch to send updates\n                 * if fetchAroundUpdates is true, or just send updates if not.\n                 * @param result\n                 * @returns {StoreObservable<T, any>}\n                 */\n                put: function (result) {\n                    var _this = this;\n                    result.then(function (updatedItems) {\n                        var state = instanceStateMap.get(_this);\n                        notifyItemObservers(updatedItems, [], state, _this);\n                        sendUpdatesOrFetch(state, _this, updatedItems, [], []);\n                    }, \n                    // Ignore errors here, they should be handled by the caller not observers\n                    function () { });\n                    return result;\n                },\n                /**\n                 * After the patch is completed, notify the item observers, and then either queue a fetch to send updates\n                 * if fetchAroundUpdates is true, or just send updates if not.\n                 * @param result\n                 * @returns {StoreObservable<T, any>}\n                 */\n                patch: function (result) {\n                    var _this = this;\n                    result.then(function (updatedItems) {\n                        var state = instanceStateMap.get(_this);\n                        notifyItemObservers(updatedItems, [], state, _this);\n                        sendUpdatesOrFetch(state, _this, updatedItems, [], []);\n                    }, \n                    // Ignore errors here, they should be handled by the caller not observers\n                    function () { });\n                    return result;\n                },\n                /**\n                 * After the add is completed notify observers. If this is the initial add AND we are fetching around\n                 * updates, then the first update to subscribers will already contain this data, since the initial fetch\n                 * is performed after the initial add. In this case we do not need to send an update. We can tell this\n                 * is the first add because it'll be triggered in the createStore base before the state is created for\n                 * this instance in the mixin's initializer\n                 * @param result\n                 * @returns {StoreObservable<T, U>}\n                 */\n                add: function (result) {\n                    var _this = this;\n                    var isFirstAdd = !instanceStateMap.get(this);\n                    result.then(function (addedItems) {\n                        var state = instanceStateMap.get(_this);\n                        if (!isFirstAdd || !state.fetchAroundUpdates) {\n                            sendUpdatesOrFetch(state, _this, [], addedItems, []);\n                        }\n                    }, \n                    // Ignore errors here, they should be handled by the caller not observers\n                    function () { });\n                    return result;\n                },\n                /**\n                 * After the items are deleted, notify item set observers of the deletion of one of the items they are\n                 * observing, and then complete any observables that need to be completed.\n                 * Completing observables is dones as follows\n                 * \t- For observers of a single item, just complete the observer\n                 * \t- For observers of a set of items\n                 * \t\t- Remove the deleted ID of this item from the set of observed IDs\n                 * \t\t- If there are now no observed IDs for the set, complete the observable\n                 * \t- Remove the item observer entry for the deleted ID\n                 * @param result\n                 * @param ids\n                 * @returns {StoreObservable<string, any>}\n                 */\n                delete: function (result, ids) {\n                    var _this = this;\n                    result.then(function (deleted) {\n                        var state = instanceStateMap.get(_this);\n                        notifyItemObservers(null, deleted, state, _this);\n                        deleted.forEach(function (id) {\n                            if (state.itemObservers.has(id)) {\n                                state.itemObservers.get(id).forEach(function (observerOrEntry) {\n                                    if (isObserver(observerOrEntry)) {\n                                        observerOrEntry.complete();\n                                    }\n                                    else {\n                                        observerOrEntry.observes.delete(id);\n                                        if (!observerOrEntry.observes.size) {\n                                            observerOrEntry.observer.complete();\n                                        }\n                                    }\n                                });\n                                state.itemObservers.delete(id);\n                            }\n                        });\n                        sendUpdatesOrFetch(state, _this, [], [], deleted);\n                    }, \n                    // Ignore errors here, they should be handled by the caller not observers\n                    function () { });\n                    return result;\n                }\n            }\n        },\n        initialize: function (instance, options) {\n            options = options || {};\n            var itemObservers = new Map_1.default();\n            var storeObservable = new Observable_1.Observable(function (observer) {\n                var state = instanceStateMap.get(this);\n                state.observers.push(observer);\n                if (state.initialFetch) {\n                    state.initialFetch.then(function () {\n                        observer.next({\n                            updates: [],\n                            deletes: [],\n                            adds: [],\n                            beforeAll: [],\n                            afterAll: state.localData.slice()\n                        });\n                    });\n                }\n                else {\n                    observer.next({\n                        updates: [],\n                        deletes: [],\n                        adds: [],\n                        beforeAll: [],\n                        afterAll: state.localData.slice()\n                    });\n                }\n                return function () {\n                    function remove(observer) {\n                        state.observers.splice(state.observers.indexOf(observer), 1);\n                    }\n                    setTimeout(function () {\n                        remove(observer);\n                    });\n                };\n            }.bind(instance));\n            var state = {\n                fetchAroundUpdates: Boolean(options.fetchAroundUpdates),\n                fetchAndSendUpdates: util_1.debounce(function (store) {\n                    store.fetch();\n                }, options.fetchAroundUpdateDebounce || 20),\n                itemObservers: itemObservers,\n                observers: [],\n                storeObservable: storeObservable,\n                localData: [],\n                localIndex: new Map_1.default()\n            };\n            if (options.fetchAroundUpdates) {\n                state.initialFetch = instance.fetch();\n            }\n            instanceStateMap.set(instance, state);\n        }\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createObservableStoreMixin;\nexports.createObservableStore = createStore_1.default\n    .mixin(createObservableStoreMixin());\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/store/mixins/createObservableStoreMixin.js\n// module id = 46\n// module chunks = 0","\"use strict\";\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar Map_1 = require(\"@dojo/shim/Map\");\nvar lang_1 = require(\"@dojo/core/lang\");\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar Observable_1 = require(\"@dojo/core/Observable\");\nvar createPatch_1 = require(\"../patch/createPatch\");\nvar createStoreObservable_1 = require(\"./createStoreObservable\");\nvar createInMemoryStorage_1 = require(\"../storage/createInMemoryStorage\");\nvar instanceStateMap = new WeakMap_1.default();\nfunction isPatchArray(patches) {\n    return isPatch(patches[0]);\n}\nfunction isPatch(patchObj) {\n    var patch = patchObj && patchObj.patch;\n    var id = patchObj && patchObj.id;\n    return typeof id === 'string' && patch && Array.isArray(patch.operations) && typeof patch.apply === 'function' &&\n        typeof patch.toString === 'function';\n}\nfunction createStoreObservable(storeResultsPromise) {\n    return createStoreObservable_1.default(new Observable_1.Observable(function subscribe(observer) {\n        storeResultsPromise\n            .then(function (results) {\n            observer.next(results);\n            observer.complete();\n        }, function (error) {\n            observer.error(error);\n        });\n    }), function (results) {\n        return results.successfulData;\n    });\n}\nvar createStore = compose_1.default({\n    get: function (ids) {\n        var state = instanceStateMap.get(this);\n        return state.initialAddPromise.then(function () {\n            if (Array.isArray(ids)) {\n                return state.storage.get(ids).then(function (items) { return items.filter(function (item) { return Boolean(item); }); });\n            }\n            else {\n                return state.storage.get([ids]).then(function (items) { return items[0]; });\n            }\n        });\n    },\n    add: function (items, options) {\n        var self = this;\n        var state = instanceStateMap.get(self);\n        var storeResultsPromise = state.initialAddPromise.then(function () {\n            return state.storage.add(Array.isArray(items) ? items : [items], options);\n        });\n        return createStoreObservable(storeResultsPromise);\n    },\n    put: function (items, options) {\n        var self = this;\n        var state = instanceStateMap.get(self);\n        var storeResultsPromise = state.initialAddPromise.then(function () {\n            return state.storage.put(Array.isArray(items) ? items : [items], options);\n        });\n        return createStoreObservable(storeResultsPromise);\n    },\n    patch: function (updates, options) {\n        var self = this;\n        var state = instanceStateMap.get(self);\n        var patchEntries = [];\n        if (Array.isArray(updates)) {\n            if (isPatchArray(updates)) {\n                patchEntries = updates;\n            }\n            else {\n                patchEntries = self.identify(updates).map(function (id, index) {\n                    return { id: id, patch: createPatch_1.diff(updates[index]) };\n                });\n            }\n        }\n        else if (updates instanceof Map_1.default) {\n            updates.forEach(function (value, key) {\n                patchEntries.push({\n                    id: key,\n                    patch: value\n                });\n            });\n        }\n        else if (isPatch(updates)) {\n            patchEntries = [updates];\n        }\n        else {\n            var dupe = lang_1.duplicate(updates);\n            var idInOptions = (options && options.id);\n            var id = idInOptions || dupe.id;\n            if (!idInOptions) {\n                delete dupe.id;\n            }\n            patchEntries = [{ id: id, patch: createPatch_1.diff(dupe) }];\n        }\n        var storeResultsPromise = state.initialAddPromise.then(function () {\n            return state.storage.patch(patchEntries);\n        });\n        return createStoreObservable(storeResultsPromise);\n    },\n    delete: function (ids) {\n        var self = this;\n        var state = instanceStateMap.get(self);\n        var storeResultsPromise = state.initialAddPromise.then(function () {\n            return state.storage.delete(Array.isArray(ids) ? ids : [ids]);\n        });\n        return createStoreObservable(storeResultsPromise);\n    },\n    fetch: function (query) {\n        var state = instanceStateMap.get(this);\n        var resolveTotalLength;\n        var rejectTotalLength;\n        var totalLength = new Promise_1.default(function (resolve, reject) {\n            resolveTotalLength = resolve;\n            rejectTotalLength = reject;\n        });\n        var fetchResult = state.initialAddPromise.then(function () {\n            var result = state.storage.fetch(query);\n            result.totalLength.then(resolveTotalLength, rejectTotalLength);\n            return result;\n        });\n        fetchResult.totalLength = fetchResult.dataLength = totalLength;\n        return fetchResult;\n    },\n    identify: function (items) {\n        var storage = instanceStateMap.get(this).storage;\n        if (Array.isArray(items)) {\n            return storage.identify(items);\n        }\n        else {\n            return storage.identify([items])[0];\n        }\n    },\n    createId: function () {\n        return instanceStateMap.get(this).storage.createId();\n    }\n}, function (instance, options) {\n    options = options || {};\n    var data = options.data;\n    options.data = undefined;\n    var instanceState = {\n        storage: options.storage || createInMemoryStorage_1.default(options),\n        initialAddPromise: Promise_1.default.resolve()\n    };\n    instanceStateMap.set(instance, instanceState);\n    if (data) {\n        instanceState.initialAddPromise = instance.add(data).catch(function (error) {\n            console.error(error);\n        });\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createStore;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/store/createStore.js\n// module id = 47\n// module chunks = 0","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\"use strict\";\nvar Observable_1 = require(\"@dojo/shim/Observable\");\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nfunction isSubscribable(object) {\n    return object && object.subscribe !== undefined;\n}\nvar Observable = (function (_super) {\n    __extends(Observable, _super);\n    function Observable() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Observable.of = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        return _super.of.apply(this, items);\n    };\n    Observable.from = function (item) {\n        return _super.from.call(this, item);\n    };\n    Observable.defer = function (deferFunction) {\n        return new Observable(function (observer) {\n            var trueObservable = deferFunction();\n            return trueObservable.subscribe({\n                next: function (value) {\n                    return observer.next(value);\n                },\n                error: function (errorValue) {\n                    return observer.error(errorValue);\n                },\n                complete: function (completeValue) {\n                    observer.complete(completeValue);\n                }\n            });\n        });\n    };\n    Observable.prototype.toPromise = function () {\n        var _this = this;\n        return new Promise_1.default(function (resolve, reject) {\n            _this.subscribe({\n                next: function (value) {\n                    resolve(value);\n                },\n                error: function (error) {\n                    reject(error);\n                }\n            });\n        });\n    };\n    Observable.prototype.map = function (mapFunction) {\n        var self = this;\n        if (typeof mapFunction !== 'function') {\n            throw new TypeError('Map parameter must be a function');\n        }\n        return new Observable(function (observer) {\n            self.subscribe({\n                next: function (value) {\n                    try {\n                        var result = mapFunction(value);\n                        return observer.next(result);\n                    }\n                    catch (e) {\n                        return observer.error(e);\n                    }\n                },\n                error: function (errorValue) {\n                    return observer.error(errorValue);\n                },\n                complete: function (completeValue) {\n                    return observer.complete(completeValue);\n                }\n            });\n        });\n    };\n    Observable.prototype.filter = function (filterFunction) {\n        var self = this;\n        if (typeof filterFunction !== 'function') {\n            throw new TypeError('Filter argument must be a function');\n        }\n        return new Observable(function (observer) {\n            self.subscribe({\n                next: function (value) {\n                    try {\n                        if (filterFunction(value)) {\n                            return observer.next(value);\n                        }\n                    }\n                    catch (e) {\n                        return observer.error(e);\n                    }\n                },\n                error: function (errorValue) {\n                    return observer.error(errorValue);\n                },\n                complete: function (completeValue) {\n                    return observer.complete(completeValue);\n                }\n            });\n        });\n    };\n    Observable.prototype.toArray = function () {\n        var self = this;\n        return new Observable(function (observer) {\n            var values = [];\n            self.subscribe({\n                next: function (value) {\n                    values.push(value);\n                },\n                error: function (errorValue) {\n                    return observer.error(errorValue);\n                },\n                complete: function (completeValue) {\n                    observer.next(values);\n                    observer.complete(completeValue);\n                }\n            });\n        });\n    };\n    Observable.prototype.mergeAll = function (concurrent) {\n        var self = this;\n        return new Observable(function (observer) {\n            var active = [];\n            var queue = [];\n            function checkForComplete() {\n                if (active.length === 0 && queue.length === 0) {\n                    observer.complete();\n                }\n                else if (queue.length > 0 && active.length < concurrent) {\n                    var item = queue.shift();\n                    if (isSubscribable(item)) {\n                        var itemIndex_1 = active.length;\n                        active.push(item);\n                        item.subscribe({\n                            next: function (value) {\n                                observer.next(value);\n                            },\n                            complete: function () {\n                                active.splice(itemIndex_1, 1);\n                                checkForComplete();\n                            }\n                        });\n                    }\n                    else {\n                        observer.next(item);\n                        checkForComplete();\n                    }\n                }\n            }\n            self.subscribe({\n                next: function (value) {\n                    queue.push(value);\n                },\n                complete: function () {\n                    checkForComplete();\n                }\n            });\n        });\n    };\n    return Observable;\n}(Observable_1.default));\nexports.Observable = Observable;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Observable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/Observable.js\n// module id = 48\n// module chunks = 0","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\"use strict\";\nvar iterator_1 = require(\"./iterator\");\nvar decorators_1 = require(\"./support/decorators\");\nvar global_1 = require(\"./support/global\");\nrequire(\"./Symbol\");\nvar Shim;\n(function (Shim) {\n    /*\n     * Decorator to mark a single method/property as non-enumerable. ES spec requires pretty much every\n     * method or property in Subscription, Observable, and SubscriptionObserver to be non-enumerable.\n     */\n    function nonEnumerable(target, key, descriptor) {\n        descriptor.enumerable = false;\n    }\n    /*\n     * Create a subscription observer for a given observer, and return the subscription.  The \"logic\" for Observerables\n     * is in here!\n     */\n    function startSubscription(executor, observer) {\n        var closed = false;\n        var cleanUp;\n        function unsubscribe() {\n            if (!closed) {\n                closed = true;\n                if (cleanUp) {\n                    cleanUp();\n                }\n            }\n        }\n        function start(subscriptionObserver) {\n            if (observer.start) {\n                observer.start(subscription);\n            }\n            if (closed) {\n                return;\n            }\n            try {\n                var result = executor(subscriptionObserver);\n                if (typeof result === 'function') {\n                    cleanUp = result;\n                }\n                else if (result && 'unsubscribe' in result) {\n                    cleanUp = result.unsubscribe;\n                }\n                else if (result !== undefined && result !== null) {\n                    throw new TypeError('Subscriber must return a callable or subscription');\n                }\n                if (closed) {\n                    if (cleanUp) {\n                        cleanUp();\n                    }\n                }\n            }\n            catch (e) {\n                error(e);\n            }\n        }\n        function next(value) {\n            if (closed) {\n                return;\n            }\n            var next = observer.next;\n            try {\n                if (typeof next === 'function') {\n                    return next(value);\n                }\n                else if (next !== undefined && next !== null) {\n                    throw new TypeError('Observer.next is not a function');\n                }\n            }\n            catch (e) {\n                error(e);\n            }\n        }\n        function error(errorValue) {\n            if (!closed) {\n                var cleanUpError = undefined;\n                try {\n                    unsubscribe();\n                }\n                catch (e) {\n                    cleanUpError = e;\n                }\n                var observerError = observer.error;\n                if (observerError !== undefined && observerError !== null) {\n                    if (typeof observerError === 'function') {\n                        var errorResult = observerError(errorValue);\n                        if (cleanUpError !== undefined) {\n                            throw cleanUpError;\n                        }\n                        return errorResult;\n                    }\n                    else {\n                        throw new TypeError('Observer.error is not a function');\n                    }\n                }\n                else if (observer.complete) {\n                    return observer.complete(errorValue);\n                }\n                else {\n                    throw errorValue;\n                }\n            }\n            else {\n                throw errorValue;\n            }\n        }\n        function complete(completeValue) {\n            if (!closed) {\n                var cleanUpError = undefined;\n                try {\n                    unsubscribe();\n                }\n                catch (e) {\n                    cleanUpError = e;\n                }\n                var observerComplete = observer.complete;\n                if (observerComplete !== undefined && observerComplete !== null) {\n                    if (typeof observerComplete === 'function') {\n                        var completeResult = observerComplete(completeValue);\n                        if (cleanUpError !== undefined) {\n                            throw cleanUpError;\n                        }\n                        return completeResult;\n                    }\n                    else {\n                        throw new TypeError('Observer.complete is not a function');\n                    }\n                }\n                else if (cleanUpError) {\n                    throw cleanUpError;\n                }\n            }\n        }\n        var subscription = Object.create(Object.create({}, {\n            'closed': {\n                enumerable: false,\n                configurable: true,\n                get: function () {\n                    return closed;\n                }\n            },\n            'unsubscribe': {\n                enumerable: false,\n                configurable: true,\n                writable: true,\n                value: unsubscribe\n            }\n        }));\n        var prototype = Object.create({}, {\n            'next': {\n                enumerable: false,\n                writable: true,\n                value: next,\n                configurable: true\n            },\n            'error': {\n                enumerable: false,\n                writable: true,\n                value: error,\n                configurable: true\n            },\n            'complete': {\n                enumerable: false,\n                writable: true,\n                value: complete,\n                configurable: true\n            },\n            'closed': {\n                enumerable: false,\n                configurable: true,\n                get: function () {\n                    return closed;\n                }\n            }\n        });\n        // create the SubscriptionObserver and kick things off\n        start(Object.create(prototype));\n        // the ONLY way to control the SubscriptionObserver is with the subscription or from a subscriber\n        return subscription;\n    }\n    var ShimObservable = (function () {\n        function ShimObservable(subscriber) {\n            if (typeof subscriber !== 'function') {\n                throw new TypeError('subscriber is not a function');\n            }\n            this._executor = subscriber;\n        }\n        ShimObservable.prototype[_a = Symbol.observable] = function () {\n            return this;\n        };\n        ShimObservable.prototype.subscribe = function (observerOrNext) {\n            var listeners = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                listeners[_i - 1] = arguments[_i];\n            }\n            var _a = listeners.slice(), onError = _a[0], onComplete = _a[1];\n            if (!observerOrNext || typeof observerOrNext === 'number' || typeof observerOrNext === 'string' || typeof observerOrNext === 'boolean') {\n                throw new TypeError('parameter must be a function or an observer');\n            }\n            var observer;\n            if (typeof observerOrNext === 'function') {\n                observer = {\n                    next: observerOrNext\n                };\n                if (typeof onError === 'function') {\n                    observer.error = onError;\n                }\n                if (typeof onComplete === 'function') {\n                    observer.complete = onComplete;\n                }\n            }\n            else {\n                observer = observerOrNext;\n            }\n            return startSubscription(this._executor, observer);\n        };\n        ShimObservable.of = function () {\n            var items = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                items[_i] = arguments[_i];\n            }\n            var constructor;\n            if (typeof this !== 'function') {\n                constructor = ShimObservable;\n            }\n            else {\n                constructor = this;\n            }\n            return new constructor(function (observer) {\n                iterator_1.forOf(items, function (o) {\n                    observer.next(o);\n                });\n                observer.complete();\n            });\n        };\n        ShimObservable.from = function (item) {\n            if (item === null || item === undefined) {\n                throw new TypeError('item cannot be null or undefined');\n            }\n            var constructor;\n            if (typeof this !== 'function') {\n                constructor = ShimObservable;\n            }\n            else {\n                constructor = this;\n            }\n            var observableSymbol = item[Symbol.observable];\n            if (observableSymbol !== undefined) {\n                if (typeof observableSymbol !== 'function') {\n                    throw new TypeError('Symbol.observable must be a function');\n                }\n                var result = observableSymbol.call(item);\n                if (result === undefined || result === null || typeof result === 'number' || typeof result === 'boolean' || typeof result === 'string') {\n                    throw new TypeError('Return value of Symbol.observable must be object');\n                }\n                if (result.constructor && result.constructor === this || result instanceof ShimObservable) {\n                    return result;\n                }\n                else if (result.subscribe) {\n                    return new constructor(result.subscribe);\n                }\n                else {\n                    if (constructor.of) {\n                        return constructor.of(result);\n                    }\n                    else {\n                        return ShimObservable.of(result);\n                    }\n                }\n            }\n            else if (iterator_1.isIterable(item) || iterator_1.isArrayLike(item)) {\n                return new constructor(function (observer) {\n                    iterator_1.forOf(item, function (o) {\n                        observer.next(o);\n                    });\n                    observer.complete();\n                });\n            }\n            else {\n                throw new TypeError('Parameter is neither Observable nor Iterable');\n            }\n        };\n        return ShimObservable;\n    }());\n    __decorate([\n        nonEnumerable\n    ], ShimObservable.prototype, _a, null);\n    __decorate([\n        nonEnumerable\n    ], ShimObservable.prototype, \"subscribe\", null);\n    __decorate([\n        nonEnumerable\n    ], ShimObservable, \"of\", null);\n    __decorate([\n        nonEnumerable\n    ], ShimObservable, \"from\", null);\n    Shim.ShimObservable = ShimObservable;\n    var _a;\n})(Shim || (Shim = {}));\nvar Observable = (function () {\n    /* istanbul ignore next */\n    /**\n     * Create a new observerable with a subscriber function. The subscriber function will get called with a\n     * SubscriptionObserver parameter for controlling the subscription.  I a function is returned, it will be\n     * run when the subscription is complete.\n     *\n     * @param {Subscriber<T>} subscriber    The subscription function to be called when observers are subscribed\n     *\n     * @example\n     * const source = new Observer<number>((observer) => {\n     *     observer.next(1);\n     *     observer.next(2);\n     *     observer.next(3);\n     * });\n     */\n    function Observable(subscriber) {\n    }\n    /* istanbul ignore next */\n    Observable.prototype.subscribe = function (observerOrNext, onError, onComplete) {\n        throw new Error();\n    };\n    /* istanbul ignore next */\n    /**\n     * Create an Observable from a list of values.\n     *\n     * @param {...T} items The values to be emitted\n     *\n     * @return {Observable<T>}    An Observable that will emit the specified values\n     *\n     * @example\n     *\n     * let source = Observable.of(1, 2, 3);\n     *\n     * // will emit three separate values, 1, 2, and 3.\n     */\n    Observable.of = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        throw new Error();\n    };\n    /* istanbul ignore next */\n    /**\n     * Create an Observable from another object. If the object is in itself Observable, the object will be returned.\n     * Otherwise, the value will be wrapped in an Observable. If the object is iterable, an Observable will be created\n     * that emits each item of the iterable.\n     *\n     * @param {Iterable<T> | ArrayLike<T> | ObservableObject} item The item to be turned into an Observable\n     *\n     * @return {Observable<T>}    An observable for the item you passed in\n     */\n    Observable.from = function (item) {\n        throw new Error();\n    };\n    /* istanbul ignore next */\n    Observable.prototype[Symbol.observable] = function () {\n        throw new Error();\n    };\n    return Observable;\n}());\nObservable = __decorate([\n    decorators_1.hasClass('es-observable', global_1.default.Observable, Shim.ShimObservable)\n], Observable);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Observable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/Observable.js\n// module id = 49\n// module chunks = 0","\"use strict\";\nvar utils_1 = require(\"../utils\");\nvar createOperation_1 = require(\"./createOperation\");\nvar createJsonPointer_1 = require(\"./createJsonPointer\");\nfunction _diff(to, from, startingPath) {\n    if (!utils_1.shouldRecurseInto(from) || !utils_1.shouldRecurseInto(to)) {\n        return [];\n    }\n    var path = startingPath || createJsonPointer_1.default();\n    var fromKeys = Object.keys(from);\n    var toKeys = Object.keys(to);\n    var operations = [];\n    fromKeys.forEach(function (key) {\n        if (!utils_1.isEqual(from[key], to[key])) {\n            if ((key in from) && !(key in to)) {\n                operations.push(createOperation_1.default(1 /* Remove */, path.push(key)));\n            }\n            else if (utils_1.shouldRecurseInto(from[key]) && utils_1.shouldRecurseInto(to[key])) {\n                operations.push.apply(operations, _diff(to[key], from[key], path.push(key)));\n            }\n            else {\n                operations.push(createOperation_1.default(2 /* Replace */, path.push(key), to[key], undefined, from[key]));\n            }\n        }\n    });\n    toKeys.forEach(function (key) {\n        if (!(key in from) && (key in to)) {\n            operations.push(createOperation_1.default(0 /* Add */, path.push(key), to[key]));\n        }\n    });\n    return operations;\n}\nfunction diff(to, from) {\n    if (from === void 0) { from = {}; }\n    return createPatch(_diff(to, from));\n}\nexports.diff = diff;\nfunction createPatch(operations) {\n    return {\n        operations: operations,\n        apply: function (target) {\n            return this.operations.reduce(function (prev, next) { return next.apply(prev); }, target);\n        },\n        toString: function () {\n            return '[' + this.operations.reduce(function (prev, next) {\n                if (prev) {\n                    return prev + ',' + next.toString();\n                }\n                else {\n                    return next.toString();\n                }\n            }, '') + ']';\n        }\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createPatch;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/patch/createPatch.js\n// module id = 50\n// module chunks = 0","\"use strict\";\nfunction shouldRecurseInto(value) {\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\nexports.shouldRecurseInto = shouldRecurseInto;\nfunction isEqual(a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return a.length === b.length && a.every(function (element, i) { return isEqual(element, b[i]); });\n    }\n    else if (shouldRecurseInto(a) && shouldRecurseInto(b)) {\n        var keysForA = Object.keys(a).sort();\n        var keysforB = Object.keys(b).sort();\n        return isEqual(keysForA, keysforB) && keysForA.every(function (key) { return isEqual(a[key], b[key]); });\n    }\n    else {\n        return a === b;\n    }\n}\nexports.isEqual = isEqual;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/utils.js\n// module id = 51\n// module chunks = 0","\"use strict\";\nvar utils_1 = require(\"../utils\");\nvar createJsonPointer_1 = require(\"./createJsonPointer\");\nfunction navigatePath(target, path) {\n    var currentPath = '';\n    var lastSegment = '';\n    var pathSegments = path.segments();\n    pathSegments.forEach(function (segment, index) {\n        currentPath += \"/\" + segment;\n        if (!target) {\n            throw new Error(\"Invalid path: \" + currentPath + \" doesn't exist in target\");\n        }\n        else if (index + 1 < pathSegments.length) {\n            target = target[segment];\n        }\n        else {\n            lastSegment = segment;\n        }\n    });\n    return {\n        object: target,\n        property: lastSegment\n    };\n}\nfunction add(target) {\n    var applyTo = navigatePath(target, this.path);\n    applyTo.object[applyTo.property] = this.value;\n    return target;\n}\nfunction remove(target) {\n    var applyTo = navigatePath(target, this.path);\n    delete applyTo.object[applyTo.property];\n    return target;\n}\nfunction replace(target) {\n    var applyTo = navigatePath(target, this.path);\n    if (!(applyTo.property in applyTo.object)) {\n        throw new Error(\"Cannot replace undefined path: \" + this.path.toString() + \" on object\");\n    }\n    applyTo.object[applyTo.property] = this.value;\n    return target;\n}\nfunction copyOrMove(from, to, target, toDelete) {\n    var moveFrom = navigatePath(target, from);\n    if (!(moveFrom.property in moveFrom.object)) {\n        throw new Error(\"Cannot move from undefined path: \" + from.toString() + \" on object\");\n    }\n    var applyTo = navigatePath(target, to);\n    applyTo.object[applyTo.property] = moveFrom.object[moveFrom.property];\n    if (toDelete) {\n        delete moveFrom.object[moveFrom.property];\n    }\n}\nfunction move(target) {\n    copyOrMove(this.from, this.path, target, true);\n    return target;\n}\nfunction copy(target) {\n    copyOrMove(this.from, this.path, target, false);\n    return target;\n}\nfunction test(target) {\n    var applyTo = navigatePath(target, this.path);\n    return utils_1.isEqual(applyTo.object[applyTo.property], this.value);\n}\nfunction getPath(path) {\n    if (Array.isArray(path)) {\n        return createJsonPointer_1.default.apply(void 0, path);\n    }\n    else {\n        return path;\n    }\n}\nfunction toString() {\n    var jsonObj = {};\n    jsonObj.op = this.op;\n    jsonObj.path = this.path.toString();\n    if (this.value) {\n        jsonObj.value = this.value;\n    }\n    if (this.from) {\n        jsonObj.from = this.from.toString();\n    }\n    return JSON.stringify(jsonObj);\n}\nfunction createOperation(type, path, value, from, oldValue) {\n    switch (type) {\n        case 0 /* Add */:\n            return {\n                op: 'add',\n                path: getPath(path),\n                value: value,\n                apply: add,\n                toString: toString\n            };\n        case 1 /* Remove */:\n            return {\n                op: 'remove',\n                path: getPath(path),\n                apply: remove,\n                toString: toString\n            };\n        case 2 /* Replace */:\n            return {\n                op: 'replace',\n                path: getPath(path),\n                value: value,\n                oldValue: oldValue,\n                apply: replace,\n                toString: toString\n            };\n        case 4 /* Move */:\n            if (!from) {\n                throw new Error('From value is required for Move operations');\n            }\n            return {\n                op: 'move',\n                path: getPath(path),\n                from: getPath(from),\n                apply: move,\n                toString: toString\n            };\n        case 3 /* Copy */:\n            if (!from) {\n                throw new Error('From value is required in Copy operation');\n            }\n            return {\n                op: 'copy',\n                path: getPath(path),\n                from: getPath(from),\n                apply: copy,\n                toString: toString\n            };\n        case 5 /* Test */:\n            return {\n                op: 'test',\n                path: getPath(path),\n                value: value,\n                apply: test,\n                toString: toString\n            };\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createOperation;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/patch/createOperation.js\n// module id = 52\n// module chunks = 0","\"use strict\";\nfunction navigate(path, target) {\n    return path.segments().reduce(function (prev, next) {\n        return prev ? prev[next] : prev;\n    }, target);\n}\nexports.navigate = navigate;\nfunction decode(segment) {\n    return segment.replace(/~1/g, '/').replace(/~0/g, '~');\n}\nfunction encode(segment) {\n    return segment.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\nfunction toString() {\n    var segments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        segments[_i] = arguments[_i];\n    }\n    return segments.reduce(function (prev, next) {\n        return prev + '/' + encode(next);\n    });\n}\nfunction createJsonPointer() {\n    var segments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        segments[_i] = arguments[_i];\n    }\n    return {\n        segments: function () {\n            return segments.map(function (segment) { return decode(segment); });\n        }, toString: function () {\n            return toString.apply(void 0, segments);\n        },\n        push: function (segment) {\n            return createJsonPointer.apply(void 0, segments.concat(segment));\n        },\n        pop: function () {\n            return createJsonPointer.apply(void 0, segments.slice(0, segments.length - 1));\n        }\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createJsonPointer;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/patch/createJsonPointer.js\n// module id = 53\n// module chunks = 0","\"use strict\";\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar global_1 = require(\"@dojo/core/global\");\nglobal_1.default.Rx = { config: { Promise: Promise_1.default } };\nfunction createStoreObservable(observable, transform) {\n    // Cast to any because the signatures of catch between the Observable and Promise interfaces are not\n    // compatible\n    var storeObservable = observable;\n    storeObservable.then = function (onFulfilled, onRejected) {\n        // Wrap in a shim promise because the interface that leaks through observable.toPromise is missing some\n        // properties on the shim(e.g. promise)\n        return Promise_1.default.resolve(observable.toPromise())\n            .then(transform)\n            .then(onFulfilled, onRejected);\n    };\n    storeObservable.catch = function (onRejected) {\n        return observable.toPromise().then(transform).then(undefined, onRejected);\n    };\n    return storeObservable;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createStoreObservable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/store/createStoreObservable.js\n// module id = 54\n// module chunks = 0","\"use strict\";\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar Map_1 = require(\"@dojo/shim/Map\");\nvar lang_1 = require(\"@dojo/core/lang\");\nvar uuid_1 = require(\"@dojo/core/uuid\");\nvar instanceStateMap = new WeakMap_1.default();\nfunction putSync(instance, items, options) {\n    var state = instanceStateMap.get(instance);\n    var ids = instance.identify(items);\n    var updatedItems = [];\n    var oldIndices = [];\n    var newIds = [];\n    var newItems = [];\n    ids.forEach(function (id, index) {\n        var oldIndex = state.index.get(id);\n        if (typeof oldIndex === 'undefined') {\n            newIds.push(id);\n            newItems.push(items[index]);\n        }\n        else {\n            updatedItems.push(items[index]);\n            oldIndices.push(oldIndex);\n        }\n    });\n    if (oldIndices.length && options && options.rejectOverwrite) {\n        throw Error('Objects already exist in store');\n    }\n    var data = state.data;\n    updatedItems.forEach(function (item, index) {\n        data[oldIndices[index]] = item;\n    });\n    newItems.forEach(function (item, index) {\n        state.index.set(newIds[index], data.push(item) - 1);\n    });\n    return {\n        successfulData: items,\n        type: 1 /* Put */\n    };\n}\nvar createInMemoryStorage = compose_1.default({\n    identify: function (items) {\n        var state = instanceStateMap.get(this);\n        var itemArray = Array.isArray(items) ? items : [items];\n        if (state.idProperty) {\n            var idProperty_1 = state.idProperty;\n            return itemArray.map(function (item) {\n                return item[idProperty_1];\n            });\n        }\n        else if (state.idFunction) {\n            return itemArray.map(state.idFunction);\n        }\n        else {\n            return itemArray.map(function (item) {\n                return item.id;\n            });\n        }\n    },\n    createId: function () {\n        return Promise_1.default.resolve(uuid_1.default());\n    },\n    fetch: function (query) {\n        var state = instanceStateMap.get(this);\n        var fullData = state.data;\n        var data = (query ? query.apply(fullData) : fullData).slice();\n        var returnPromise = state.returnsPromise.then(function () { return data; });\n        state.returnsPromise = returnPromise;\n        returnPromise.totalLength = returnPromise.dataLength = Promise_1.default.resolve(fullData.length);\n        return returnPromise;\n    },\n    get: function (ids) {\n        var state = instanceStateMap.get(this);\n        var data = state.data;\n        var objects = [];\n        return Promise_1.default.resolve(ids.reduce(function (prev, next) {\n            return state.index.has(next) ? prev.concat(data[state.index.get(next)]) : prev;\n        }, objects));\n    },\n    put: function (items, options) {\n        var state = instanceStateMap.get(this);\n        try {\n            var result_1 = putSync(this, items, options);\n            // Don't control the order operations are executed in, but make sure that the results\n            // resolve in the order they were actually executed in.\n            var returnPromise = state.returnsPromise.then(function () { return result_1; });\n            state.returnsPromise = returnPromise;\n            return returnPromise;\n        }\n        catch (error) {\n            return Promise_1.default.reject(error);\n        }\n    },\n    add: function (items, options) {\n        options = options || {};\n        var state = instanceStateMap.get(this);\n        if (typeof options.rejectOverwrite === 'undefined') {\n            options.rejectOverwrite = true;\n        }\n        try {\n            var result_2 = putSync(this, items, options);\n            // Don't control the order operations are executed in, but make sure that the results\n            // resolve in the order they were actually executed in.\n            var returnPromise = state.returnsPromise.then(function () {\n                result_2.type = 0 /* Add */;\n                return result_2;\n            });\n            state.returnsPromise = returnPromise;\n            return returnPromise;\n        }\n        catch (error) {\n            return Promise_1.default.reject(error);\n        }\n    },\n    delete: function (ids) {\n        var state = instanceStateMap.get(this);\n        var data = state.data;\n        var idsToRemove = ids.filter(function (id) {\n            return state.index.has(id);\n        });\n        var indices = idsToRemove\n            .map(function (id) {\n            return state.index.get(id);\n        })\n            .sort();\n        idsToRemove.forEach(function (id) {\n            state.index.delete(id);\n        });\n        indices.forEach(function (index, indexArrayIndex) {\n            return data.splice(index - indexArrayIndex, 1);\n        });\n        if (indices.length) {\n            var firstInvalidIndex_1 = indices[0];\n            var updateIndexForIds = this.identify(data.slice(firstInvalidIndex_1));\n            updateIndexForIds.forEach(function (id, index) {\n                state.index.set(id, index + firstInvalidIndex_1);\n            });\n        }\n        // Don't control the order operations are executed in, but make sure that the results\n        // resolve in the order they were actually executed in.\n        var returnPromise = state.returnsPromise.then(function () { return ({\n            successfulData: idsToRemove,\n            type: 3 /* Delete */\n        }); });\n        state.returnsPromise = returnPromise;\n        return returnPromise;\n    },\n    patch: function (updates) {\n        var state = instanceStateMap.get(this);\n        var data = state.data;\n        var filteredUpdates = updates.filter(function (update) {\n            return state.index.has(update.id);\n        });\n        var oldIndices = filteredUpdates.map(function (update) {\n            return state.index.get(update.id);\n        });\n        try {\n            var updatedItems_1 = filteredUpdates.map(function (update, index) {\n                var item = lang_1.duplicate(data[oldIndices[index]]);\n                var updatedItem = update.patch.apply(item);\n                data[oldIndices[index]] = updatedItem;\n                return updatedItem;\n            });\n            // Don't control the order operations are executed in, but make sure that the results\n            // resolve in the order they were actually executed in.\n            var returnsPromise = state.returnsPromise.then(function () { return ({\n                successfulData: updatedItems_1,\n                type: 2 /* Patch */\n            }); });\n            state.returnsPromise = returnsPromise;\n            return returnsPromise;\n        }\n        catch (error) {\n            return Promise_1.default.reject(error);\n        }\n    },\n    isUpdate: function (item) {\n        var state = instanceStateMap.get(this);\n        var id = this.identify([item])[0];\n        var isUpdate = state.index.has(id);\n        return Promise_1.default.resolve({\n            id: id,\n            item: item,\n            isUpdate: isUpdate\n        });\n    }\n}, function (instance, options) {\n    options = options || {};\n    instanceStateMap.set(instance, {\n        data: [],\n        index: new Map_1.default(),\n        idProperty: options.idProperty,\n        idFunction: options.idFunction,\n        returnsPromise: Promise_1.default.resolve()\n    });\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createInMemoryStorage;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/storage/createInMemoryStorage.js\n// module id = 55\n// module chunks = 0","\"use strict\";\n/**\n * Returns a v4 compliant UUID.\n *\n * @returns {string}\n */\nfunction uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = uuid;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/uuid.js\n// module id = 56\n// module chunks = 0","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\"use strict\";\nvar decorators_1 = require(\"./support/decorators\");\nvar global_1 = require(\"./support/global\");\nvar iterator_1 = require(\"./iterator\");\nrequire(\"./Symbol\");\nvar Shim;\n(function (Shim) {\n    var Set = (function () {\n        function Set(iterable) {\n            var _this = this;\n            this._setData = [];\n            this[Symbol.toStringTag] = 'Set';\n            if (iterable) {\n                iterator_1.forOf(iterable, function (value) { return _this.add(value); });\n            }\n        }\n        ;\n        Set.prototype.add = function (value) {\n            if (this.has(value)) {\n                return this;\n            }\n            this._setData.push(value);\n            return this;\n        };\n        ;\n        Set.prototype.clear = function () {\n            this._setData.length = 0;\n        };\n        ;\n        Set.prototype.delete = function (value) {\n            var idx = this._setData.indexOf(value);\n            if (idx === -1) {\n                return false;\n            }\n            this._setData.splice(idx, 1);\n            return true;\n        };\n        ;\n        Set.prototype.entries = function () {\n            return new iterator_1.ShimIterator(this._setData.map(function (value) { return [value, value]; }));\n        };\n        ;\n        Set.prototype.forEach = function (callbackfn, thisArg) {\n            var iterator = this.values();\n            var result = iterator.next();\n            while (!result.done) {\n                callbackfn.call(thisArg, result.value, result.value, this);\n                result = iterator.next();\n            }\n        };\n        ;\n        Set.prototype.has = function (value) {\n            return this._setData.indexOf(value) > -1;\n        };\n        ;\n        Set.prototype.keys = function () {\n            return new iterator_1.ShimIterator(this._setData);\n        };\n        ;\n        Object.defineProperty(Set.prototype, \"size\", {\n            get: function () {\n                return this._setData.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Set.prototype.values = function () {\n            return new iterator_1.ShimIterator(this._setData);\n        };\n        ;\n        Set.prototype[Symbol.iterator] = function () {\n            return new iterator_1.ShimIterator(this._setData);\n        };\n        ;\n        return Set;\n    }());\n    Shim.Set = Set;\n})(Shim = exports.Shim || (exports.Shim = {}));\nvar Set = (function () {\n    /* istanbul ignore next */\n    function Set(iterable) {\n        /* istanbul ignore next */\n        this[Symbol.toStringTag] = 'Set';\n    }\n    ;\n    /* istanbul ignore next */\n    Set.prototype.add = function (value) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype.clear = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype.delete = function (value) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype.entries = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype.forEach = function (callbackfn, thisArg) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype.has = function (value) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype.keys = function () { throw new Error('Abstract method'); };\n    ;\n    Object.defineProperty(Set.prototype, \"size\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error('Abstract method'); },\n        enumerable: true,\n        configurable: true\n    });\n    ;\n    /* istanbul ignore next */\n    Set.prototype.values = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype[Symbol.iterator] = function () { throw new Error('Abstract method'); };\n    ;\n    return Set;\n}());\nSet = __decorate([\n    decorators_1.hasClass('es6-set', global_1.default.Set, Shim.Set)\n], Set);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Set;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/Set.js\n// module id = 57\n// module chunks = 0","\"use strict\";\nvar lang_1 = require(\"./lang\");\n/**\n * Wraps a setTimeout call in a handle, allowing the timeout to be cleared by calling destroy.\n *\n * @param callback Callback to be called when the timeout elapses\n * @param delay Number of milliseconds to wait before calling the callback\n * @return Handle which can be destroyed to clear the timeout\n */\nfunction createTimer(callback, delay) {\n    var timerId = setTimeout(callback, delay);\n    return lang_1.createHandle(function () {\n        if (timerId) {\n            clearTimeout(timerId);\n            timerId = null;\n        }\n    });\n}\nexports.createTimer = createTimer;\n/**\n * Wraps a callback, returning a function which fires after no further calls are received over a set interval.\n *\n * @param callback Callback to wrap\n * @param delay Number of milliseconds to wait after any invocations before calling the original callback\n * @return Debounced function\n */\nfunction debounce(callback, delay) {\n    // node.d.ts clobbers setTimeout/clearTimeout with versions that return/receive NodeJS.Timer,\n    // but browsers return/receive a number\n    var timer;\n    return function () {\n        timer && clearTimeout(timer);\n        var context = this;\n        var args = arguments;\n        timer = setTimeout(function () {\n            callback.apply(context, args);\n            args = context = timer = null;\n        }, delay);\n    };\n}\nexports.debounce = debounce;\n/**\n * Wraps a callback, returning a function which fires at most once per set interval.\n *\n * @param callback Callback to wrap\n * @param delay Number of milliseconds to wait before allowing the original callback to be called again\n * @return Throttled function\n */\nfunction throttle(callback, delay) {\n    var ran;\n    return function () {\n        if (ran) {\n            return;\n        }\n        ran = true;\n        callback.apply(this, arguments);\n        setTimeout(function () {\n            ran = null;\n        }, delay);\n    };\n}\nexports.throttle = throttle;\n/**\n * Like throttle, but calls the callback at the end of each interval rather than the beginning.\n * Useful for e.g. resize or scroll events, when debounce would appear unresponsive.\n *\n * @param callback Callback to wrap\n * @param delay Number of milliseconds to wait before calling the original callback and allowing it to be called again\n * @return Throttled function\n */\nfunction throttleAfter(callback, delay) {\n    var ran;\n    return function () {\n        if (ran) {\n            return;\n        }\n        ran = true;\n        var context = this;\n        var args = arguments;\n        setTimeout(function () {\n            callback.apply(context, args);\n            args = context = ran = null;\n        }, delay);\n    };\n}\nexports.throttleAfter = throttleAfter;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/util.js\n// module id = 58\n// module chunks = 0","import todoStore, { Item } from '../stores/todoStore';\nimport createFilter from '@dojo/stores/query/createFilter';\nimport { assign } from '@dojo/core/lang';\n\nlet id = 0;\n\nexport const addTodo = function({ label, completed }: { label: string, completed: boolean }) {\n\treturn todoStore.add({ id: `${id++}`, label, completed });\n};\n\nexport const deleteTodo = function({ id }: { id: string }) {\n\treturn todoStore.delete(id);\n};\n\nexport const deleteCompleted = function() {\n\treturn todoStore.fetch(createFilter<Item>().equalTo('completed', true))\n\t\t.then((items: Item[]) => todoStore.identify(items))\n\t\t.then((ids: string[]) => todoStore.delete(ids));\n};\n\nexport const toggleAll = function({ checked: completed }: { checked: boolean }) {\n\treturn todoStore.fetch()\n\t\t.then((items: Item[]) => {\n\t\t\treturn items.map((item) => {\n\t\t\t\treturn assign({}, item, <any> { completed });\n\t\t\t});\n\t\t})\n\t\t.then((items) => todoStore.patch(items));\n};\n\nexport const updateTodo = function(item: Item) {\n\treturn todoStore.patch(item);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions/todoStoreActions.ts","import { createObservableStore } from '@dojo/stores/store/mixins/createObservableStoreMixin';\nimport { putTodo } from '../actions/widgetStoreActions';\n\nexport interface Item {\n\tid: string;\n\tlabel?: string;\n\tcompleted?: boolean;\n}\n\nconst todoStore = createObservableStore({\n\tdata: <Item[]> [],\n\tfetchAroundUpdates: true\n});\n\nexport default todoStore;\n\nexport function bindActions() {\n\treturn todoStore\n\t\t.observe()\n\t\t.subscribe((options) => {\n\t\t\tputTodo(options);\n\t\t});\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/stores/todoStore.ts","import { StoreDelta } from '@dojo/stores/store/mixins/createObservableStoreMixin';\nimport widgetStore from '../stores/widgetStore';\n\nexport const putTodo = function({ afterAll = [] }: StoreDelta<any>) {\n\tconst completedCount = afterAll.filter(({ completed }) => completed).length;\n\tconst activeCount = afterAll.length - completedCount;\n\tconst allCompleted = afterAll.length === completedCount && afterAll.length;\n\n\treturn widgetStore.patch({ id: 'todo-app', todos: afterAll, activeCount, completedCount, allCompleted });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions/widgetStoreActions.ts","\"use strict\";\nvar createJsonPointer_1 = require(\"../patch/createJsonPointer\");\nvar utils_1 = require(\"../utils\");\nfunction isBooleanOp(op) {\n    return op === 0 /* And */ || op === 1 /* Or */;\n}\nfunction isFilter(filterOrFunction) {\n    return typeof filterOrFunction !== 'function' && filterOrFunction.apply;\n}\nfunction createFilterOrReturnOp(descriptorOrOp) {\n    if (isBooleanOp(descriptorOrOp)) {\n        return descriptorOrOp;\n    }\n    else {\n        return createComparator(descriptorOrOp.filterType, descriptorOrOp.value, descriptorOrOp.path);\n    }\n}\nfunction createFilter(filterDescriptors, serializer) {\n    var filters = [];\n    if (filterDescriptors) {\n        if (Array.isArray(filterDescriptors)) {\n            filters = filterDescriptors.map(function (descriptorChainMember) {\n                if (Array.isArray(descriptorChainMember)) {\n                    return createFilter(descriptorChainMember);\n                }\n                else {\n                    return createFilterOrReturnOp(descriptorChainMember);\n                }\n            });\n        }\n        else {\n            filters.push(createComparator(filterDescriptors.filterType, filterDescriptors.value, filterDescriptors.path));\n        }\n    }\n    return createFilterHelper(filters, serializer || serializeFilter);\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createFilter;\nfunction createFilterHelper(filters, serializer) {\n    // Small helpers to abstract common operations for building comparator filters\n    // The main helper delegates to the factory, adding and AND operation before the next filter,\n    // because by default each filter in a chain will be ANDed with the previous.\n    function comparatorFilterHelper(filterType, value, path) {\n        path = path || createJsonPointer_1.default();\n        var needsOperator = filters.length > 0 &&\n            ((filters[filters.length - 1] !== 0 /* And */ && filters[filters.length - 1] !== 1) /* Or */);\n        var newFilters = needsOperator ? filters.concat([0 /* And */, createComparator(filterType, value, path)]) : filters.concat([createComparator(filterType, value, path)]);\n        return createFilterHelper(newFilters, serializer);\n    }\n    var filter = {\n        test: function (item) {\n            return applyFilterChain(item, filters);\n        },\n        filterType: 12 /* Compound */,\n        apply: function (data) {\n            return data.filter(this.test);\n        },\n        filterChain: filters,\n        toString: function (filterSerializer) {\n            return (filterSerializer || serializer)(this);\n        },\n        and: function (newFilter) {\n            var newFilters = [];\n            if (newFilter) {\n                newFilters.push(this, 0 /* And */, newFilter);\n            }\n            else if (filters.length) {\n                newFilters.push.apply(newFilters, filters.concat([0 /* And */]));\n            }\n            return createFilterHelper(newFilters, serializer);\n        },\n        or: function (newFilter) {\n            var newFilters = [];\n            if (newFilter) {\n                newFilters.push(this, 1 /* Or */, newFilter);\n            }\n            else if (filters.length) {\n                newFilters.push.apply(newFilters, filters.concat([1 /* Or */]));\n            }\n            return createFilterHelper(newFilters, serializer);\n        },\n        lessThan: function (path, value) {\n            return comparatorFilterHelper(0 /* LessThan */, value, path);\n        },\n        lessThanOrEqualTo: function (path, value) {\n            return comparatorFilterHelper(8 /* LessThanOrEqualTo */, value, path);\n        },\n        greaterThan: function (path, value) {\n            return comparatorFilterHelper(1 /* GreaterThan */, value, path);\n        },\n        greaterThanOrEqualTo: function (path, value) {\n            return comparatorFilterHelper(9 /* GreaterThanOrEqualTo */, value, path);\n        },\n        matches: function (path, value) {\n            return comparatorFilterHelper(10 /* Matches */, value, path);\n        },\n        'in': function (path, value) {\n            return comparatorFilterHelper(4 /* In */, value, path);\n        },\n        contains: function (path, value) {\n            return comparatorFilterHelper(5 /* Contains */, value, path);\n        },\n        equalTo: function (path, value) {\n            return comparatorFilterHelper(2 /* EqualTo */, value, path);\n        },\n        deepEqualTo: function (path, value) {\n            return comparatorFilterHelper(3 /* DeepEqualTo */, value, path);\n        },\n        notEqualTo: function (path, value) {\n            return comparatorFilterHelper(6 /* NotEqualTo */, value, path);\n        },\n        notDeepEqualTo: function (path, value) {\n            return comparatorFilterHelper(7 /* NotDeepEqualTo */, value, path);\n        },\n        custom: function (test) {\n            return comparatorFilterHelper(11 /* Custom */, test);\n        },\n        queryType: 0 /* Filter */,\n        incremental: true\n    };\n    return filter;\n}\nfunction applyFilterChain(item, filterChain) {\n    var ordFilterSections = [];\n    var startOfSlice = 0;\n    // Ands have higher precedence, so split into chains of\n    // ands between ors.\n    filterChain.forEach(function (chainMember, i) {\n        if (chainMember === 1 /* Or */) {\n            ordFilterSections.push(filterChain.slice(startOfSlice, i));\n            startOfSlice = i + 1;\n        }\n    });\n    if (startOfSlice < filterChain.length) {\n        ordFilterSections.push(filterChain.slice(startOfSlice, filterChain.length));\n    }\n    // These sections are or'd together so only\n    // one has to pass\n    return ordFilterSections.some(function (filterChain) {\n        // The individual filters are and'd together, so if any\n        // fails the whole section fails\n        return filterChain.every(function (filterOrAnd) {\n            if (isFilter(filterOrAnd)) {\n                return filterOrAnd.test(item);\n            }\n            else {\n                return true;\n            }\n        });\n    });\n}\nfunction createComparator(operator, value, path) {\n    path = typeof path === 'string' ? createJsonPointer_1.default(path) : path;\n    var test;\n    var filterType = operator;\n    var operatorString;\n    switch (operator) {\n        case 0 /* LessThan */:\n            test = function (property) {\n                return property < value;\n            };\n            operatorString = 'lt';\n            break;\n        case 8 /* LessThanOrEqualTo */:\n            test = function (property) {\n                return property <= value;\n            };\n            operatorString = 'lte';\n            break;\n        case 1 /* GreaterThan */:\n            test = function (property) {\n                return property > value;\n            };\n            operatorString = 'gt';\n            break;\n        case 9 /* GreaterThanOrEqualTo */:\n            test = function (property) {\n                return property >= value;\n            };\n            operatorString = 'gte';\n            break;\n        case 2 /* EqualTo */:\n            test = function (property) {\n                return property === value;\n            };\n            operatorString = 'eq';\n            break;\n        case 6 /* NotEqualTo */:\n            test = function (property) {\n                return property !== value;\n            };\n            operatorString = 'ne';\n            break;\n        case 3 /* DeepEqualTo */:\n            test = function (property) {\n                return utils_1.isEqual(property, value);\n            };\n            operatorString = 'eq';\n            break;\n        case 7 /* NotDeepEqualTo */:\n            test = function (property) {\n                return !utils_1.isEqual(property, value);\n            };\n            operatorString = 'ne';\n            break;\n        case 5 /* Contains */:\n            test = function (propertyOrItem) {\n                if (Array.isArray(propertyOrItem)) {\n                    return propertyOrItem.indexOf(value) > -1;\n                }\n                else {\n                    return propertyOrItem && Boolean(propertyOrItem[value]);\n                }\n            };\n            operatorString = 'contains';\n            break;\n        case 4 /* In */:\n            test = function (propertyOrItem) {\n                return Array.isArray(value) && value.indexOf(propertyOrItem) > -1;\n            };\n            operatorString = 'in';\n            break;\n        case 10 /* Matches */:\n            test = function (property) {\n                return value.test(property);\n            };\n            break;\n        case 11 /* Custom */:\n            test = value;\n            break;\n    }\n    return {\n        test: function (item) {\n            var propertyValue = createJsonPointer_1.navigate(path, item);\n            return test(propertyValue);\n        },\n        apply: function (data) {\n            return data.filter(this.test);\n        },\n        toString: function () {\n            if (!operatorString) {\n                throw Error('Cannot parse this filter type to an RQL query string');\n            }\n            return operatorString + \"(\" + path.toString() + \", \" + JSON.stringify(value) + \")\";\n        },\n        path: path,\n        value: value,\n        filterType: filterType,\n        queryType: 0 /* Filter */\n    };\n}\n//// Default serialization function\nfunction serializeFilter(filter) {\n    var operator = '&';\n    if (filter.filterChain && filter.filterChain.length > 0) {\n        return filter.filterChain.reduce(function (prev, next) {\n            if (isFilter(next)) {\n                var start = next.filterChain ? '(' : '';\n                var end = next.filterChain ? ')' : '';\n                return prev + (prev ? operator : '') + (prev ? start : '') + next.toString() + (prev ? end : '');\n            }\n            else if (next === 0 /* And */) {\n                operator = '&';\n                return prev;\n            }\n            else {\n                operator = '|';\n                return prev;\n            }\n        }, '');\n    }\n    else {\n        return '';\n    }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/query/createFilter.js\n// module id = 62\n// module chunks = 0","import { DNode, WidgetOptions, WidgetMixin, WidgetFactory, WidgetProperties } from '@dojo/widget-core/interfaces';\nimport createWidgetBase from '@dojo/widget-core/createWidgetBase';\nimport storeMixin, { StoreMixinApi, StoreMixinProperties } from '@dojo/widget-core/mixins/storeMixin';\nimport { v, w } from '@dojo/widget-core/d';\n\nimport { todoInput } from './actions/userActions';\nimport { bind } from './utils';\n\nexport interface AppProperties extends WidgetProperties, StoreMixinProperties { }\n\nexport interface AppMixin extends WidgetMixin<AppProperties>, StoreMixinApi { }\n\nexport interface AppFactory extends WidgetFactory<AppMixin, WidgetOptions<AppProperties>> { }\n\nconst createApp: AppFactory = createWidgetBase\n\t.mixin(storeMixin)\n\t.mixin({\n\t\tmixin: {\n\t\t\tclasses: [ 'todoapp' ],\n\t\t\ttagName: 'section',\n\t\t\tgetChildrenNodes: function(this: AppMixin): DNode[] {\n\t\t\t\tconst { todos = [], activeCount, completedCount, allCompleted, activeFilter } = this.state;\n\t\t\t\tconst classes = todos && todos.length ? [] : [ 'hidden' ];\n\t\t\t\tconst todoFooterProperties = { id: 'todo-footer', activeCount, completedCount, activeFilter, classes };\n\n\t\t\t\treturn [\n\t\t\t\t\tv('header', {}, [\n\t\t\t\t\t\tw('title', { label: 'todos' }),\n\t\t\t\t\t\tw('text-input', { classes: ['new-todo'], focused: true, placeholder: 'What needs to be done?', onKeyUp: bind(todoInput, this) })\n\t\t\t\t\t]),\n\t\t\t\t\tw('main-section', { todos, activeFilter, allCompleted }),\n\t\t\t\t\tw('todo-footer', todoFooterProperties)\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t});\n\nexport default createApp;\n\n\n\n// WEBPACK FOOTER //\n// ./src/createApp.ts","\"use strict\";\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar createEvented_1 = require(\"@dojo/compose/bases/createEvented\");\nvar lang_1 = require(\"@dojo/core/lang\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar Map_1 = require(\"@dojo/shim/Map\");\nvar d_1 = require(\"./d\");\n/**\n * Internal state map for widget instances\n */\nvar widgetInternalStateMap = new WeakMap_1.default();\nvar propertyFunctionNameRegex = /^diffProperty(.*)/;\nfunction getFromRegistry(instance, factoryLabel) {\n    if (instance.registry && instance.registry.has(factoryLabel)) {\n        return instance.registry.get(factoryLabel);\n    }\n    return d_1.registry.get(factoryLabel);\n}\nfunction dNodeToVNode(instance, dNode) {\n    var internalState = widgetInternalStateMap.get(instance);\n    if (typeof dNode === 'string' || dNode === null) {\n        return dNode;\n    }\n    if (d_1.isWNode(dNode)) {\n        var children = dNode.children, properties = dNode.properties;\n        var key = properties.key;\n        var factory_1 = dNode.factory;\n        var child = void 0;\n        if (typeof factory_1 === 'string') {\n            var item = getFromRegistry(instance, factory_1);\n            if (compose_1.isComposeFactory(item)) {\n                factory_1 = item;\n            }\n            else {\n                if (item && !internalState.initializedFactoryMap.has(factory_1)) {\n                    var promise = item.then(function (factory) {\n                        instance.invalidate();\n                        return factory;\n                    });\n                    internalState.initializedFactoryMap.set(factory_1, promise);\n                }\n                return null;\n            }\n        }\n        var childrenMapKey = key || factory_1;\n        var cachedChildren = internalState.cachedChildrenMap.get(childrenMapKey) || [];\n        var cachedChild_1;\n        cachedChildren.some(function (cachedChildWrapper) {\n            if (cachedChildWrapper.factory === factory_1 && !cachedChildWrapper.used) {\n                cachedChild_1 = cachedChildWrapper;\n                return true;\n            }\n            return false;\n        });\n        if (cachedChild_1) {\n            child = cachedChild_1.child;\n            if (properties) {\n                child.setProperties(properties);\n            }\n            cachedChild_1.used = true;\n        }\n        else {\n            child = factory_1({ properties: properties });\n            child.own(child.on('invalidated', function () {\n                instance.invalidate();\n            }));\n            cachedChildren = cachedChildren.concat([{ child: child, factory: factory_1, used: true }]);\n            internalState.cachedChildrenMap.set(childrenMapKey, cachedChildren);\n            instance.own(child);\n        }\n        if (!key && cachedChildren.length > 1) {\n            var errorMsg = 'It is recommended to provide a unique `key` property when using the same widget factory multiple times';\n            console.warn(errorMsg);\n            instance.emit({ type: 'error', target: instance, error: new Error(errorMsg) });\n        }\n        child.setChildren(children);\n        return child.__render__();\n    }\n    dNode.children = dNode.children\n        .filter(function (child) { return child !== null; })\n        .map(function (child) {\n        return dNodeToVNode(instance, child);\n    });\n    return dNode.render({ bind: instance });\n}\nfunction manageDetachedChildren(instance) {\n    var internalState = widgetInternalStateMap.get(instance);\n    internalState.cachedChildrenMap.forEach(function (cachedChildren, key) {\n        var filterCachedChildren = cachedChildren.filter(function (cachedChild) {\n            if (cachedChild.used) {\n                cachedChild.used = false;\n                return true;\n            }\n            cachedChild.child.destroy();\n            return false;\n        });\n        internalState.cachedChildrenMap.set(key, filterCachedChildren);\n    });\n}\nfunction formatTagNameAndClasses(tagName, classes) {\n    if (classes.length) {\n        return tagName + \".\" + classes.join('.');\n    }\n    return tagName;\n}\nvar createWidget = createEvented_1.default\n    .mixin({\n    mixin: {\n        get properties() {\n            var properties = widgetInternalStateMap.get(this).properties;\n            return properties;\n        },\n        classes: [],\n        getNode: function () {\n            var tag = formatTagNameAndClasses(this.tagName, this.classes);\n            return d_1.v(tag, this.getNodeAttributes(), this.getChildrenNodes());\n        },\n        get children() {\n            return widgetInternalStateMap.get(this).children;\n        },\n        setChildren: function (children) {\n            var internalState = widgetInternalStateMap.get(this);\n            internalState.children = children;\n            this.emit({\n                type: 'widget:children',\n                target: this\n            });\n        },\n        getChildrenNodes: function () {\n            return this.children;\n        },\n        getNodeAttributes: function (overrides) {\n            var _this = this;\n            var props = {};\n            this.nodeAttributes.forEach(function (fn) {\n                var newProps = fn.call(_this);\n                if (newProps) {\n                    lang_1.assign(props, newProps);\n                }\n            });\n            return props;\n        },\n        invalidate: function () {\n            var internalState = widgetInternalStateMap.get(this);\n            internalState.dirty = true;\n            this.emit({\n                type: 'invalidated',\n                target: this\n            });\n        },\n        get id() {\n            return this.properties.id;\n        },\n        setProperties: function (properties) {\n            var _this = this;\n            var internalState = widgetInternalStateMap.get(this);\n            var diffPropertyResults = {};\n            var diffPropertyChangedKeys = [];\n            internalState.diffPropertyFunctionMap.forEach(function (property, diffFunctionName) {\n                var previousProperty = internalState.previousProperties[property];\n                var newProperty = properties[property];\n                var result = _this[diffFunctionName](previousProperty, newProperty);\n                if (!result) {\n                    return;\n                }\n                if (result.changed) {\n                    diffPropertyChangedKeys.push(property);\n                }\n                delete properties[property];\n                delete internalState.previousProperties[property];\n                diffPropertyResults[property] = result.value;\n            });\n            var diffPropertiesResult = this.diffProperties(internalState.previousProperties, properties);\n            internalState.properties = lang_1.assign(diffPropertiesResult.properties, diffPropertyResults);\n            var changedPropertyKeys = diffPropertiesResult.changedKeys.concat(diffPropertyChangedKeys);\n            if (changedPropertyKeys.length) {\n                this.emit({\n                    type: 'properties:changed',\n                    target: this,\n                    properties: this.properties,\n                    changedPropertyKeys: changedPropertyKeys\n                });\n            }\n            internalState.previousProperties = this.properties;\n        },\n        diffProperties: function (previousProperties, newProperties) {\n            var changedKeys = Object.keys(newProperties).reduce(function (changedPropertyKeys, propertyKey) {\n                if (previousProperties[propertyKey] !== newProperties[propertyKey]) {\n                    changedPropertyKeys.push(propertyKey);\n                }\n                return changedPropertyKeys;\n            }, []);\n            return { changedKeys: changedKeys, properties: lang_1.assign({}, newProperties) };\n        },\n        nodeAttributes: [\n            function () {\n                var baseIdProp = this.properties && this.properties.id ? { 'data-widget-id': this.properties.id } : {};\n                var _a = (this.properties || {}).styles, styles = _a === void 0 ? {} : _a;\n                var classes = {};\n                var internalState = widgetInternalStateMap.get(this);\n                internalState.widgetClasses.forEach(function (c) { return classes[c] = false; });\n                if (this.properties && this.properties.classes) {\n                    this.properties.classes.forEach(function (c) { return classes[c] = true; });\n                    internalState.widgetClasses = this.properties.classes;\n                }\n                return lang_1.assign(baseIdProp, { key: this, classes: classes, styles: styles });\n            }\n        ],\n        __render__: function () {\n            var internalState = widgetInternalStateMap.get(this);\n            if (internalState.dirty || !internalState.cachedVNode) {\n                var widget = dNodeToVNode(this, this.getNode());\n                manageDetachedChildren(this);\n                if (widget) {\n                    internalState.cachedVNode = widget;\n                }\n                internalState.dirty = false;\n                return widget;\n            }\n            return internalState.cachedVNode;\n        },\n        registry: undefined,\n        tagName: 'div'\n    },\n    initialize: function (instance, options) {\n        if (options === void 0) { options = {}; }\n        var tagName = options.tagName, _a = options.properties, properties = _a === void 0 ? {} : _a;\n        var diffPropertyFunctionMap = new Map_1.default();\n        instance.tagName = tagName || instance.tagName;\n        Object.keys(Object.getPrototypeOf(instance)).forEach(function (attribute) {\n            var match = attribute.match(propertyFunctionNameRegex);\n            if (match) {\n                diffPropertyFunctionMap.set(match[0], \"\" + match[1].slice(0, 1).toLowerCase() + match[1].slice(1));\n            }\n        });\n        widgetInternalStateMap.set(instance, {\n            dirty: true,\n            widgetClasses: [],\n            properties: {},\n            previousProperties: {},\n            initializedFactoryMap: new Map_1.default(),\n            cachedChildrenMap: new Map_1.default(),\n            diffPropertyFunctionMap: diffPropertyFunctionMap,\n            children: []\n        });\n        instance.own(instance.on('properties:changed', function (evt) {\n            instance.invalidate();\n        }));\n        instance.setProperties(properties);\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createWidget;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widget-core/createWidgetBase.js\n// module id = 64\n// module chunks = 0","\"use strict\";\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar array_1 = require(\"@dojo/shim/array\");\nvar lang_1 = require(\"@dojo/core/lang\");\nvar createEvented_1 = require(\"@dojo/compose/bases/createEvented\");\n/**\n * Private map for store mixin.\n */\nvar internalStateMap = new WeakMap_1.default();\nvar stateMap = new WeakMap_1.default();\n/**\n * state changed event type\n */\nvar stateChangedEventType = 'state:changed';\nfunction replaceState(instance, state) {\n    var internalState = stateMap.get(instance);\n    internalState.state = state;\n    var eventObject = {\n        type: stateChangedEventType,\n        state: state,\n        target: instance\n    };\n    instance.emit(eventObject);\n}\nfunction onPropertiesChanged(instance, properties, changedPropertyKeys) {\n    var internalState = internalStateMap.get(instance);\n    if (internalState) {\n        if (array_1.includes(changedPropertyKeys, 'store') || array_1.includes(changedPropertyKeys, 'id')) {\n            internalState.handle.destroy();\n        }\n    }\n    instance.observe();\n}\n/**\n * Store Mixin Factory\n */\nvar storeMixinFactory = createEvented_1.default.mixin({\n    className: 'StoreMixin',\n    mixin: {\n        get state() {\n            return stateMap.get(this).state;\n        },\n        observe: function () {\n            var _this = this;\n            var internalState = internalStateMap.get(this);\n            var _a = this.properties, id = _a.id, store = _a.store;\n            if (!store) {\n                throw new Error('store is required to observe state');\n            }\n            if (internalState) {\n                if (internalState.id === id) {\n                    return;\n                }\n                throw new Error('Unable to observe state for a different id');\n            }\n            var observer = id ? store.observe(id) : store.observe();\n            var subscription = observer.subscribe(function (state) {\n                replaceState(_this, state['afterAll'] ? { data: state['afterAll'] } : state);\n            }, function (err) {\n                throw err;\n            });\n            var handle = {\n                destroy: function () {\n                    subscription.unsubscribe();\n                    internalStateMap.delete(_this);\n                }\n            };\n            internalStateMap.set(this, { id: id, handle: handle });\n            this.own(handle);\n        },\n        setState: function (newState) {\n            var _this = this;\n            var _a = this.properties, store = _a.store, id = _a.id;\n            if (id || newState['id']) {\n                store.patch(lang_1.assign({ id: id }, newState))\n                    .then(function () { return id ? store.get(id) : store.fetch(); })\n                    .then(function (state) {\n                    replaceState(_this, state);\n                });\n            }\n            else {\n                throw new Error('Unable to set state without a specified `id`');\n            }\n        }\n    },\n    initialize: function (instance) {\n        instance.own(instance.on('properties:changed', function (evt) {\n            onPropertiesChanged(instance, evt.properties, evt.changedPropertyKeys);\n        }));\n        instance.own(instance.on(stateChangedEventType, function () {\n            instance.invalidate();\n        }));\n        stateMap.set(instance, { state: Object.create(null) });\n        instance.observe();\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = storeMixinFactory;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widget-core/mixins/storeMixin.js\n// module id = 65\n// module chunks = 0","export function bind<T extends Function>(fn: T, instance: any): T {\n\treturn fn.bind(instance);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.ts","import { Widget, WidgetProperties, WidgetFactory } from '@dojo/widget-core/interfaces';\nimport createWidgetBase from '@dojo/widget-core/createWidgetBase';\nimport { VNodeProperties } from '@dojo/interfaces/vdom';\n\nexport interface LabelProperties extends WidgetProperties {\n\tlabel?: string;\n\tonKeypress?: (event: KeyboardEvent) => void;\n\tonDblclick?: (event: MouseEvent) => void;\n}\n\nexport type Label = Widget<LabelProperties> & {\n\tonKeypress: (event: KeyboardEvent) => void;\n\tonDblclick: (event: MouseEvent) => void;\n}\n\nexport interface LabelFactory extends WidgetFactory<Label, LabelProperties> {}\n\nconst createLabel: LabelFactory = createWidgetBase\n\t.mixin({\n\t\tmixin: {\n\t\t\ttagName: 'label',\n\t\t\tonDblclick(this: Label, event: MouseEvent) {\n\t\t\t\tthis.properties.onDblclick && this.properties.onDblclick(event);\n\t\t\t},\n\t\t\tonKeypress(this: Label, event: KeyboardEvent) {\n\t\t\t\tthis.properties.onKeypress && this.properties.onKeypress(event);\n\t\t\t},\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: Label): VNodeProperties {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinnerHTML: this.properties.label,\n\t\t\t\t\t\t'aria-describedby': 'edit-instructions',\n\t\t\t\t\t\ttabindex: '0',\n\t\t\t\t\t\tonkeyup: this.onKeypress,\n\t\t\t\t\t\tondblclick: this.onDblclick\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\nexport default createLabel;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createLabel.ts","import { Widget, WidgetProperties, WidgetFactory } from '@dojo/widget-core/interfaces';\nimport { VNodeProperties } from '@dojo/interfaces/vdom';\nimport createWidgetBase from '@dojo/widget-core/createWidgetBase';\n\nexport interface TitleProperties extends WidgetProperties {\n\tlabel?: string;\n}\n\nexport interface TitleFactory extends WidgetFactory<Widget<TitleProperties>, TitleProperties> { }\n\nconst createTitle: TitleFactory = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'h1',\n\t\tnodeAttributes: [\n\t\t\tfunction (this: Widget<TitleProperties>): VNodeProperties {\n\t\t\t\treturn { innerHTML: this.properties.label };\n\t\t\t}\n\t\t]\n\t}\n});\n\nexport default createTitle;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTitle.ts","import { VNodeProperties } from '@dojo/interfaces/vdom';\nimport createWidgetBase from '@dojo/widget-core/createWidgetBase';\nimport { Widget, WidgetProperties, WidgetFactory } from '@dojo/widget-core/interfaces';\n\nexport interface ButtonProperties extends WidgetProperties {\n\tlabel?: string;\n\tname?: string;\n\tonClick?(event: MouseEvent): void;\n}\n\nexport type Button = Widget<ButtonProperties> & {\n\tonClick(event?: MouseEvent): void;\n};\n\nexport interface ButtonFactory extends WidgetFactory<Button, ButtonProperties> { }\n\nconst createButton: ButtonFactory = createWidgetBase\n\t.mixin({\n\t\tmixin: {\n\t\t\tonClick(this: Button, event: MouseEvent) {\n\t\t\t\tthis.properties.onClick && this.properties.onClick(event);\n\t\t\t},\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction(this: Button): VNodeProperties {\n\t\t\t\t\treturn { innerHTML: this.properties.label, onclick: this.onClick };\n\t\t\t\t}\n\t\t\t],\n\t\t\ttagName: 'button',\n\t\t\ttype: 'button'\n\t\t}\n\t});\n\nexport default createButton;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createButton.ts","import { Widget, WidgetProperties, DNode } from '@dojo/widget-core/interfaces';\nimport { VNodeProperties } from '@dojo/interfaces/vdom';\nimport createWidgetBase from '@dojo/widget-core/createWidgetBase';\nimport { v, w } from '@dojo/widget-core/d';\nimport { todoEdit, todoEditInput, todoRemove, todoSave, todoToggleComplete } from '../actions/userActions';\nimport { bind } from './../utils';\n\nexport interface TodoItemProperties extends WidgetProperties {\n\tlabel: string;\n\tediting: boolean;\n\tcompleted: boolean;\n}\n\nexport type TodoItem = Widget<TodoItemProperties>\n\nexport type Identifiable<I> = I & {\n\ttodoId?: string;\n}\n\nconst createTodoItem = createWidgetBase.mixin({\n\t\tmixin: {\n\t\t\ttagName: 'li',\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction(this: TodoItem): VNodeProperties {\n\t\t\t\t\tconst { completed, editing } = this.properties;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tclasses: { completed, editing }\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t],\n\t\t\tgetChildrenNodes: function(this: TodoItem): (DNode | null)[] {\n\t\t\t\tconst { properties: { id: todoId, completed: checked, label, editing: focused = false } } = this;\n\n\t\t\t\treturn [\n\t\t\t\t\tv('div.view', [\n\t\t\t\t\t\tw('checkbox', { classes: [ 'toggle' ], checked, onChange: bind(todoToggleComplete, this) }),\n\t\t\t\t\t\tw('label', { label, onDblclick: bind(todoEdit, this), onKeypress: bind(todoEdit, this) }),\n\t\t\t\t\t\tw('button', { classes: [ 'destroy' ], onClick: bind(todoRemove, this) })\n\t\t\t\t\t]),\n\t\t\t\t\tfocused ? w('text-input', {\n\t\t\t\t\t\tvalue: label,\n\t\t\t\t\t\tid: todoId,\n\t\t\t\t\t\tfocused, classes: [ 'edit' ],\n\t\t\t\t\t\tonBlur: bind(todoSave, this),\n\t\t\t\t\t\tonKeyUp: bind(todoEditInput, this)\n\t\t\t\t\t}) : null\n\t\t\t\t];\n\t\t\t}\n\t\t}\n});\n\nexport default createTodoItem;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoItem.ts","import { Widget, WidgetFactory, WidgetProperties, DNode } from '@dojo/widget-core/interfaces';\nimport createWidgetBase from '@dojo/widget-core/createWidgetBase';\nimport { w } from '@dojo/widget-core/d';\nimport { assign } from '@dojo/core/lang';\nimport { Item } from './../stores/todoStore';\n\nexport interface TodoListProperties extends WidgetProperties { }\n\nexport type TodoList = Widget<TodoListProperties>\n\nexport interface TodoListFactory extends WidgetFactory<TodoList, TodoListProperties> {}\n\nfunction filter(filterName: string, todo: Item): boolean {\n\tswitch (filterName) {\n\t\tcase 'completed':\n\t\t\treturn !!todo.completed;\n\t\tcase 'active':\n\t\t\treturn !todo.completed;\n\t\tdefault:\n\t\t\treturn true;\n\t}\n}\n\nconst createTodoList: TodoListFactory = createWidgetBase\n\t.mixin({\n\t\tmixin: {\n\t\t\ttagName: 'ul',\n\t\t\tclasses: [ 'todo-list' ],\n\t\t\tgetChildrenNodes: function(this: TodoList): DNode[] {\n\t\t\t\tconst { todos = [], activeFilter = '' } = this.properties;\n\n\t\t\t\treturn todos\n\t\t\t\t\t.filter((todo: Item) => filter(activeFilter, todo))\n\t\t\t\t\t.map((todo: Item) => w('todo-item', assign(<any> {}, <any> { key: todo.id }, todo)));\n\t\t\t}\n\t\t}\n\t});\n\nexport default createTodoList;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoList.ts","import { Widget, WidgetFactory, WidgetProperties, DNode } from '@dojo/widget-core/interfaces';\nimport createWidgetBase from '@dojo/widget-core/createWidgetBase';\nimport { v }  from '@dojo/widget-core/d';\n\nexport interface TodoFilterProperties extends WidgetProperties {\n\tactiveFilter?: string;\n};\n\nexport type TodoFilter = Widget<TodoFilterProperties>;\n\nexport type TodoFilterFactory = WidgetFactory<TodoFilter, TodoFilterProperties>\n\nfunction createFilterItems(activeFilter: string): DNode[] {\n\tconst filters = [ 'all', 'active', 'completed' ];\n\treturn filters.map((filterItem) => {\n\t\tconst label = filterItem[0].toUpperCase() + filterItem.substring(1);\n\t\treturn v('li', {}, [\n\t\t\tv('a', {\n\t\t\t\tinnerHTML: label,\n\t\t\t\thref: `#${filterItem}`,\n\t\t\t\tclasses: {\n\t\t\t\t\tselected: activeFilter === filterItem\n\t\t\t\t}\n\t\t\t})\n\t\t]);\n\t});\n}\n\nconst createTodoFilter: TodoFilterFactory = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'ul',\n\t\tclasses: [ 'filters' ],\n\t\tgetChildrenNodes: function(this: TodoFilter): DNode[] {\n\t\t\tconst activeFilter = this.properties.activeFilter || '';\n\t\t\treturn createFilterItems(activeFilter);\n\t\t}\n\t}\n});\n\nexport default createTodoFilter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoFilter.ts","import { Widget, WidgetProperties, DNode } from '@dojo/widget-core/interfaces';\nimport createWidgetBase from '@dojo/widget-core/createWidgetBase';\nimport { v, w } from '@dojo/widget-core/d';\nimport { clearCompleted } from '../actions/userActions';\n\nexport interface TodoFooterProperties extends WidgetProperties {\n\tactiveFilter: string;\n\tactiveCount: number;\n\tcompletedCount: number;\n}\n\nexport type TodoFooter = Widget<TodoFooterProperties>;\n\nconst createTodoFooter = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'footer',\n\t\tclasses: [ 'footer' ],\n\t\tgetChildrenNodes: function(this: TodoFooter): (DNode | null)[] {\n\t\t\tconst { activeCount, activeFilter, completedCount } = this.properties;\n\t\t\tconst countLabel = activeCount === 1 ? 'item' : 'items';\n\n\t\t\treturn [\n\t\t\t\tv('span', { 'class': 'todo-count' }, [\n\t\t\t\t\tv('strong', [activeCount + ' ']),\n\t\t\t\t\tv('span', [countLabel + ' left'])\n\t\t\t\t]),\n\t\t\t\tw('todo-filter', {\n\t\t\t\t\tclasses: [ 'filters' ],\n\t\t\t\t\tactiveFilter\n\t\t\t\t}),\n\t\t\t\tcompletedCount ? w('button', {\n\t\t\t\t\tonClick: clearCompleted,\n\t\t\t\t\tlabel: 'Clear completed',\n\t\t\t\t\tclasses: [ 'clear-completed' ]\n\t\t\t\t}) : null\n\t\t\t];\n\t\t}\n\t}\n});\n\nexport default createTodoFooter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoFooter.ts","import { DNode, Widget, WidgetProperties } from '@dojo/widget-core/interfaces';\nimport createWidgetBase from '@dojo/widget-core/createWidgetBase';\nimport { w } from '@dojo/widget-core/d';\nimport { todoToggleAll } from '../actions/userActions';\n\nexport interface MainSectionProperties extends WidgetProperties {\n\tallCompleted: boolean;\n\tstore: any;\n}\n\nconst createMainSection = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'section',\n\t\tclasses: [ 'main' ],\n\t\tgetChildrenNodes: function (this: Widget<MainSectionProperties>): DNode[] {\n\t\t\tconst { properties: { activeFilter, todos, allCompleted: checked } } = this;\n\n\t\t\treturn [\n\t\t\t\tw('checkbox', { checked, onChange: todoToggleAll, classes: [ 'toggle-all' ]}),\n\t\t\t\tw('todo-list', { todos, activeFilter })\n\t\t\t];\n\t\t}\n\t}\n});\n\nexport default createMainSection;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createMainSection.ts","import createWidgetBase from '@dojo/widget-core/createWidgetBase';\nimport { Widget, WidgetFactory, WidgetProperties } from '@dojo/widget-core/interfaces';\nimport { VNodeProperties } from '@dojo/interfaces/vdom';\n\nexport interface CheckboxProperties extends WidgetProperties {\n\tchecked?: boolean;\n\tonChange?: (event?: Event) => void;\n};\n\nexport type CheckboxInput = Widget<CheckboxProperties> & {\n\tonChange: (event?: Event) => void;\n}\n\nexport type CheckboxInputFactory = WidgetFactory<CheckboxInput, CheckboxProperties>\n\nconst createCheckboxInput: CheckboxInputFactory = createWidgetBase\n\t.mixin({\n\t\tmixin: {\n\t\t\ttagName: 'input',\n\t\t\ttype: 'checkbox',\n\t\t\tonChange(this: CheckboxInput, event?: Event) {\n\t\t\t\tthis.properties.onChange && this.properties.onChange(event);\n\t\t\t},\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: CheckboxInput): VNodeProperties {\n\t\t\t\t\tconst { type, onChange: onchange, properties: { checked } } = this;\n\t\t\t\t\treturn { checked, onchange, type };\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\nexport default createCheckboxInput;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createCheckboxInput.ts","import createWidgetBase from '@dojo/widget-core/createWidgetBase';\nimport { Widget, WidgetProperties, WidgetFactory } from '@dojo/widget-core/interfaces';\nimport { VNodeProperties } from '@dojo/interfaces/vdom';\n\nexport interface FocusableTextProperties extends WidgetProperties {\n\tfocused?: boolean;\n\tplaceholder?: string;\n\tvalue?: string;\n\tonKeyUp?: (event?: KeyboardEvent) => void;\n\tonBlur?: (event?: Event) => void;\n};\n\nexport type FocusableTextInput = Widget<FocusableTextProperties> & {\n\tonKeyUp: (event?: KeyboardEvent) => void;\n\tonBlur: (event?: Event) => void;\n\tafterUpdate?: (element: HTMLInputElement) => void;\n}\n\nexport interface FocusableTextInputFactory extends WidgetFactory<FocusableTextInput, FocusableTextProperties> { }\n\nconst createFocusableTextInput: FocusableTextInputFactory = createWidgetBase\n\t.mixin({\n\t\tmixin: {\n\t\t\ttagName: 'input',\n\n\t\t\ttype: 'text',\n\n\t\t\tonKeyUp(this: FocusableTextInput, event?: KeyboardEvent) {\n\t\t\t\tthis.properties.onKeyUp && this.properties.onKeyUp(event);\n\t\t\t},\n\t\t\tonBlur(this: FocusableTextInput, event?: Event) {\n\t\t\t\tthis.properties.onBlur && this.properties.onBlur(event);\n\t\t\t},\n\t\t\tafterUpdate(this: FocusableTextInput, element: HTMLInputElement) {\n\t\t\t\tconst focused = this.properties.focused;\n\t\t\t\tif (focused) {\n\t\t\t\t\tsetTimeout(() => element.focus(), 0);\n\t\t\t\t}\n\t\t\t\telse if (!focused && document.activeElement === element) {\n\t\t\t\t\telement.blur();\n\t\t\t\t}\n\t\t\t},\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: FocusableTextInput): VNodeProperties {\n\t\t\t\t\tconst { onKeyUp: onkeyup, onBlur: onblur, afterUpdate, afterUpdate: afterCreate } = this;\n\t\t\t\t\tconst { placeholder, value = '' } = this.properties;\n\n\t\t\t\t\treturn { afterUpdate, placeholder, innerHTML: value, value, afterCreate, onkeyup, onblur };\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\nexport default createFocusableTextInput;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createFocusableTextInput.ts"],"sourceRoot":""}