{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///src/main.js","webpack:///webpack/bootstrap 7c54a583eb7a06d05079","webpack:///./src/main.ts","webpack:///./src/routes.ts","webpack:///./~/@dojo/routing/createRoute.js","webpack:///./~/@dojo/compose/compose.js","webpack:///./~/@dojo/core/instrument.js","webpack:///./~/@dojo/core/has.js","webpack:///./~/@dojo/core/global.js","webpack:///./~/@dojo/shim/support/has.js","webpack:///./~/@dojo/shim/support/global.js","webpack:///./~/@dojo/has/has.js","webpack:///./~/process/browser.js","webpack:///./~/@dojo/core/lang.js","webpack:///./~/@dojo/shim/array.js","webpack:///./~/@dojo/shim/support/util.js","webpack:///./~/@dojo/shim/iterator.js","webpack:///./~/@dojo/shim/string.js","webpack:///./~/@dojo/shim/Symbol.js","webpack:///./~/@dojo/shim/number.js","webpack:///./~/@dojo/shim/WeakMap.js","webpack:///./~/@dojo/shim/support/decorators.js","webpack:///./~/@dojo/compose/aspect.js","webpack:///./~/@dojo/core/UrlSearchParams.js","webpack:///./~/@dojo/routing/createRouter.js","webpack:///./~/@dojo/compose/bases/createEvented.js","webpack:///./~/@dojo/core/aspect.js","webpack:///./~/@dojo/shim/Map.js","webpack:///./~/@dojo/shim/object.js","webpack:///./~/@dojo/compose/bases/createDestroyable.js","webpack:///./~/@dojo/shim/Promise.js","webpack:///./~/@dojo/shim/support/queue.js","webpack:///./~/timers-browserify/main.js","webpack:///./~/setimmediate/setImmediate.js","webpack:///./~/@dojo/core/async/Task.js","webpack:///./~/@dojo/core/async/ExtensiblePromise.js","webpack:///./~/@dojo/core/on.js","webpack:///./~/@dojo/routing/lib/path.js","webpack:///./~/@dojo/routing/history/createHashHistory.js","webpack:///./src/actions/widgetStoreActions.ts","webpack:///./src/stores/widgetStore.ts","webpack:///./src/stores/createObservableStore.ts","webpack:///./~/@dojo/stores/store/createStore.js","webpack:///./~/@dojo/core/Observable.js","webpack:///./~/@dojo/shim/Observable.js","webpack:///./~/@dojo/stores/patch/createPatch.js","webpack:///./~/@dojo/stores/utils.js","webpack:///./~/@dojo/stores/patch/createOperation.js","webpack:///./~/@dojo/stores/patch/createJsonPointer.js","webpack:///./~/@dojo/stores/store/createStoreObservable.js","webpack:///./~/@dojo/stores/storage/createInMemoryStorage.js","webpack:///./~/@dojo/core/uuid.js","webpack:///./~/@dojo/stores/store/mixins/createObservableStoreMixin.js","webpack:///./~/@dojo/shim/Set.js","webpack:///./~/@dojo/core/util.js","webpack:///./src/stores/todoStore.ts","webpack:///./src/createApp.ts","webpack:///./~/@dojo/widgets/createProjector.js","webpack:///./~/@dojo/widgets/createWidgetBase.js","webpack:///./~/@dojo/compose/bases/createStateful.js","webpack:///./~/@dojo/widgets/d.js","webpack:///./~/maquette/dist/maquette.js","webpack:///./~/@dojo/widgets/FactoryRegistry.js","webpack:///./~/@dojo/widgets/mixins/shallowPropertyComparisonMixin.js","webpack:///./~/@dojo/widgets/mixins/createProjectorMixin.js","webpack:///./~/@dojo/widgets/mixins/externalState.js","webpack:///./src/widgets/createTodoDetails.ts","webpack:///./src/widgets/createFocusableTextInput.ts","webpack:///./~/@dojo/widgets/mixins/createFormFieldMixin.js","webpack:///./~/@dojo/compose/bases/createCancelableEvent.js","webpack:///./src/widgets/createCheckboxInput.ts","webpack:///./src/actions/todoStoreActions.ts","webpack:///./~/@dojo/stores/query/createFilter.js","webpack:///./src/widgets/createFormattedDate.ts","webpack:///./src/widgets/createHome.ts","webpack:///./src/actions/userActions.ts","webpack:///./src/widgets/createTodoFooter.ts","webpack:///./~/@dojo/widgets/components/button/createButton.js","webpack:///./src/widgets/createTodoFilter.ts","webpack:///./src/widgets/createViewChooser.ts","webpack:///./src/widgets/createTitle.ts","webpack:///./src/widgets/createMainSection.ts","webpack:///./src/widgets/createTodoItemList.ts","webpack:///./src/widgets/createTodoListItem.ts","webpack:///./src/widgets/createTodoCardItem.ts","webpack:///./src/widgets/createSearchInput.ts"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","routes_1","todoStore_1","widgetStore_1","createApp_1","document","getElementsByTagName","app","default","properties","externalState","append","then","bindActions","start","createRoute_1","createRouter_1","createHashHistory_1","widgetStoreActions_1","mainRoute","path","params","_a","searchParams","activeFilter","activeView","filter","view","get","exec","request","_b","setHierarchy","filterAndView","todoViewRoute","todoId","showTodoDetails","router","history","fallback","Object","defineProperty","value","computeDefaultParams","parameters","searchParameters","fromPathname","forEach","name","index","undefined","compose_1","UrlSearchParams_1","WeakMap_1","path_1","privateStateMap","parentMap","noop","createRoute","parent","add","_this","routes","route","hasBeenAppended","Error","push","set","Array","isArray","_i","add_1","length","link","findRouter","match","segments","hasTrailingSlash","computeParams","trailingSlashMustMatch","result","hasRemaining","trailingSlash","knownSearchParams","reduce","list","getAll","values","offset","rawPathValues","rawSearchParams","select","context","guard","matchResult","guardResult","redirect","remainingSelection","handler","selected","remainingSegments_1","slice","some","nested","nestedResult","selection","concat","instance","_c","test","TypeError","deconstructedPath","deconstruct","missingMethod","method","assignFactoryName","prototype","assignFunctionName","Symbol_1","toStringTag","configurable","fn","nameDescriptor","getOwnPropertyDescriptor","writable","assignProperties","overwrite","target","sources","arguments","source","defineProperties","getOwnPropertyNames","descriptors","key","sourceDescriptor","sourceValue","targetDescriptor","targetValue","current","array_1","includes","from","objectCreate","rebase","args","apply","getInitFunctionNames","initFns","privateFactoryData","map","factoryDescriptor","mixin","className","assignAdviceMap","createPrivateFactoryData","optionsAdvice","advice","factories","initFunction","proto","staticProperties","factoryData","base","optionsInitFns","initFn","lang_1","assign","Boolean","createFactory","options","constructor","SyntaxError","unshift","factoryPrototype","_loop_1","aspect","sourceMethod","aspect_1","before","after","around","staticMethods","DEFAULT_FACTORY_LABEL","freeze","isComposeFactory","extend","extension","instrument_1","deprecated","message","override","baseFactory","keys","overlay","overlayFunction","aspectAdviceToAdviceMap","aspectAdvice","mapAdvice","type","adviceTuple","adviceMap","beforeAdvice","afterAdvice","aroundAdvice","objectKeys","isComposeMixinable","toMixin","mixinDescriptor","initialize","doFrom","doBefore","doAfter","doAround","create","_static","doExtend","doMixin","doOverride","doOverlay","doAspect","doStatic","doFactoryDescriptor","static","compose","warn","url","has_1","DEFAULT_DEPRECATED_MESSAGE","warning","globalWarn","console","deprecatedAdvice","deprecatedDecorator","propertyKey","descriptor","originalFn_1","setWarn","__export","hasOwnProperty","global_1","requestAnimationFrame","ArrayBuffer","FormData","XMLHttpRequest","open","responseType","abort","global","globalObject","window","self","has_2","Symbol","fill","Number","POSITIVE_INFINITY","getCallSite","callSite","substitutions","String","b","raw","supportsTrunc","Math","acosh","clz32","imul","Promise","Observable","Set","has","Map","entries","e","WeakMap","key1","key2","setImmediate","postMessage","MutationObserver","WebKitMutationObserver","Function","process","isFeatureTestThenable","isStaticFeatureFunction","load","resourceId","require","config","normalize","skip","term","tokens","exists","feature","normalizedFeature","toLowerCase","staticCache","testCache","testFunctions","testThenables","resolvedValue","globalScope","staticFeatures","DojoHasEnvironment","location","versions","node","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","Item","array","nextTick","title","browser","env","argv","version","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","shouldDeepCopyObject","toString","copyArray","inherited","item","_mixin","deep","kwArgs","mixins","RangeError","deepAssign","deepMixin","duplicate","getPrototypeOf","isIdentical","lateBind","suppliedArgs","partial","targetFunction","createHandle","destructor","destroy","createCompositeHandle","handles","handles_1","handle","toLength","isNaN","isFinite","floor","min","max","number_1","MAX_SAFE_INTEGER","toInteger","abs","normalizeOffset","Shim","util_1","iterator_1","arrayLike","mapFunction","thisArg","bind","Constructor","isArrayLike","isIterable","forOf","of","items","copyWithin","end","count","direction","find","callback","findIndex","searchElement","fromIndex","currentElement","wrapNative","getValueDescriptor","enumerable","nativeFunction","iterator","iterable","ShimIterator","doBreak","broken","next","done","l","char","code","charCodeAt","string_1","HIGH_SURROGATE_MIN","HIGH_SURROGATE_MAX","staticDone","_nextIndex","_nativeIterator","_list","LOW_SURROGATE_MIN","LOW_SURROGATE_MAX","normalizeSubstringArgs","text","search","position","isEnd","rawStrings","numSubstitutions","length_1","fromCodePoint","codePoints","fromCharCode","MAX_SIZE","codeUnits","codePoint","isValid","highSurrogate","lowSurrogate","codePointAt","first","second","repeat","Infinity","startsWith","endsWith","endPosition","indexOf","padEnd","maxLength","fillString","strText","padding","padStart","isSymbol","validateSymbol","InternalSymbol","objPrototype","globalSymbols","getSymbolName","created","desc","postfix","description","sym","__description__","__name__","keyFor","hasInstance","for","isConcatSpreadable","observable","replace","species","split","toPrimitive","unscopables","valueOf","Exposed","SymbolShim","wellKnown","isInteger","isSafeInteger","EPSILON","pow","MIN_SAFE_INTEGER","__decorate","decorators","d","r","Reflect","decorate","decorators_1","getUID","random","DELETED","generateName","startId","Date","now","_frozenEntries","_getFrozenEntryIndex","delete","entry","_name","frozenIndex","splice","isFrozen","hasClass","trueClass","falseClass","getDispatcher","joinPoint","dispatcher","dispatchAdviceMap","previousArgs","currentArgs","previousResult","before_1","after_1","advise","AdviceType","Around","Before","After","parseQueryString","input","query","indexOfFirstEquals","decodeURIComponent","UrlSearchParams","encodedKey","encodeURIComponent","values_1","join","createDeferral","cancel","resume","promise","Promise_1","resolve","reject","reportError","error","catchRejection","thenable","catch","createEvented_1","Task_1","on_1","createRouter","dispatch","state","dispatchFromStart","canceled","deferrals","defer","success","parse","all","dispatched","currentSelection","result_1","roots","hierarchy","parent_1","addLeadingSlash","leadingSlash","addTrailingSlash","currentPathValues","currentSearchParams","expectedSegments","namedOffset","expectedSegments_1","segment","isNamedSegment","literal","searchParameters_1","value_1","_d","_e","pathname","prefix","replacePath","setPath","dispatchCurrent","started","contextFactory","pause","lastDispatch","redirectCount","redirecting","dispatchResult","listener","pausable","event","own","sharedContext_1","isActionable","do","resolveListener","handlesArraytoHandle","Map_1","createDestroyable_1","listenersMap","createEvented","listenerMap","type_1","listeners","listenerMapArg_1","isMapLike","receiveArguments","previous","advised","nextId","methodName","existing","results","executionId","newResults","object_1","_keys","_values","_indexOfKey","is","clear","length_2","getOwnPropertyDescriptorsWrapper","o","getOwnPropertySymbols","value1","value2","substring","symbolAwareKeys","prop","hasGetOwnPropertySymbols","getOwnPropertyDescriptors","destroyed","isDestroyable","handlesWeakMap","createDestroyable","queue_1","isThenable","executor","isChained","isResolved","callbacks","whenFinished","settle","newState","queueMicroTask","onFulfilled","onRejected","fulfill","complete","finish","populating","total","processItem","race","reason","clearImmediate","executeTask","isActive","getQueueHandle","microTasks","microTaskQueued","checkMicroTaskQueue","queueTask","enqueue","addEventListener","data","stopPropagation","shift","HostMutationObserver","node_1","createElement","queue_2","observer","observe","attributes","setAttribute","Timeout","clearFn","_id","_clearFn","setInterval","clearInterval","close","unref","ref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","task","tasksByHandle","nextHandle","registerImmediate","runIfPresent","currentlyRunningATask","installNextTickImplementation","canUsePostMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","installPostMessageImplementation","messagePrefix","onGlobalMessage","attachEvent","installMessageChannelImplementation","channel","MessageChannel","port1","port2","installReadyStateChangeImplementation","html","doc","documentElement","script","onreadystatechange","removeChild","appendChild","installSetTimeoutImplementation","attachTo","isTask","children","__extends","__","ExtensiblePromise_1","Task","_super","canceler","superResolve","superReject","_state","_cancel","finallyTask","runFinally","_finally","child","finally","unwrapPromises","unwrapped","ExtensiblePromise","_promise","promiseKeys_1","promiseResults","returnValue","rejected","valueOrError","dispatchEvent","ownerDocument","createEvent","nativeEvent","initEvent","bubbles","cancelable","capture","removeEventListener","paused","pathnameTokens","searchStart","hashStart","t","isMatch","expected","consume","peek","inSearchComponent","name_1","closing","separator","next_1","createHashHistory","privateState","browserLocation","hash","putTodo","afterAll","completedCount","completed","activeCount","allCompleted","patch","todos","widgets","todo","todoDetails","createObservableStore_1","createStore_1","createObservableStoreMixin_1","createObservableStore","isPatchArray","patches","isPatch","patchObj","operations","createStoreObservable","storeResultsPromise","createStoreObservable_1","Observable_1","successfulData","createPatch_1","createInMemoryStorage_1","instanceStateMap","createStore","ids","initialAddPromise","storage","put","updates","patchEntries","identify","diff","dupe","idInOptions","fetch","resolveTotalLength","rejectTotalLength","totalLength","fetchResult","dataLength","createId","instanceState","isSubscribable","object","subscribe","deferFunction","trueObservable","errorValue","completeValue","toPromise","filterFunction","toArray","mergeAll","concurrent","checkForComplete","itemIndex_1","nonEnumerable","startSubscription","unsubscribe","closed","cleanUp","subscriptionObserver","subscription","cleanUpError","observerError","errorResult","observerComplete","completeResult","ShimObservable","subscriber","_executor","observerOrNext","onError","onComplete","observableSymbol","_diff","to","startingPath","utils_1","shouldRecurseInto","createJsonPointer_1","fromKeys","toKeys","isEqual","createOperation_1","createPatch","prev","every","element","keysForA","sort","keysforB","navigatePath","currentPath","lastSegment","pathSegments","property","applyTo","remove","copyOrMove","toDelete","moveFrom","move","copy","getPath","jsonObj","op","JSON","stringify","createOperation","oldValue","navigate","decode","encode","createJsonPointer","pop","transform","storeObservable","Rx","putSync","updatedItems","oldIndices","newIds","newItems","oldIndex","rejectOverwrite","uuid_1","createInMemoryStorage","itemArray","idProperty","idProperty_1","idFunction","fullData","returnPromise","returnsPromise","objects","result_2","idsToRemove","indices","indexArrayIndex","firstInvalidIndex_1","updateIndexForIds","filteredUpdates","update","updatedItems_1","updatedItem","isUpdate","uuid","v","mergeDeltas","currentUpdate","newUpdate","takeLastItem","found","reverse","_","takeLastId","removeOutdatedItems","newDeletes","oldUpdates","deletedIds","removeCancellingUpdates","oldAdds","addIds","convertReplacementToUpdate","oldDeletes","newAdds","newUpdates","deletes","updateIds","adds","updatedUpdates","shouldKeep","beforeAll","addUpdateDelete","store","newData","localIndex","buildIndex","sendUpdates","storeDelta","queuedUpdate","localData","observers","isObserverEntry","observes","Set_1","isObserver","notifyItemObservers","notify","itemObservers","observerOrEntry","observerEntry","sendUpdatesOrFetch","fetchAroundUpdates","fetchAndSendUpdates","createObservableStoreMixin","idOrIds","self_1","state_1","ids_1","idSet_1","foundIds","itemUpdate","size","retrievedIdSet_1","missingItemIds","id_1","initialFetch","isFirstAdd","addedItems","deleted","debounce","fetchAroundUpdateDebounce","_setData","idx","callbackfn","createTimer","delay","timerId","timer","throttle","ran","throttleAfter","todoStore","__assign","s","n","createProjector_1","externalState_1","d_1","createTodoDetails_1","FactoryRegistry_1","createHome_1","widgetRegistry","createApp","registry","getChildrenNodes","widget","w","classes","tagName","createWidgetBase_1","createProjectorMixin_1","createProjector","isWNode","getFromRegistry","factoryLabel","dNodeToVNode","dNode","internalState","widgetInternalStateMap","initializedFactoryMap","invalidate","childrenMapKey","cachedChild","historicChildrenMap","setProperties","currentChildrenMap","errorMsg","__render__","render","manageDetachedChildren","formatTagNameAndClasses","createStateful_1","shallowPropertyComparisonMixin_1","createWidget","getNode","tag","getNodeAttributes","overrides","props","nodeAttributes","newProps","dirty","changedPropertyKeys","diffProperties","previousProperties","newProperties","onPropertiesChanged","setState","baseIdProp","data-widget-id","styles","widgetClasses","cachedVNode","factoryRegistry","evt","stateChangedEventType","createStateful","oldState","eventObject","propertiesOrChildren","maquette_1","h","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","createDom","updateDom","NAMESPACE_W3","NAMESPACE_SVG","NAMESPACE_XLINK","emptyArray","same","vnode1","vnode2","vnodeSelector","toTextVNode","domNode","appendChildren","parentSelector","insertions","main","missingTransition","DEFAULT_PROJECTION_OPTIONS","namespace","eventHandlerInterceptor","styleApplyer","styleName","style","transitions","enter","exit","applyDefaultProjectionOptions","projectorOptions","checkStyleValue","styleValue","projectionOptions","propNames","propCount","propName","propValue","token","classList","classNames","classNameCount","j","styleNames","styleCount","lastIndexOf","oldPropValue","setAttributeNS","updateProperties","propertiesUpdated","previousValue","previousOn","newStyleValue","oldStyleValue","findIndexOfChild","sameAs","nodeAdded","vNode","enterAnimation","nodeToRemove","exitAnimation","pointerEvents","removeDomNode","parentNode","checkDistinguishable","childNodes","indexToCheck","parentVNode","operation","childNode","updateChildren","vnode","oldChildren","newChildren","oldChildrenLength","newChildrenLength","newIndex","textUpdated","oldChild","newChild","findOldIndex","addChildren","initPropertiesAndChildren","textContent","afterCreate","insertBefore","createTextNode","charAt","createElementNS","updated","newVNode","replaceChild","firstChild","afterUpdate","updateAnimation","createProjection","updatedVnode","selector","childIndex","argsLength","onlyChild","dom","beforeNode","merge","createCache","cachedInputs","cachedOutcome","inputs","calculation","createMapping","getSourceKey","createResult","updateResult","newSources","newKeys","oldTargets","sourceKey","searchIndex","projector","propertyName","eventHandler","scheduleRender","scheduled","renderCompleted","stopped","projections","renderFunctions","doRender","renderNow","stop","cancelAnimationFrame","renderMaquetteFunction","detach","FactoryRegistry","registryItem","isObject","shallowCompare","shallowPropertyComparisonMixin","previousValue_1","projectorData","projectorDataMap","ProjectorState","Attached","attach","attachPromise","attachHandle","Detached","AttachType","Append","Merge","Replace","createProjectorMixin","projectorState","body","cssTransitions","maquetteProjectorOptions","replaceState","internalStateMap","externalStateFactory","err","createFocusableTextInput_1","createCheckboxInput_1","todoStoreActions_1","createFormattedDate_1","createFocusableTextArea","completedHandlers","textUpdateHandlers","closeHandlers","createTodoDetails","label","createdOn","onclick","focused","onInput","date","checked","onChange","closeLink","updateTodo","href","createFormFieldMixin_1","createFocusableTextInput","onBlur","onKeyUp","focus","activeElement","blur","onkeyup","onblur","oninput","placeholder","innerHTML","valueReplacer","RegExp","valueReviver","regExpStr","regExp","flags","valueToString","stringToValue","str","createCancelableEvent_1","createFormMixin","event_1","defaultPrevented","disabled","createCancelableEvent","preventDefault","createCheckboxInput","onchange","createFilter_1","addTodo","editing","deleteTodo","deleteCompleted","equalTo","toggleAll","isBooleanOp","isFilter","filterOrFunction","createFilterOrReturnOp","descriptorOrOp","createComparator","filterType","createFilter","filterDescriptors","serializer","filters","descriptorChainMember","createFilterHelper","serializeFilter","comparatorFilterHelper","needsOperator","newFilters","applyFilterChain","filterChain","filterSerializer","and","newFilter","or","lessThan","lessThanOrEqualTo","greaterThan","greaterThanOrEqualTo","matches","in","contains","deepEqualTo","notEqualTo","notDeepEqualTo","custom","queryType","incremental","ordFilterSections","startOfSlice","chainMember","filterOrAnd","operator","operatorString","propertyOrItem","propertyValue","createFormattedDate","hours","getHours","minutes","getMinutes","suffix","getMonth","getDate","getFullYear","userActions_1","createTodoFooter_1","createTitle_1","createMainSection_1","createHome","newTodoOptions","todoInput","toggleEditing","which","todoEdit","todoListState","todoEditInput","todoSave","todoRemove","todoToggleComplete","todoToggleAll","clearCompleted","updateSearch","searchQuery","createButton_1","createTodoFilter_1","createViewChooser_1","createTodoFooter","countLabel","class","onClick","createButton","createFilterItems","filterItem","toUpperCase","createTodoFilter","createViewChooser","cards","createTitle","searchHandler","createTodoItemList_1","createSearchInput_1","createMainSection","checkBoxOptions","filterName","applySearch","createTodoListItem_1","createTodoCardItem_1","createTodoItemList","card-list","empty","createLabel","onDoubleClick","onKeyPress","ondblclick","onkeypress","aria-describedby","tabindex","createTodoListItem","card","inputOptions","createTodoCardItem","createSearchInput"],"mappings":"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","file":"src/main.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\tmodule.exports = __webpack_require__(4);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 2 */,\n/* 3 */,\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar routes_1 = __webpack_require__(5);\n\tvar todoStore_1 = __webpack_require__(57);\n\tvar widgetStore_1 = __webpack_require__(42);\n\tvar createApp_1 = __webpack_require__(58);\n\tvar root = document.getElementsByTagName('my-app')[0];\n\tvar app = createApp_1.default({\n\t    root: root,\n\t    properties: {\n\t        id: 'todo-app',\n\t        externalState: widgetStore_1.default\n\t    }\n\t});\n\tapp.append()\n\t    .then(function () { return todoStore_1.bindActions(); })\n\t    .then(function () { return routes_1.default.start(); });\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createRoute_1 = __webpack_require__(6);\n\tvar createRouter_1 = __webpack_require__(26);\n\tvar createHashHistory_1 = __webpack_require__(40);\n\tvar widgetStoreActions_1 = __webpack_require__(41);\n\texports.mainRoute = createRoute_1.default({\n\t    path: '/{filter}?{view}',\n\t    params: function (_a, searchParams) {\n\t        var filter = _a[0];\n\t        var activeFilter;\n\t        var activeView;\n\t        var view = searchParams.get('view');\n\t        switch (filter) {\n\t            case 'active':\n\t            case 'all':\n\t            case 'completed':\n\t                activeFilter = filter;\n\t                break;\n\t            default:\n\t                activeFilter = 'all';\n\t        }\n\t        switch (view) {\n\t            case 'cards':\n\t            case 'list':\n\t                activeView = view;\n\t                break;\n\t            default:\n\t                activeView = 'list';\n\t        }\n\t        return {\n\t            filter: activeFilter,\n\t            view: activeView\n\t        };\n\t    },\n\t    exec: function (request) {\n\t        var _a = request.params, filter = _a.filter, _b = _a.view, view = _b === void 0 ? 'list' : _b;\n\t        widgetStoreActions_1.setHierarchy([['main', {}]]);\n\t        return widgetStoreActions_1.filterAndView(filter, view);\n\t    }\n\t});\n\texports.todoViewRoute = createRoute_1.default({\n\t    path: '/todos/{todoId}',\n\t    exec: function (request) {\n\t        var todoId = request.params.todoId;\n\t        return widgetStoreActions_1.showTodoDetails(todoId);\n\t    }\n\t});\n\tvar router = createRouter_1.default({\n\t    history: createHashHistory_1.default(), fallback: function () {\n\t        widgetStoreActions_1.setHierarchy([['main', {}]]);\n\t        return widgetStoreActions_1.filterAndView('all', 'list');\n\t    }\n\t});\n\texports.mainRoute.append(exports.todoViewRoute);\n\trouter.append(exports.mainRoute);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = router;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(7);\n\tvar UrlSearchParams_1 = __webpack_require__(25);\n\tvar WeakMap_1 = __webpack_require__(22);\n\tvar createRouter_1 = __webpack_require__(26);\n\tvar path_1 = __webpack_require__(39);\n\tvar privateStateMap = new WeakMap_1.default();\n\t// Store parent relationships in a separate map, since it's the parent that adds entries to this map. Parents shouldn't\n\t// change the private state of their children.\n\tvar parentMap = new WeakMap_1.default();\n\tvar noop = function () { };\n\tfunction computeDefaultParams(parameters, searchParameters, fromPathname, searchParams) {\n\t    var params = {};\n\t    parameters.forEach(function (name, index) {\n\t        params[name] = fromPathname[index];\n\t    });\n\t    searchParameters.forEach(function (name) {\n\t        var value = searchParams.get(name);\n\t        if (value !== undefined) {\n\t            params[name] = value;\n\t        }\n\t    });\n\t    return params;\n\t}\n\tvar createRoute = compose_1.default({\n\t    get parent() {\n\t        return parentMap.get(this);\n\t    },\n\t    get path() {\n\t        return privateStateMap.get(this).path;\n\t    },\n\t    append: function (add) {\n\t        var _this = this;\n\t        var routes = privateStateMap.get(this).routes;\n\t        var append = function (route) {\n\t            if (createRouter_1.hasBeenAppended(route)) {\n\t                throw new Error('Cannot append route that has already been appended');\n\t            }\n\t            routes.push(route);\n\t            parentMap.set(route, _this);\n\t        };\n\t        if (Array.isArray(add)) {\n\t            for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {\n\t                var route = add_1[_i];\n\t                append(route);\n\t            }\n\t        }\n\t        else {\n\t            append(add);\n\t        }\n\t    },\n\t    link: function (params) {\n\t        return createRouter_1.findRouter(this).link(this, params);\n\t    },\n\t    match: function (segments, hasTrailingSlash, searchParams) {\n\t        var _a = privateStateMap.get(this), computeParams = _a.computeParams, path = _a.path, trailingSlashMustMatch = _a.trailingSlashMustMatch;\n\t        var result = path_1.match(path, segments);\n\t        if (result === null) {\n\t            return null;\n\t        }\n\t        if (!result.hasRemaining && trailingSlashMustMatch && path.trailingSlash !== hasTrailingSlash) {\n\t            return null;\n\t        }\n\t        // Only extract the search params defined in the route's path.\n\t        var knownSearchParams = path.searchParameters.reduce(function (list, name) {\n\t            var value = searchParams.getAll(name);\n\t            if (value !== undefined) {\n\t                list[name] = value;\n\t            }\n\t            return list;\n\t        }, {});\n\t        var params = computeParams(result.values, new UrlSearchParams_1.default(knownSearchParams));\n\t        if (params === null) {\n\t            return null;\n\t        }\n\t        return {\n\t            hasRemaining: result.hasRemaining,\n\t            offset: result.offset,\n\t            params: params,\n\t            rawPathValues: result.values,\n\t            rawSearchParams: knownSearchParams\n\t        };\n\t    },\n\t    select: function (context, segments, hasTrailingSlash, searchParams) {\n\t        var _a = privateStateMap.get(this), exec = _a.exec, index = _a.index, fallback = _a.fallback, guard = _a.guard, path = _a.path, routes = _a.routes;\n\t        var matchResult = this.match(segments, hasTrailingSlash, searchParams);\n\t        // Return early if possible.\n\t        if (!matchResult || matchResult.hasRemaining && routes.length === 0 && !fallback) {\n\t            return [];\n\t        }\n\t        var params = matchResult.params;\n\t        if (guard) {\n\t            var guardResult = guard({ context: context, params: params });\n\t            if (typeof guardResult === 'string') {\n\t                return guardResult;\n\t            }\n\t            if (!guardResult) {\n\t                return [];\n\t            }\n\t        }\n\t        var handler = exec;\n\t        var redirect;\n\t        var remainingSelection;\n\t        var selected = false;\n\t        if (matchResult.hasRemaining) {\n\t            // Match the remaining segments. Return a hierarchy if nested routes were selected.\n\t            var remainingSegments_1 = segments.slice(matchResult.offset);\n\t            selected = routes.some(function (nested) {\n\t                var nestedResult = nested.select(context, remainingSegments_1, hasTrailingSlash, searchParams);\n\t                if (typeof nestedResult === 'string') {\n\t                    redirect = nestedResult;\n\t                    return true;\n\t                }\n\t                if (nestedResult.length > 0) {\n\t                    remainingSelection = nestedResult;\n\t                    return true;\n\t                }\n\t                return false;\n\t            });\n\t            // No remaining segments matched, only select this route if a fallback handler was specified.\n\t            if (!selected && fallback) {\n\t                selected = true;\n\t                handler = fallback;\n\t            }\n\t        }\n\t        else {\n\t            selected = true;\n\t            if (index) {\n\t                handler = index;\n\t            }\n\t        }\n\t        if (!selected) {\n\t            return [];\n\t        }\n\t        if (redirect !== undefined) {\n\t            return redirect;\n\t        }\n\t        var rawPathValues = matchResult.rawPathValues, rawSearchParams = matchResult.rawSearchParams;\n\t        var selection = {\n\t            // Use a noop handler if exec was not provided. Something needs to be returned otherwise the router may\n\t            // think no routes were selected.\n\t            handler: handler || noop,\n\t            path: path,\n\t            params: params,\n\t            rawPathValues: rawPathValues,\n\t            rawSearchParams: rawSearchParams,\n\t            route: this\n\t        };\n\t        return remainingSelection ? [selection].concat(remainingSelection) : [selection];\n\t    }\n\t}, function (instance, _a) {\n\t    var _b = _a === void 0 ? {} : _a, exec = _b.exec, fallback = _b.fallback, guard = _b.guard, index = _b.index, computeParams = _b.params, path = _b.path, _c = _b.trailingSlashMustMatch, trailingSlashMustMatch = _c === void 0 ? true : _c;\n\t    if (path && /#/.test(path)) {\n\t        throw new TypeError('Path must not contain \\'#\\'');\n\t    }\n\t    var deconstructedPath = path_1.deconstruct(path || '/');\n\t    var parameters = deconstructedPath.parameters, searchParameters = deconstructedPath.searchParameters;\n\t    if (computeParams) {\n\t        if (parameters.length === 0 && searchParameters.length === 0) {\n\t            throw new TypeError('Can\\'t specify params() if path doesn\\'t contain any');\n\t        }\n\t    }\n\t    else {\n\t        computeParams = function (fromPathname, searchParams) {\n\t            return computeDefaultParams(parameters, searchParameters, fromPathname, searchParams);\n\t        };\n\t    }\n\t    privateStateMap.set(instance, {\n\t        computeParams: computeParams,\n\t        exec: exec,\n\t        fallback: fallback,\n\t        guard: guard,\n\t        index: index,\n\t        path: deconstructedPath,\n\t        routes: [],\n\t        trailingSlashMustMatch: trailingSlashMustMatch\n\t    });\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createRoute;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar instrument_1 = __webpack_require__(8);\n\tvar lang_1 = __webpack_require__(15);\n\tvar array_1 = __webpack_require__(16);\n\tvar WeakMap_1 = __webpack_require__(22);\n\tvar Symbol_1 = __webpack_require__(20);\n\tvar aspect_1 = __webpack_require__(24);\n\t/**\n\t * The default factory label if no label can be derived during the factory creation process\n\t */\n\tvar DEFAULT_FACTORY_LABEL = 'Compose';\n\t/* References to support minification */\n\tvar defineProperty = Object.defineProperty;\n\tvar isArray = Array.isArray;\n\tvar objectCreate = Object.create;\n\tvar objectKeys = Object.keys;\n\t/**\n\t * A weakmap that stores all the private data for a factory\n\t */\n\tvar privateFactoryData = new WeakMap_1.default();\n\t/**\n\t * An internal function which stubs out a method which, when called at runtime, throws.\n\t *\n\t * @param method The name of \"abstract\" method being called\n\t */\n\tfunction missingMethod(method) {\n\t    return function throwOnMissingMethod() {\n\t        throw new TypeError(\"Advice being applied to missing method named: \" + method);\n\t    };\n\t}\n\t/**\n\t * Internal function which can label a factory with a name and also sets\n\t * the `toString()` method on the prototype to return the approriate\n\t * name for instances.\n\t *\n\t * @param fn The name of the factory to label\n\t * @param value The name to supply for the label\n\t */\n\tfunction assignFactoryName(factory, value) {\n\t    if (typeof factory === 'function' && factory.prototype) {\n\t        assignFunctionName(factory, value);\n\t        defineProperty(factory.prototype, Symbol_1.default.toStringTag, {\n\t            get: function () {\n\t                return value;\n\t            },\n\t            configurable: true\n\t        });\n\t    }\n\t}\n\t/**\n\t * Internal function which can label a function with a name\n\t */\n\tfunction assignFunctionName(fn, value) {\n\t    var nameDescriptor = Object.getOwnPropertyDescriptor(fn, 'name');\n\t    if (typeof nameDescriptor === 'undefined' || nameDescriptor.configurable) {\n\t        defineProperty(fn, 'name', {\n\t            value: value,\n\t            writable: true,\n\t            configurable: true\n\t        });\n\t    }\n\t}\n\t/**\n\t * A helper function that copies own properties and their descriptors\n\t * from one or more sources to a target object. Includes non-enumerable properties\n\t *\n\t * @param overwrite If `true` properties, like arrays, will not be merged, instead overwritten\n\t * @param target The target that properties should be copied onto\n\t * @param sources The rest of the parameters treated as sources to apply\n\t */\n\tfunction assignProperties(overwrite, target) {\n\t    var sources = [];\n\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t        sources[_i - 2] = arguments[_i];\n\t    }\n\t    sources.forEach(function (source) {\n\t        if (!source) {\n\t            return;\n\t        }\n\t        Object.defineProperties(target, Object.getOwnPropertyNames(source).reduce(function (descriptors, key) {\n\t            if (key !== 'constructor') {\n\t                var sourceDescriptor = Object.getOwnPropertyDescriptor(source, key);\n\t                var sourceValue = sourceDescriptor && sourceDescriptor.value;\n\t                var targetDescriptor = Object.getOwnPropertyDescriptor(target, key);\n\t                var targetValue = targetDescriptor && targetDescriptor.value;\n\t                /* Special handling to merge array proprties */\n\t                if (!overwrite && isArray(sourceValue) && isArray(targetValue)) {\n\t                    sourceDescriptor.value = sourceValue.reduce(function (value, current) {\n\t                        if (!array_1.includes(target[key], current)) {\n\t                            value.push(current);\n\t                        }\n\t                        return value;\n\t                    }, array_1.from(targetValue));\n\t                }\n\t                descriptors[key] = sourceDescriptor;\n\t            }\n\t            return descriptors;\n\t        }, objectCreate(null)));\n\t    });\n\t    return target;\n\t}\n\t/**\n\t * A helper funtion to return a function that is rebased to infer that the\n\t * first argument of the passed function will be the `this` when the function\n\t * is executed.\n\t *\n\t * @param  fn The function to be rebased\n\t * @return    The rebased function\n\t */\n\tfunction rebase(fn) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return fn.apply(this, [this].concat(args));\n\t    };\n\t}\n\t/**\n\t * For a given factory, return the names of the initialization functions that will be\n\t * invoked upon construction.\n\t *\n\t * @param factory The factory that the array of function names should be returned for\n\t */\n\tfunction getInitFunctionNames(factory) {\n\t    var initFns = privateFactoryData.get(factory).initFns;\n\t    if (initFns) {\n\t        return initFns.map(function (fn) { return fn.name; });\n\t    }\n\t}\n\texports.getInitFunctionNames = getInitFunctionNames;\n\t/* The rebased functions we need to decorate compose constructors with */\n\t/**\n\t * Perform an extension of a class\n\t *\n\t * @deprecated\n\t */\n\tvar doExtend = rebase(extend);\n\t/**\n\t * Perform a mixin of a class\n\t */\n\tvar doMixin = rebase(mixin);\n\t/**\n\t * Perform a override of a class\n\t */\n\tvar doOverride = rebase(override);\n\t/**\n\t * Perform an overlay of a class\n\t */\n\tvar doOverlay = rebase(overlay);\n\t/**\n\t * Apply aspect advice to a class\n\t */\n\tvar doAspect = rebase(aspect);\n\t/**\n\t * Add static method/properties to a class\n\t */\n\tvar doStatic = rebase(_static);\n\t/**\n\t * Take a mixin and return a factory descriptor for the mixin\n\t *\n\t * @param mixin The factory to return the descriptor for\n\t * @template T The outer type of the descriptor\n\t * @template O The outer factory options of the descriptor\n\t * @template U The inner type of the descriptor\n\t * @template P The inner factory options of the descriptor\n\t */\n\tfunction factoryDescriptor(mixin) {\n\t    return {\n\t        mixin: mixin,\n\t        className: mixin.name\n\t    };\n\t}\n\t/**\n\t * Generate a factory descriptor for a class\n\t */\n\tvar doFactoryDescriptor = rebase(factoryDescriptor);\n\t/**\n\t * A set of functions that are used to decorate the compose factories\n\t */\n\tvar staticMethods = {\n\t    extend: doExtend,\n\t    mixin: doMixin,\n\t    override: doOverride,\n\t    overlay: doOverlay,\n\t    from: doFrom,\n\t    before: doBefore,\n\t    after: doAfter,\n\t    around: doAround,\n\t    aspect: doAspect,\n\t    factoryDescriptor: doFactoryDescriptor,\n\t    static: doStatic\n\t};\n\t/**\n\t * Internal function that merges (or creates) an advice map\n\t *\n\t * @param sources The advice maps to be merged into a single one\n\t */\n\tfunction assignAdviceMap() {\n\t    var sources = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        sources[_i] = arguments[_i];\n\t    }\n\t    var result = {};\n\t    sources.forEach(function (source) {\n\t        if (source) {\n\t            for (var method in source) {\n\t                result[method] = result[method] ? result[method].concat(source[method]) : source[method].slice();\n\t            }\n\t        }\n\t    });\n\t    return result;\n\t}\n\t/**\n\t * An internal function that takes a set of create widget options and returns a set of private factory data\n\t *\n\t * @param options The set of factory options to use in creating the private factory data\n\t */\n\tfunction createPrivateFactoryData(_a) {\n\t    var optionsAdvice = _a.advice, factories = _a.factories, initFunction = _a.initFunction, overwrite = _a.overwrite, proto = _a.proto, staticProperties = _a.staticProperties;\n\t    var factoryData = (factories || []).reduce(function (factoryData, factory) {\n\t        var _a = privateFactoryData.get(factory), advice = _a.advice, base = _a.base, initFns = _a.initFns;\n\t        if (advice) {\n\t            factoryData.advice = assignAdviceMap(factoryData.advice, advice);\n\t        }\n\t        if (base) {\n\t            assignProperties(false, factoryData.base, base);\n\t        }\n\t        var optionsInitFns = factoryData.initFns;\n\t        initFns.forEach(function (initFn) {\n\t            if (!array_1.includes(optionsInitFns, initFn)) {\n\t                optionsInitFns.push(initFn);\n\t            }\n\t        });\n\t        return factoryData;\n\t    }, {\n\t        base: {},\n\t        initFns: [],\n\t        staticProperties: staticProperties ? lang_1.assign({}, staticProperties) : undefined\n\t    });\n\t    if (initFunction) {\n\t        factoryData.initFns.push(initFunction);\n\t    }\n\t    if (optionsAdvice) {\n\t        factoryData.advice = assignAdviceMap(factoryData.advice, optionsAdvice);\n\t    }\n\t    assignProperties(Boolean(overwrite), factoryData.base, proto);\n\t    return factoryData;\n\t}\n\tfunction createFactory(options) {\n\t    /**\n\t     * A compose factory\n\t     */\n\t    function factory() {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        if (this && this.constructor === factory) {\n\t            throw new SyntaxError('Factories cannot be called with \"new\".');\n\t        }\n\t        var instance = objectCreate(factory.prototype);\n\t        /* clone any arrays in the instance */\n\t        for (var key in instance) {\n\t            if (isArray(Object.getOwnPropertyDescriptor(factory.prototype, key).value)) {\n\t                instance[key] = array_1.from(instance[key]);\n\t            }\n\t        }\n\t        args.unshift(instance);\n\t        privateFactoryData.get(factory).initFns.forEach(function (fn) {\n\t            fn.apply(null, args);\n\t        });\n\t        return instance;\n\t    }\n\t    var factoryData = createPrivateFactoryData(options);\n\t    privateFactoryData.set(factory, factoryData);\n\t    var factoryPrototype = factory.prototype;\n\t    /* mixin base properties into the prototype */\n\t    assignProperties(false, factoryPrototype, factoryData.base);\n\t    /* apply any advice to the prototype */\n\t    if (factoryData.advice) {\n\t        var _loop_1 = function (method) {\n\t            factoryData.advice[method].forEach(function (_a) {\n\t                var aspect = _a[0], advice = _a[1];\n\t                var sourceMethod = factoryPrototype[method] || missingMethod(method);\n\t                switch (aspect) {\n\t                    case 'before':\n\t                        factoryPrototype[method] = aspect_1.before(sourceMethod, advice);\n\t                        break;\n\t                    case 'after':\n\t                        factoryPrototype[method] = aspect_1.after(sourceMethod, advice);\n\t                        break;\n\t                    case 'around':\n\t                        factoryPrototype[method] = aspect_1.around(sourceMethod, advice);\n\t                }\n\t            });\n\t        };\n\t        for (var method in factoryData.advice) {\n\t            _loop_1(method);\n\t        }\n\t    }\n\t    /* assign a constructor to the prototype */\n\t    factoryPrototype.constructor = factory;\n\t    /* assign static methods/properties */\n\t    lang_1.assign(factory, staticMethods, factoryData.staticProperties);\n\t    /* assign factory name */\n\t    var className = options.className ||\n\t        (options.factories && options.factories[0] && options.factories[0].name) ||\n\t        DEFAULT_FACTORY_LABEL;\n\t    assignFactoryName(factory, className);\n\t    /* freeze the factory, so it cannot be accidently modified */\n\t    Object.freeze(factory);\n\t    return factory;\n\t}\n\t/**\n\t * A custom type guard that determines if the value is a ComposeFactory\n\t *\n\t * @param   value The target to check\n\t * @returns       Return true if it is a ComposeFactory, otherwise false\n\t */\n\tfunction isComposeFactory(value) {\n\t    return Boolean(value && privateFactoryData.get(value));\n\t}\n\texports.isComposeFactory = isComposeFactory;\n\tfunction extend(base, className, extension) {\n\t    instrument_1.deprecated({ message: 'This function will be removed, use \"override\" instead.', name: 'extend' });\n\t    if (typeof className !== 'string') {\n\t        extension = className;\n\t        className = undefined;\n\t    }\n\t    return createFactory({\n\t        className: className,\n\t        proto: typeof extension === 'function' ? extension.prototype : extension,\n\t        factories: [base]\n\t    });\n\t}\n\tfunction override(baseFactory, className, properties) {\n\t    if (typeof className !== 'string') {\n\t        properties = className;\n\t        className = undefined;\n\t    }\n\t    if (typeof properties !== 'object') {\n\t        throw new TypeError('Argument \"properties\" must be an object.');\n\t    }\n\t    var base = privateFactoryData.get(baseFactory).base;\n\t    /* TODO: In TypeScript 2.1 we have merge types which can then be used to provide type checking at design time\n\t     * similiar to this */\n\t    Object.keys(properties).forEach(function (key) {\n\t        if (!(key in base)) {\n\t            throw new TypeError(\"Attempting to override missing property \\\"\" + key + \"\\\"\");\n\t        }\n\t    });\n\t    return createFactory({\n\t        className: className,\n\t        overwrite: true,\n\t        proto: properties,\n\t        factories: [baseFactory]\n\t    });\n\t}\n\t/**\n\t * Internal implementation of the overlay functionality, to allow a function to modify a\n\t * compose factory prototype\n\t *\n\t * @param base The target compose factory\n\t * @param overlayFunction The callback function that will modify the prototype of the factory\n\t */\n\tfunction overlay(base, overlayFunction) {\n\t    var factory = createFactory({\n\t        factories: [base]\n\t    });\n\t    overlayFunction(factory.prototype);\n\t    return factory;\n\t}\n\t/**\n\t * Internal function that converts `AspectAdvice` into `AdviceMap` which can then be used for\n\t * creating a factory\n\t *\n\t * @param aspectAdvice The aspect advice to convert into an advice map\n\t */\n\tfunction aspectAdviceToAdviceMap(aspectAdvice) {\n\t    if (!aspectAdvice) {\n\t        return;\n\t    }\n\t    var adviceMap = {};\n\t    var beforeAdvice = aspectAdvice.before;\n\t    var afterAdvice = aspectAdvice.after;\n\t    var aroundAdvice = aspectAdvice.around;\n\t    function mapAdvice(type, key, advice) {\n\t        var adviceTuple = [type, advice[key]];\n\t        if (adviceMap[key]) {\n\t            adviceMap[key].push(adviceTuple);\n\t        }\n\t        else {\n\t            adviceMap[key] = [adviceTuple];\n\t        }\n\t    }\n\t    if (beforeAdvice) {\n\t        objectKeys(beforeAdvice).forEach(function (key) {\n\t            /* TODO: Remove ! in 2.1 */\n\t            mapAdvice('before', key, beforeAdvice);\n\t        });\n\t    }\n\t    if (afterAdvice) {\n\t        objectKeys(afterAdvice).forEach(function (key) {\n\t            /* TODO: Remove ! in 2.1 */\n\t            mapAdvice('after', key, afterAdvice);\n\t        });\n\t    }\n\t    if (aroundAdvice) {\n\t        objectKeys(aroundAdvice).forEach(function (key) {\n\t            /* TODO: Remove ! in 2.1 */\n\t            mapAdvice('around', key, aroundAdvice);\n\t        });\n\t    }\n\t    return adviceMap;\n\t}\n\t/**\n\t * A custom type guard that determines if a value is ComposeMixinable\n\t *\n\t * @param value The value to guard for\n\t */\n\tfunction isComposeMixinable(value) {\n\t    return Boolean(value && 'factoryDescriptor' in value && typeof value.factoryDescriptor === 'function');\n\t}\n\t/**\n\t * The internal implementation of mixin in values into a compose factory\n\t *\n\t * @param base The base compose factory that is the target for being mixed in\n\t * @param toMixin The value to be mixed in\n\t */\n\tfunction mixin(base, toMixin) {\n\t    /* ensure we are dealing with a mixinDescriptor */\n\t    var mixinDescriptor = isComposeMixinable(toMixin) ? toMixin.factoryDescriptor() : toMixin;\n\t    /* destructure out most of the factory creation options */\n\t    var mixin = mixinDescriptor.mixin, initFunction = mixinDescriptor.initialize, aspectAdvice = mixinDescriptor.aspectAdvice, className = mixinDescriptor.className;\n\t    /* we will at least be using the base factory to create the new one */\n\t    var factories = [base];\n\t    var proto;\n\t    /* if mixin is a compose factory, we will pass it as a factory used to create the new factory */\n\t    if (isComposeFactory(mixin)) {\n\t        factories.push(mixin);\n\t    }\n\t    else {\n\t        /* of which, we can have a constructor function/class, or an object literal (or undefined) */\n\t        proto = typeof mixin === 'function' ? mixin.prototype : mixin;\n\t    }\n\t    /* convert the advice, if any, to the format used by createFactory */\n\t    var advice = aspectAdviceToAdviceMap(aspectAdvice);\n\t    /* label the initFn */\n\t    if (initFunction) {\n\t        assignFunctionName(initFunction, \"mixin\" + (className || (isComposeFactory(mixin) && mixin.name) || base.name));\n\t    }\n\t    /* return the newly created factory */\n\t    return createFactory({\n\t        advice: advice,\n\t        factories: factories,\n\t        initFunction: initFunction,\n\t        className: className,\n\t        proto: proto\n\t    });\n\t}\n\t/**\n\t * Internal implementation of extracting methods from another object\n\t *\n\t * @param base The target that the method should be extracted from\n\t * @param method The name of the method\n\t */\n\tfunction from(base, method) {\n\t    return base.prototype[method];\n\t}\n\t/**\n\t * Internal implementation to apply from when `this` represents the base\n\t *\n\t * @param base The target that the method should be extracted from\n\t * @param method The name of the method\n\t */\n\tfunction doFrom(base, method) {\n\t    return createFactory({\n\t        factories: [this],\n\t        proto: (_a = {},\n\t            _a[method] = base.prototype[method],\n\t            _a)\n\t    });\n\t    var _a;\n\t}\n\tfunction before() {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i] = arguments[_i];\n\t    }\n\t    var base;\n\t    var method;\n\t    var advice;\n\t    if (args.length >= 3) {\n\t        base = args[0], method = args[1], advice = args[2];\n\t        method = base.prototype[method];\n\t    }\n\t    else {\n\t        method = args[0], advice = args[1];\n\t    }\n\t    return aspect_1.before(method, advice);\n\t}\n\t/**\n\t * The internal implementation to apply before advice when `this` is scoped as the base factory\n\t *\n\t * @param method The name of the method that the advice should be applied to\n\t * @param advice The advice to apply\n\t */\n\tfunction doBefore(method, advice) {\n\t    return createFactory({\n\t        factories: [this],\n\t        advice: (_a = {},\n\t            _a[method] = [['before', advice]],\n\t            _a)\n\t    });\n\t    var _a;\n\t}\n\tfunction after() {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i] = arguments[_i];\n\t    }\n\t    var base;\n\t    var method;\n\t    var advice;\n\t    if (args.length >= 3) {\n\t        base = args[0], method = args[1], advice = args[2];\n\t        method = base.prototype[method];\n\t    }\n\t    else {\n\t        method = args[0], advice = args[1];\n\t    }\n\t    return aspect_1.after(method, advice);\n\t}\n\t/**\n\t * The internal implementation to apply after advice when `this` is scoped as the base factory\n\t *\n\t * @param method The name of the method that the advice should be applied to\n\t * @param advice The advice to apply\n\t */\n\tfunction doAfter(method, advice) {\n\t    return createFactory({\n\t        factories: [this],\n\t        advice: (_a = {},\n\t            _a[method] = [['after', advice]],\n\t            _a)\n\t    });\n\t    var _a;\n\t}\n\tfunction around() {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i] = arguments[_i];\n\t    }\n\t    var base;\n\t    var method;\n\t    var advice;\n\t    if (args.length >= 3) {\n\t        base = args[0], method = args[1], advice = args[2];\n\t        method = base.prototype[method];\n\t    }\n\t    else {\n\t        method = args[0], advice = args[1];\n\t    }\n\t    return aspect_1.around(method, advice);\n\t}\n\t/**\n\t * The internal implementation to apply around advice when `this` is scoped as the base factory\n\t *\n\t * @param method The name of the method that the advice should be applied to\n\t * @param advice The advice to apply\n\t */\n\tfunction doAround(method, advice) {\n\t    return createFactory({\n\t        factories: [this],\n\t        advice: (_a = {},\n\t            _a[method] = [['around', advice]],\n\t            _a)\n\t    });\n\t    var _a;\n\t}\n\t/**\n\t * The internal implementation of applying aspect advice to a factory\n\t *\n\t * @param base The base factory the advice should be applied to\n\t * @param advice The advice map to apply to the factory\n\t */\n\tfunction aspect(base, advice) {\n\t    return createFactory({\n\t        factories: [base],\n\t        advice: aspectAdviceToAdviceMap(advice)\n\t    });\n\t}\n\tfunction create(className, base, initFunction) {\n\t    /* disambugate arguments */\n\t    if (typeof className !== 'string') {\n\t        initFunction = base;\n\t        base = className;\n\t        className = undefined;\n\t    }\n\t    /* Label the initFunction */\n\t    if (initFunction && className) {\n\t        assignFunctionName(initFunction, \"init\" + className);\n\t    }\n\t    var factories;\n\t    var proto;\n\t    /* If base is a compose factory, set it as the factory array */\n\t    if (base && isComposeFactory(base)) {\n\t        factories = [base];\n\t    }\n\t    else {\n\t        proto = typeof base === 'function' ? base.prototype : base;\n\t    }\n\t    return createFactory({\n\t        className: className,\n\t        factories: factories,\n\t        initFunction: initFunction,\n\t        proto: proto\n\t    });\n\t}\n\t/**\n\t * Internal implementation of applying static properties to a compose factory\n\t *\n\t * @param factory The factory that the static properties should be applied to\n\t * @param staticProperties The properties to be applied to the factory\n\t */\n\tfunction _static(base, staticProperties) {\n\t    return createFactory({\n\t        factories: [base],\n\t        staticProperties: staticProperties\n\t    });\n\t}\n\t/**\n\t * A factory construction utility\n\t *\n\t * @param base An ES6 Class, ComposeFactory or Object literal to use as the base for the new factory\n\t * @param initFunction An optional initialization function for the factory\n\t */\n\tvar compose = create;\n\t/* Add static methods to compose */\n\tlang_1.assign(compose, {\n\t    create: create,\n\t    static: _static,\n\t    extend: extend,\n\t    mixin: mixin,\n\t    override: override,\n\t    overlay: overlay,\n\t    from: from,\n\t    before: before,\n\t    after: after,\n\t    around: around,\n\t    aspect: aspect\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = compose;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(9);\n\t/**\n\t * The default message to warn when no other is provided\n\t */\n\tvar DEFAULT_DEPRECATED_MESSAGE = 'This function will be removed in future versions.';\n\t/**\n\t * When set, globalWarn will be used instead of `console.warn`\n\t */\n\tvar globalWarn;\n\t/**\n\t * A function that will console warn that a function has been deprecated\n\t *\n\t * @param options Provide options which change the display of the message\n\t */\n\tfunction deprecated(_a) {\n\t    var _b = _a === void 0 ? {} : _a, message = _b.message, name = _b.name, warn = _b.warn, url = _b.url;\n\t    /* istanbul ignore else: testing with debug off is difficult */\n\t    if (has_1.default('debug')) {\n\t        message = message || DEFAULT_DEPRECATED_MESSAGE;\n\t        var warning = \"DEPRECATED: \" + (name ? name + ': ' : '') + message;\n\t        if (url) {\n\t            warning += \"\\n\\n    See \" + url + \" for more details.\\n\\n\";\n\t        }\n\t        if (warn) {\n\t            warn(warning);\n\t        }\n\t        else if (globalWarn) {\n\t            globalWarn(warning);\n\t        }\n\t        else {\n\t            console.warn(warning);\n\t        }\n\t    }\n\t}\n\texports.deprecated = deprecated;\n\t/**\n\t * A function that generates before advice that can be used to warn when an API has been deprecated\n\t *\n\t * @param options Provide options which change the display of the message\n\t */\n\tfunction deprecatedAdvice(options) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        deprecated(options);\n\t        return args;\n\t    };\n\t}\n\texports.deprecatedAdvice = deprecatedAdvice;\n\t/**\n\t * A method decorator that will console warn when a method if invoked that is deprecated\n\t *\n\t * @param options Provide options which change the display of the message\n\t */\n\tfunction deprecatedDecorator(options) {\n\t    return function (target, propertyKey, descriptor) {\n\t        if (has_1.default('debug')) {\n\t            var originalFn_1 = descriptor.value;\n\t            options = options || {};\n\t            /* IE 10/11 don't have the name property on functions */\n\t            options.name = target.constructor.name ? target.constructor.name + \"#\" + propertyKey : propertyKey;\n\t            descriptor.value = function () {\n\t                var args = [];\n\t                for (var _i = 0; _i < arguments.length; _i++) {\n\t                    args[_i] = arguments[_i];\n\t                }\n\t                deprecated(options);\n\t                return originalFn_1.apply(target, args);\n\t            };\n\t        }\n\t        return descriptor;\n\t    };\n\t}\n\texports.deprecatedDecorator = deprecatedDecorator;\n\t/**\n\t * A function that will set the warn function that will be used instead of `console.warn` when\n\t * logging warning messages\n\t *\n\t * @param warn The function (or `undefined`) to use instead of `console.warn`\n\t */\n\tfunction setWarn(warn) {\n\t    globalWarn = warn;\n\t}\n\texports.setWarn = setWarn;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\tvar global_1 = __webpack_require__(10);\n\tvar has_1 = __webpack_require__(11);\n\t__export(__webpack_require__(11));\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = has_1.default;\n\thas_1.add('object-assign', typeof global_1.default.Object.assign === 'function');\n\thas_1.add('raf', typeof requestAnimationFrame === 'function');\n\thas_1.add('arraybuffer', typeof global_1.default.ArrayBuffer !== 'undefined');\n\thas_1.add('formdata', typeof global_1.default.FormData !== 'undefined');\n\thas_1.add('xhr', typeof global_1.default.XMLHttpRequest !== 'undefined');\n\thas_1.add('xhr2', has_1.default('xhr') && 'responseType' in global_1.default.XMLHttpRequest.prototype);\n\thas_1.add('xhr2-blob', function () {\n\t    if (!has_1.default('xhr2')) {\n\t        return false;\n\t    }\n\t    var request = new XMLHttpRequest();\n\t    request.open('GET', '/', true);\n\t    request.responseType = 'blob';\n\t    request.abort();\n\t    return request.responseType === 'blob';\n\t});\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\tvar globalObject = (function () {\n\t    if (typeof window !== 'undefined') {\n\t        // Browsers\n\t        return window;\n\t    }\n\t    else if (typeof global !== 'undefined') {\n\t        // Node\n\t        return global;\n\t    }\n\t    else if (typeof self !== 'undefined') {\n\t        // Web workers\n\t        return self;\n\t    }\n\t    return {};\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = globalObject;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\tvar global_1 = __webpack_require__(12);\n\tvar has_1 = __webpack_require__(13);\n\tvar has_2 = __webpack_require__(13);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = has_1.default;\n\t__export(__webpack_require__(13));\n\t/* ECMAScript 6 and 7 Features */\n\t/*\n\t * Determine whether or not native Symbol exists. If it doesn't, we don't want to use\n\t * a few other native implementations like Map, WeakMap, Set.  Consider a polyfill that provides Symbol,\n\t * Map, etc in the global namespace. If the polyfill's Symbol is not compatible with our Symbol, neither\n\t * will be anything that uses their iterator symbol, like Map, Set, etc.\n\t */\n\t/* Symbol */\n\thas_2.add('es6-symbol', typeof global_1.default.Symbol !== 'undefined' && typeof Symbol() === 'symbol');\n\t/* Object */\n\thas_2.add('es6-object-assign', typeof Object.assign === 'function');\n\t/* Array */\n\thas_2.add('es6-array-from', 'from' in global_1.default.Array);\n\thas_2.add('es6-array-of', 'of' in global_1.default.Array);\n\thas_2.add('es6-array-fill', function () {\n\t    if ('fill' in global_1.default.Array.prototype) {\n\t        /* Some versions of Safari do not properly implement this */\n\t        return [1].fill(9, Number.POSITIVE_INFINITY)[0] === 1;\n\t    }\n\t    return false;\n\t});\n\thas_2.add('es6-array-findindex', 'findIndex' in global_1.default.Array.prototype);\n\thas_2.add('es6-array-find', 'find' in global_1.default.Array.prototype);\n\thas_2.add('es6-array-copywithin', 'copyWithin' in global_1.default.Array.prototype);\n\thas_2.add('es7-array-includes', 'includes' in global_1.default.Array.prototype);\n\t/* String */\n\thas_2.add('es6-string-raw', function () {\n\t    function getCallSite(callSite) {\n\t        var substitutions = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            substitutions[_i - 1] = arguments[_i];\n\t        }\n\t        return callSite;\n\t    }\n\t    if ('raw' in global_1.default.String) {\n\t        var b = 1;\n\t        var callSite = (_a = [\"a\\n\", \"\"], _a.raw = [\"a\\\\n\", \"\"], getCallSite(_a, b));\n\t        callSite.raw = ['a\\\\n'];\n\t        var supportsTrunc = global_1.default.String.raw(callSite, 42) === 'a:\\\\n';\n\t        return supportsTrunc;\n\t    }\n\t    return false;\n\t    var _a;\n\t});\n\thas_2.add('es6-string-fromcodepoint', 'fromCodePoint' in global_1.default.String);\n\thas_2.add('es6-string-codepointat', 'codePointAt' in global_1.default.String.prototype);\n\thas_2.add('es6-string-normalize', 'normalize' in global_1.default.String.prototype);\n\thas_2.add('es6-string-repeat', 'repeat' in global_1.default.String.prototype);\n\thas_2.add('es6-string-startswith', 'startsWith' in global_1.default.String.prototype);\n\thas_2.add('es6-string-endswith', 'endsWith' in global_1.default.String.prototype);\n\thas_2.add('es6-string-includes', 'includes' in global_1.default.String.prototype);\n\thas_2.add('es6-string-padstart', 'padStart' in global_1.default.String.prototype);\n\thas_2.add('es6-string-padend', 'padEnd' in global_1.default.String.prototype);\n\t/* Math */\n\thas_2.add('es6-math-acosh', typeof global_1.default.Math.acosh === 'function');\n\thas_2.add('es6-math-clz32', typeof global_1.default.Math.clz32 === 'function');\n\thas_2.add('es6-math-imul', function () {\n\t    if ('imul' in global_1.default.Math) {\n\t        /* Some versions of Safari on ios do not properly implement this */\n\t        return Math.imul(0xffffffff, 5) === -5;\n\t    }\n\t    return false;\n\t});\n\t/* Promise */\n\thas_2.add('es6-promise', typeof global_1.default.Promise !== 'undefined' && has_1.default('es6-symbol'));\n\t/* Observable */\n\thas_2.add('es-observable', typeof global_1.default.Observable !== 'undefined');\n\t/* Set */\n\thas_2.add('es6-set', function () {\n\t    if (typeof global_1.default.Set === 'function') {\n\t        /* IE11 and older versions of Safari are missing critical ES6 Set functionality */\n\t        var set = new global_1.default.Set([1]);\n\t        return set.has(1) && 'keys' in set && typeof set.keys === 'function' && has_1.default('es6-symbol');\n\t    }\n\t    return false;\n\t});\n\t/* Map */\n\thas_2.add('es6-map', function () {\n\t    if (typeof global_1.default.Map === 'function') {\n\t        /*\n\t        IE11 and older versions of Safari are missing critical ES6 Map functionality\n\t        We wrap this in a try/catch because sometimes the Map constructor exists, but does not\n\t        take arguments (iOS 8.4)\n\t         */\n\t        try {\n\t            var map = new global_1.default.Map([[0, 1]]);\n\t            return map.has(0) &&\n\t                typeof map.keys === 'function' && has_1.default('es6-symbol') &&\n\t                typeof map.values === 'function' &&\n\t                typeof map.entries === 'function';\n\t        }\n\t        catch (e) {\n\t            /* istanbul ignore next: not testing on iOS at the moment */\n\t            return false;\n\t        }\n\t    }\n\t    return false;\n\t});\n\t/* WeakMap */\n\thas_2.add('es6-weakmap', function () {\n\t    if (typeof global_1.default.WeakMap !== 'undefined') {\n\t        /* IE11 and older versions of Safari are missing critical ES6 Map functionality */\n\t        var key1 = {};\n\t        var key2 = {};\n\t        var map = new global_1.default.WeakMap([[key1, 1]]);\n\t        Object.freeze(key1);\n\t        return map.get(key1) === 1 && map.set(key2, 2) === map && has_1.default('es6-symbol');\n\t    }\n\t    return false;\n\t});\n\t/* Miscellaneous features */\n\thas_2.add('float32array', 'Float32Array' in global_1.default);\n\thas_2.add('setimmediate', typeof global_1.default.setImmediate !== 'undefined');\n\thas_2.add('postmessage', typeof postMessage === 'function');\n\thas_2.add('microtasks', function () { return has_1.default('es6-promise') || has_1.default('host-node') || has_1.default('dom-mutationobserver'); });\n\t/* DOM Features */\n\thas_2.add('dom-mutationobserver', function () { return has_1.default('host-browser') && Boolean(global_1.default.MutationObserver || global_1.default.WebKitMutationObserver); });\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\tvar globalObject = (typeof global === 'undefined') ? Function('return this')() : global;\n\t// global spec defines a reference to the global object called 'global'\n\t// https://github.com/tc39/proposal-global\n\tif (!('global' in globalObject)) {\n\t    globalObject.global = globalObject;\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = globalObject;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {\"use strict\";\n\tfunction isFeatureTestThenable(value) {\n\t    return value && value.then;\n\t}\n\t/**\n\t * A cache of results of feature tests\n\t */\n\texports.testCache = {};\n\t/**\n\t * A cache of the un-resolved feature tests\n\t */\n\texports.testFunctions = {};\n\t/**\n\t * A cache of unresolved thenables (probably promises)\n\t * @type {{}}\n\t */\n\tvar testThenables = {};\n\t/**\n\t * A reference to the global scope (`window` in a browser, `global` in NodeJS)\n\t */\n\tvar globalScope = (function () {\n\t    /* istanbul ignore else */\n\t    if (typeof window !== 'undefined') {\n\t        // Browsers\n\t        return window;\n\t    }\n\t    else if (typeof global !== 'undefined') {\n\t        // Node\n\t        return global;\n\t    }\n\t    else if (typeof self !== 'undefined') {\n\t        // Web workers\n\t        return self;\n\t    }\n\t    /* istanbul ignore next */\n\t    return {};\n\t})();\n\t/* Grab the staticFeatures if there are available */\n\tvar staticFeatures = (globalScope.DojoHasEnvironment || {}).staticFeatures;\n\t/* Cleaning up the DojoHasEnviornment */\n\tif ('DojoHasEnvironment' in globalScope) {\n\t    delete globalScope.DojoHasEnvironment;\n\t}\n\t/**\n\t * Custom type guard to narrow the `staticFeatures` to either a map or a function that\n\t * returns a map.\n\t *\n\t * @param value The value to guard for\n\t */\n\tfunction isStaticFeatureFunction(value) {\n\t    return typeof value === 'function';\n\t}\n\t/**\n\t * The cache of asserted features that were available in the global scope when the\n\t * module loaded\n\t */\n\tvar staticCache = staticFeatures\n\t    ? isStaticFeatureFunction(staticFeatures)\n\t        ? staticFeatures.apply(globalScope)\n\t        : staticFeatures\n\t    : {};/* Providing an empty cache, if none was in the environment\n\t\n\t/**\n\t* AMD plugin function.\n\t*\n\t* Conditional loads modules based on a has feature test value.\n\t*\n\t* @param resourceId Gives the resolved module id to load.\n\t* @param require The loader require function with respect to the module that contained the plugin resource in its\n\t*                dependency list.\n\t* @param load Callback to loader that consumes result of plugin demand.\n\t*/\n\tfunction load(resourceId, require, load, config) {\n\t    resourceId ? require([resourceId], load) : load();\n\t}\n\texports.load = load;\n\t/**\n\t * AMD plugin function.\n\t *\n\t * Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test\n\t * value(s).\n\t *\n\t * @param resourceId The id of the module\n\t * @param normalize Resolves a relative module id into an absolute module id\n\t */\n\tfunction normalize(resourceId, normalize) {\n\t    var tokens = resourceId.match(/[\\?:]|[^:\\?]*/g) || [];\n\t    var i = 0;\n\t    function get(skip) {\n\t        var term = tokens[i++];\n\t        if (term === ':') {\n\t            // empty string module name, resolves to null\n\t            return null;\n\t        }\n\t        else {\n\t            // postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n\t            if (tokens[i++] === '?') {\n\t                if (!skip && has(term)) {\n\t                    // matched the feature, get the first value from the options\n\t                    return get();\n\t                }\n\t                else {\n\t                    // did not match, get the second value, passing over the first\n\t                    get(true);\n\t                    return get(skip);\n\t                }\n\t            }\n\t            // a module\n\t            return term;\n\t        }\n\t    }\n\t    var id = get();\n\t    return id && normalize(id);\n\t}\n\texports.normalize = normalize;\n\t/**\n\t * Check if a feature has already been registered\n\t *\n\t * @param feature the name of the feature\n\t */\n\tfunction exists(feature) {\n\t    var normalizedFeature = feature.toLowerCase();\n\t    return Boolean(normalizedFeature in staticCache || normalizedFeature in exports.testCache || exports.testFunctions[normalizedFeature]);\n\t}\n\texports.exists = exists;\n\t/**\n\t * Register a new test for a named feature.\n\t *\n\t * @example\n\t * has.add('dom-addeventlistener', !!document.addEventListener);\n\t *\n\t * @example\n\t * has.add('touch-events', function () {\n\t *    return 'ontouchstart' in document\n\t * });\n\t *\n\t * @param feature the name of the feature\n\t * @param value the value reported of the feature, or a function that will be executed once on first test\n\t * @param overwrite if an existing value should be overwritten. Defaults to false.\n\t */\n\tfunction add(feature, value, overwrite) {\n\t    if (overwrite === void 0) { overwrite = false; }\n\t    var normalizedFeature = feature.toLowerCase();\n\t    if (exists(normalizedFeature) && !overwrite && !(normalizedFeature in staticCache)) {\n\t        throw new TypeError(\"Feature \\\"\" + feature + \"\\\" exists and overwrite not true.\");\n\t    }\n\t    if (typeof value === 'function') {\n\t        exports.testFunctions[normalizedFeature] = value;\n\t    }\n\t    else if (isFeatureTestThenable(value)) {\n\t        testThenables[feature] = value.then(function (resolvedValue) {\n\t            exports.testCache[feature] = resolvedValue;\n\t            delete testThenables[feature];\n\t        }, function () {\n\t            delete testThenables[feature];\n\t        });\n\t    }\n\t    else {\n\t        exports.testCache[normalizedFeature] = value;\n\t        delete exports.testFunctions[normalizedFeature];\n\t    }\n\t}\n\texports.add = add;\n\t/**\n\t * Return the current value of a named feature.\n\t *\n\t * @param feature The name (if a string) or identifier (if an integer) of the feature to test.\n\t */\n\tfunction has(feature) {\n\t    var result;\n\t    var normalizedFeature = feature.toLowerCase();\n\t    if (normalizedFeature in staticCache) {\n\t        result = staticCache[normalizedFeature];\n\t    }\n\t    else if (exports.testFunctions[normalizedFeature]) {\n\t        result = exports.testCache[normalizedFeature] = exports.testFunctions[normalizedFeature].call(null);\n\t        delete exports.testFunctions[normalizedFeature];\n\t    }\n\t    else if (normalizedFeature in exports.testCache) {\n\t        result = exports.testCache[normalizedFeature];\n\t    }\n\t    else if (feature in testThenables) {\n\t        return false;\n\t    }\n\t    else {\n\t        throw new TypeError(\"Attempt to detect unregistered has feature \\\"\" + feature + \"\\\"\");\n\t    }\n\t    return result;\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = has;\n\t/*\n\t * Out of the box feature tests\n\t */\n\t/* Environments */\n\t/* Used as a value to provide a debug only code path */\n\tadd('debug', true);\n\t/* Detects if the environment is \"browser like\" */\n\tadd('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');\n\t/* Detects if the environment appears to be NodeJS */\n\tadd('host-node', function () {\n\t    if (typeof process === 'object' && process.versions && process.versions.node) {\n\t        return process.versions.node;\n\t    }\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(14)))\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(9);\n\tvar slice = Array.prototype.slice;\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t/**\n\t * Type guard that ensures that the value can be coerced to Object\n\t * to weed out host objects that do not derive from Object.\n\t * This function is used to check if we want to deep copy an object or not.\n\t * Note: In ES6 it is possible to modify an object's Symbol.toStringTag property, which will\n\t * change the value returned by `toString`. This is a rare edge case that is difficult to handle,\n\t * so it is not handled here.\n\t * @param  value The value to check\n\t * @return       If the value is coercible into an Object\n\t */\n\tfunction shouldDeepCopyObject(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\tfunction copyArray(array, inherited) {\n\t    return array.map(function (item) {\n\t        if (Array.isArray(item)) {\n\t            return copyArray(item, inherited);\n\t        }\n\t        return !shouldDeepCopyObject(item) ?\n\t            item :\n\t            _mixin({\n\t                deep: true,\n\t                inherited: inherited,\n\t                sources: [item],\n\t                target: {}\n\t            });\n\t    });\n\t}\n\tfunction _mixin(kwArgs) {\n\t    var deep = kwArgs.deep;\n\t    var inherited = kwArgs.inherited;\n\t    var target = kwArgs.target;\n\t    for (var _i = 0, _a = kwArgs.sources; _i < _a.length; _i++) {\n\t        var source = _a[_i];\n\t        if (source === null || source === undefined) {\n\t            continue;\n\t        }\n\t        for (var key in source) {\n\t            if (inherited || hasOwnProperty.call(source, key)) {\n\t                var value = source[key];\n\t                if (deep) {\n\t                    if (Array.isArray(value)) {\n\t                        value = copyArray(value, inherited);\n\t                    }\n\t                    else if (shouldDeepCopyObject(value)) {\n\t                        value = _mixin({\n\t                            deep: true,\n\t                            inherited: inherited,\n\t                            sources: [value],\n\t                            target: {}\n\t                        });\n\t                    }\n\t                }\n\t                target[key] = value;\n\t            }\n\t        }\n\t    }\n\t    return target;\n\t}\n\t/**\n\t * Copies the values of all enumerable own properties of one or more source objects to the target object.\n\t *\n\t * @param target The target object to receive values from source objects\n\t * @param sources Any number of objects whose enumerable own properties will be copied to the target object\n\t * @return The modified target object\n\t */\n\texports.assign = has_1.default('object-assign') ?\n\t    Object.assign :\n\t    function (target) {\n\t        var sources = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            sources[_i - 1] = arguments[_i];\n\t        }\n\t        return _mixin({\n\t            deep: false,\n\t            inherited: false,\n\t            sources: sources,\n\t            target: target\n\t        });\n\t    };\n\tfunction create(prototype) {\n\t    var mixins = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        mixins[_i - 1] = arguments[_i];\n\t    }\n\t    if (!mixins.length) {\n\t        throw new RangeError('lang.create requires at least one mixin object.');\n\t    }\n\t    var args = mixins.slice();\n\t    args.unshift(Object.create(prototype));\n\t    return exports.assign.apply(null, args);\n\t}\n\texports.create = create;\n\tfunction deepAssign(target) {\n\t    var sources = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        sources[_i - 1] = arguments[_i];\n\t    }\n\t    return _mixin({\n\t        deep: true,\n\t        inherited: false,\n\t        sources: sources,\n\t        target: target\n\t    });\n\t}\n\texports.deepAssign = deepAssign;\n\tfunction deepMixin(target) {\n\t    var sources = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        sources[_i - 1] = arguments[_i];\n\t    }\n\t    return _mixin({\n\t        deep: true,\n\t        inherited: true,\n\t        sources: sources,\n\t        target: target\n\t    });\n\t}\n\texports.deepMixin = deepMixin;\n\t/**\n\t * Creates a new object using the provided source's prototype as the prototype for the new object, and then\n\t * deep copies the provided source's values into the new target.\n\t *\n\t * @param source The object to duplicate\n\t * @return The new object\n\t */\n\tfunction duplicate(source) {\n\t    var target = Object.create(Object.getPrototypeOf(source));\n\t    return deepMixin(target, source);\n\t}\n\texports.duplicate = duplicate;\n\t/**\n\t * Determines whether two values are the same value.\n\t *\n\t * @param a First value to compare\n\t * @param b Second value to compare\n\t * @return true if the values are the same; false otherwise\n\t */\n\tfunction isIdentical(a, b) {\n\t    return a === b ||\n\t        /* both values are NaN */\n\t        (a !== a && b !== b);\n\t}\n\texports.isIdentical = isIdentical;\n\t/**\n\t * Returns a function that binds a method to the specified object at runtime. This is similar to\n\t * `Function.prototype.bind`, but instead of a function it takes the name of a method on an object.\n\t * As a result, the function returned by `lateBind` will always call the function currently assigned to\n\t * the specified property on the object as of the moment the function it returns is called.\n\t *\n\t * @param instance The context object\n\t * @param method The name of the method on the context object to bind to itself\n\t * @param suppliedArgs An optional array of values to prepend to the `instance[method]` arguments list\n\t * @return The bound function\n\t */\n\tfunction lateBind(instance, method) {\n\t    var suppliedArgs = [];\n\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t        suppliedArgs[_i - 2] = arguments[_i];\n\t    }\n\t    return suppliedArgs.length ?\n\t        function () {\n\t            var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\t            // TS7017\n\t            return instance[method].apply(instance, args);\n\t        } :\n\t        function () {\n\t            // TS7017\n\t            return instance[method].apply(instance, arguments);\n\t        };\n\t}\n\texports.lateBind = lateBind;\n\tfunction mixin(target) {\n\t    var sources = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        sources[_i - 1] = arguments[_i];\n\t    }\n\t    return _mixin({\n\t        deep: false,\n\t        inherited: true,\n\t        sources: sources,\n\t        target: target\n\t    });\n\t}\n\texports.mixin = mixin;\n\t/**\n\t * Returns a function which invokes the given function with the given arguments prepended to its argument list.\n\t * Like `Function.prototype.bind`, but does not alter execution context.\n\t *\n\t * @param targetFunction The function that needs to be bound\n\t * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list\n\t * @return The bound function\n\t */\n\tfunction partial(targetFunction) {\n\t    var suppliedArgs = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        suppliedArgs[_i - 1] = arguments[_i];\n\t    }\n\t    return function () {\n\t        var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\t        return targetFunction.apply(this, args);\n\t    };\n\t}\n\texports.partial = partial;\n\t/**\n\t * Returns an object with a destroy method that, when called, calls the passed-in destructor.\n\t * This is intended to provide a unified interface for creating \"remove\" / \"destroy\" handlers for\n\t * event listeners, timers, etc.\n\t *\n\t * @param destructor A function that will be called when the handle's `destroy` method is invoked\n\t * @return The handle object\n\t */\n\tfunction createHandle(destructor) {\n\t    return {\n\t        destroy: function () {\n\t            this.destroy = function () { };\n\t            destructor.call(this);\n\t        }\n\t    };\n\t}\n\texports.createHandle = createHandle;\n\t/**\n\t * Returns a single handle that can be used to destroy multiple handles simultaneously.\n\t *\n\t * @param handles An array of handles with `destroy` methods\n\t * @return The handle object\n\t */\n\tfunction createCompositeHandle() {\n\t    var handles = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        handles[_i] = arguments[_i];\n\t    }\n\t    return createHandle(function () {\n\t        for (var _i = 0, handles_1 = handles; _i < handles_1.length; _i++) {\n\t            var handle = handles_1[_i];\n\t            handle.destroy();\n\t        }\n\t    });\n\t}\n\texports.createCompositeHandle = createCompositeHandle;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(11);\n\tvar util_1 = __webpack_require__(17);\n\tvar iterator_1 = __webpack_require__(18);\n\tvar number_1 = __webpack_require__(21);\n\t/**\n\t * Ensures a non-negative, non-infinite, safe integer.\n\t *\n\t * @param length The number to validate\n\t * @return A proper length\n\t */\n\tfunction toLength(length) {\n\t    length = Number(length);\n\t    if (isNaN(length)) {\n\t        return 0;\n\t    }\n\t    if (isFinite(length)) {\n\t        length = Math.floor(length);\n\t    }\n\t    // Ensure a non-negative, real, safe integer\n\t    return Math.min(Math.max(length, 0), number_1.MAX_SAFE_INTEGER);\n\t}\n\t/**\n\t * From ES6 7.1.4 ToInteger()\n\t *\n\t * @param value A value to convert\n\t * @return An integer\n\t */\n\tfunction toInteger(value) {\n\t    value = Number(value);\n\t    if (isNaN(value)) {\n\t        return 0;\n\t    }\n\t    if (value === 0 || !isFinite(value)) {\n\t        return value;\n\t    }\n\t    return (value > 0 ? 1 : -1) * Math.floor(Math.abs(value));\n\t}\n\t/**\n\t * Normalizes an offset against a given length, wrapping it if negative.\n\t *\n\t * @param value The original offset\n\t * @param length The total length to normalize against\n\t * @return If negative, provide a distance from the end (length); otherwise provide a distance from 0\n\t */\n\tfunction normalizeOffset(value, length) {\n\t    return value < 0 ? Math.max(length + value, 0) : Math.min(value, length);\n\t}\n\t/**\n\t * A namespace that contains the polyfilled functionality that is then exported below, depending on if\n\t * the functionality is required or not.\n\t */\n\tvar Shim;\n\t(function (Shim) {\n\t    function from(arrayLike, mapFunction, thisArg) {\n\t        if (arrayLike == null) {\n\t            throw new TypeError('from: requires an array-like object');\n\t        }\n\t        if (mapFunction && thisArg) {\n\t            mapFunction = mapFunction.bind(thisArg);\n\t        }\n\t        /* tslint:disable-next-line:variable-name */\n\t        var Constructor = this;\n\t        var length = toLength(arrayLike.length);\n\t        // Support extension\n\t        var array = (typeof Constructor === 'function') ? Object(new Constructor(length)) : new Array(length);\n\t        if (!iterator_1.isArrayLike(arrayLike) && !iterator_1.isIterable(arrayLike)) {\n\t            return array;\n\t        }\n\t        var i = 0;\n\t        iterator_1.forOf(arrayLike, function (value) {\n\t            array[i] = mapFunction ? mapFunction(value, i) : value;\n\t            i++;\n\t        });\n\t        if (arrayLike.length !== undefined) {\n\t            array.length = length;\n\t        }\n\t        return array;\n\t    }\n\t    Shim.from = from;\n\t    function of() {\n\t        var items = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            items[_i] = arguments[_i];\n\t        }\n\t        return Array.prototype.slice.call(items);\n\t    }\n\t    Shim.of = of;\n\t    function copyWithin(target, offset, start, end) {\n\t        if (target == null) {\n\t            throw new TypeError('copyWithin: target must be an array-like object');\n\t        }\n\t        var length = toLength(target.length);\n\t        offset = normalizeOffset(toInteger(offset), length);\n\t        start = normalizeOffset(toInteger(start), length);\n\t        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n\t        var count = Math.min(end - start, length - offset);\n\t        var direction = 1;\n\t        if (offset > start && offset < (start + count)) {\n\t            direction = -1;\n\t            start += count - 1;\n\t            offset += count - 1;\n\t        }\n\t        while (count > 0) {\n\t            if (start in target) {\n\t                target[offset] = target[start];\n\t            }\n\t            else {\n\t                delete target[offset];\n\t            }\n\t            offset += direction;\n\t            start += direction;\n\t            count--;\n\t        }\n\t        return target;\n\t    }\n\t    Shim.copyWithin = copyWithin;\n\t    function fill(target, value, start, end) {\n\t        var length = toLength(target.length);\n\t        var i = normalizeOffset(toInteger(start), length);\n\t        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n\t        while (i < end) {\n\t            target[i++] = value;\n\t        }\n\t        return target;\n\t    }\n\t    Shim.fill = fill;\n\t    function find(target, callback, thisArg) {\n\t        var index = findIndex(target, callback, thisArg);\n\t        return index !== -1 ? target[index] : undefined;\n\t    }\n\t    Shim.find = find;\n\t    function findIndex(target, callback, thisArg) {\n\t        var length = toLength(target.length);\n\t        if (!callback) {\n\t            throw new TypeError('find: second argument must be a function');\n\t        }\n\t        if (thisArg) {\n\t            callback = callback.bind(thisArg);\n\t        }\n\t        for (var i = 0; i < length; i++) {\n\t            if (callback(target[i], i, target)) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t    Shim.findIndex = findIndex;\n\t    function includes(target, searchElement, fromIndex) {\n\t        if (fromIndex === void 0) { fromIndex = 0; }\n\t        var len = toLength(target.length);\n\t        for (var i = fromIndex; i < len; ++i) {\n\t            var currentElement = target[i];\n\t            if (searchElement === currentElement ||\n\t                (searchElement !== searchElement && currentElement !== currentElement)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t    Shim.includes = includes;\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\texports.from = has_1.default('es6-array-from')\n\t    ? Array.from\n\t    : Shim.from;\n\t/**\n\t * Creates a new array from the function parameters.\n\t *\n\t * @param arguments Any number of arguments for the array\n\t * @return An array from the given arguments\n\t */\n\texports.of = has_1.default('es6-array-of')\n\t    ? Array.of\n\t    : Shim.of;\n\t/* ES6 Array instance methods */\n\t/**\n\t * Copies data internally within an array or array-like object.\n\t *\n\t * @param target The target array-like object\n\t * @param offset The index to start copying values to; if negative, it counts backwards from length\n\t * @param start The first (inclusive) index to copy; if negative, it counts backwards from length\n\t * @param end The last (exclusive) index to copy; if negative, it counts backwards from length\n\t * @return The target\n\t */\n\texports.copyWithin = has_1.default('es6-array-copywithin')\n\t    ? util_1.wrapNative(Array.prototype.copyWithin)\n\t    : Shim.copyWithin;\n\t/**\n\t * Fills elements of an array-like object with the specified value.\n\t *\n\t * @param target The target to fill\n\t * @param value The value to fill each element of the target with\n\t * @param start The first index to fill\n\t * @param end The (exclusive) index at which to stop filling\n\t * @return The filled target\n\t */\n\texports.fill = has_1.default('es6-array-fill')\n\t    ? util_1.wrapNative(Array.prototype.fill)\n\t    : Shim.fill;\n\t/**\n\t * Finds and returns the first instance matching the callback or undefined if one is not found.\n\t *\n\t * @param target An array-like object\n\t * @param callback A function returning if the current value matches a criteria\n\t * @param [thisArg] The execution context for the find function\n\t * @return The first element matching the callback, or undefined if one does not exist\n\t */\n\texports.find = has_1.default('es6-array-find')\n\t    ? util_1.wrapNative(Array.prototype.find)\n\t    : Shim.find;\n\t/**\n\t * Performs a linear search and returns the first index whose value satisfies the passed callback,\n\t * or -1 if no values satisfy it.\n\t *\n\t * @param target An array-like object\n\t * @param callback A function returning true if the current value satisfies its criteria\n\t * @param [thisArg] The execution context for the find function\n\t * @return The first index whose value satisfies the passed callback, or -1 if no values satisfy it\n\t */\n\texports.findIndex = has_1.default('es6-array-findindex')\n\t    ? util_1.wrapNative(Array.prototype.findIndex)\n\t    : Shim.findIndex;\n\t/* ES7 Array instance methods */\n\t/**\n\t * Determines whether an array includes a given value\n\t *\n\t * @param target the target array-like object\n\t * @param searchElement the item to search for\n\t * @param fromIndex the starting index to search from\n\t * @return `true` if the array includes the element, otherwise `false`\n\t */\n\texports.includes = has_1.default('es7-array-includes')\n\t    ? util_1.wrapNative(Array.prototype.includes)\n\t    : Shim.includes;\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * Helper function to generate a value property descriptor\n\t *\n\t * @param value        The value the property descriptor should be set to\n\t * @param enumerable   If the property should be enumberable, defaults to false\n\t * @param writable     If the property should be writable, defaults to true\n\t * @param configurable If the property should be configurable, defaults to true\n\t * @return             The property descriptor object\n\t */\n\tfunction getValueDescriptor(value, enumerable, writable, configurable) {\n\t    if (enumerable === void 0) { enumerable = false; }\n\t    if (writable === void 0) { writable = true; }\n\t    if (configurable === void 0) { configurable = true; }\n\t    return {\n\t        value: value,\n\t        enumerable: enumerable,\n\t        writable: writable,\n\t        configurable: configurable\n\t    };\n\t}\n\texports.getValueDescriptor = getValueDescriptor;\n\t/**\n\t * A helper function which wraps a function where the first argument becomes the scope\n\t * of the call\n\t *\n\t * @param nativeFunction The source function to be wrapped\n\t */\n\tfunction wrapNative(nativeFunction) {\n\t    return function (target) {\n\t        var args = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            args[_i - 1] = arguments[_i];\n\t        }\n\t        return nativeFunction.apply(target, args);\n\t    };\n\t}\n\texports.wrapNative = wrapNative;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar string_1 = __webpack_require__(19);\n\t__webpack_require__(20);\n\tvar staticDone = { done: true, value: undefined };\n\t/**\n\t * A class that provides \"shims\" an iterator interface on array like\n\t * objects.\n\t */\n\tvar ShimIterator = (function () {\n\t    function ShimIterator(list) {\n\t        this._nextIndex = -1;\n\t        if (isIterable(list)) {\n\t            this._nativeIterator = list[Symbol.iterator]();\n\t        }\n\t        else {\n\t            this._list = list;\n\t        }\n\t    }\n\t    ;\n\t    /**\n\t     * Return the next iteration result for the Iterator\n\t     */\n\t    ShimIterator.prototype.next = function () {\n\t        if (this._nativeIterator) {\n\t            return this._nativeIterator.next();\n\t        }\n\t        if (!this._list) {\n\t            return staticDone;\n\t        }\n\t        if (++this._nextIndex < this._list.length) {\n\t            return {\n\t                done: false,\n\t                value: this._list[this._nextIndex]\n\t            };\n\t        }\n\t        return staticDone;\n\t    };\n\t    ;\n\t    ShimIterator.prototype[Symbol.iterator] = function () {\n\t        return this;\n\t    };\n\t    return ShimIterator;\n\t}());\n\texports.ShimIterator = ShimIterator;\n\t/**\n\t * A type guard for checking if something has an Iterable interface\n\t *\n\t * @param value The value to type guard against\n\t */\n\tfunction isIterable(value) {\n\t    return value && typeof value[Symbol.iterator] === 'function';\n\t}\n\texports.isIterable = isIterable;\n\t/**\n\t * A type guard for checking if something is ArrayLike\n\t *\n\t * @param value The value to type guard against\n\t */\n\tfunction isArrayLike(value) {\n\t    return value && typeof value.length === 'number';\n\t}\n\texports.isArrayLike = isArrayLike;\n\t/**\n\t * Returns the iterator for an object\n\t *\n\t * @param iterable The iterable object to return the iterator for\n\t */\n\tfunction get(iterable) {\n\t    if (isIterable(iterable)) {\n\t        return iterable[Symbol.iterator]();\n\t    }\n\t    else if (isArrayLike(iterable)) {\n\t        return new ShimIterator(iterable);\n\t    }\n\t}\n\texports.get = get;\n\t/**\n\t * Shims the functionality of `for ... of` blocks\n\t *\n\t * @param iterable The object the provides an interator interface\n\t * @param callback The callback which will be called for each item of the iterable\n\t * @param thisArg Optional scope to pass the callback\n\t */\n\tfunction forOf(iterable, callback, thisArg) {\n\t    var broken = false;\n\t    function doBreak() {\n\t        broken = true;\n\t    }\n\t    /* We need to handle iteration of double byte strings properly */\n\t    if (!isIterable(iterable) && typeof iterable === 'string') {\n\t        var l = iterable.length;\n\t        for (var i = 0; i < l; ++i) {\n\t            var char = iterable[i];\n\t            if ((i + 1) < l) {\n\t                var code = char.charCodeAt(0);\n\t                if ((code >= string_1.HIGH_SURROGATE_MIN) && (code <= string_1.HIGH_SURROGATE_MAX)) {\n\t                    char += iterable[++i];\n\t                }\n\t            }\n\t            callback.call(thisArg, char, iterable, doBreak);\n\t            if (broken) {\n\t                return;\n\t            }\n\t        }\n\t    }\n\t    else {\n\t        var iterator = get(iterable);\n\t        if (iterator) {\n\t            var result = iterator.next();\n\t            while (!result.done) {\n\t                callback.call(thisArg, result.value, iterable, doBreak);\n\t                if (broken) {\n\t                    return;\n\t                }\n\t                result = iterator.next();\n\t            }\n\t        }\n\t    }\n\t}\n\texports.forOf = forOf;\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(11);\n\tvar util_1 = __webpack_require__(17);\n\t/**\n\t * The minimum location of high surrogates\n\t */\n\texports.HIGH_SURROGATE_MIN = 0xD800;\n\t/**\n\t * The maximum location of high surrogates\n\t */\n\texports.HIGH_SURROGATE_MAX = 0xDBFF;\n\t/**\n\t * The minimum location of low surrogates\n\t */\n\texports.LOW_SURROGATE_MIN = 0xDC00;\n\t/**\n\t * The maximum location of low surrogates\n\t */\n\texports.LOW_SURROGATE_MAX = 0xDFFF;\n\tvar Shim;\n\t(function (Shim) {\n\t    /**\n\t     * Validates that text is defined, and normalizes position (based on the given default if the input is NaN).\n\t     * Used by startsWith, includes, and endsWith.\n\t     *\n\t     * @return Normalized position.\n\t     */\n\t    function normalizeSubstringArgs(name, text, search, position, isEnd) {\n\t        if (isEnd === void 0) { isEnd = false; }\n\t        if (text == null) {\n\t            throw new TypeError('string.' + name + ' requires a valid string to search against.');\n\t        }\n\t        var length = text.length;\n\t        position = position !== position ? (isEnd ? length : 0) : position;\n\t        return [text, String(search), Math.min(Math.max(position, 0), length)];\n\t    }\n\t    function raw(callSite) {\n\t        var substitutions = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            substitutions[_i - 1] = arguments[_i];\n\t        }\n\t        var rawStrings = callSite.raw;\n\t        var result = '';\n\t        var numSubstitutions = substitutions.length;\n\t        if (callSite == null || callSite.raw == null) {\n\t            throw new TypeError('string.raw requires a valid callSite object with a raw value');\n\t        }\n\t        for (var i = 0, length_1 = rawStrings.length; i < length_1; i++) {\n\t            result += rawStrings[i] + (i < numSubstitutions && i < length_1 - 1 ? substitutions[i] : '');\n\t        }\n\t        return result;\n\t    }\n\t    Shim.raw = raw;\n\t    function fromCodePoint() {\n\t        var codePoints = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            codePoints[_i] = arguments[_i];\n\t        }\n\t        // Adapted from https://github.com/mathiasbynens/String.fromCodePoint\n\t        var length = arguments.length;\n\t        if (!length) {\n\t            return '';\n\t        }\n\t        var fromCharCode = String.fromCharCode;\n\t        var MAX_SIZE = 0x4000;\n\t        var codeUnits = [];\n\t        var index = -1;\n\t        var result = '';\n\t        while (++index < length) {\n\t            var codePoint = Number(arguments[index]);\n\t            // Code points must be finite integers within the valid range\n\t            var isValid = isFinite(codePoint) && Math.floor(codePoint) === codePoint &&\n\t                codePoint >= 0 && codePoint <= 0x10FFFF;\n\t            if (!isValid) {\n\t                throw RangeError('string.fromCodePoint: Invalid code point ' + codePoint);\n\t            }\n\t            if (codePoint <= 0xFFFF) {\n\t                // BMP code point\n\t                codeUnits.push(codePoint);\n\t            }\n\t            else {\n\t                // Astral code point; split in surrogate halves\n\t                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t                codePoint -= 0x10000;\n\t                var highSurrogate = (codePoint >> 10) + exports.HIGH_SURROGATE_MIN;\n\t                var lowSurrogate = (codePoint % 0x400) + exports.LOW_SURROGATE_MIN;\n\t                codeUnits.push(highSurrogate, lowSurrogate);\n\t            }\n\t            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n\t                result += fromCharCode.apply(null, codeUnits);\n\t                codeUnits.length = 0;\n\t            }\n\t        }\n\t        return result;\n\t    }\n\t    Shim.fromCodePoint = fromCodePoint;\n\t    function codePointAt(text, position) {\n\t        if (position === void 0) { position = 0; }\n\t        // Adapted from https://github.com/mathiasbynens/String.prototype.codePointAt\n\t        if (text == null) {\n\t            throw new TypeError('string.codePointAt requries a valid string.');\n\t        }\n\t        var length = text.length;\n\t        if (position !== position) {\n\t            position = 0;\n\t        }\n\t        if (position < 0 || position >= length) {\n\t            return undefined;\n\t        }\n\t        // Get the first code unit\n\t        var first = text.charCodeAt(position);\n\t        if (first >= exports.HIGH_SURROGATE_MIN && first <= exports.HIGH_SURROGATE_MAX && length > position + 1) {\n\t            // Start of a surrogate pair (high surrogate and there is a next code unit); check for low surrogate\n\t            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t            var second = text.charCodeAt(position + 1);\n\t            if (second >= exports.LOW_SURROGATE_MIN && second <= exports.LOW_SURROGATE_MAX) {\n\t                return (first - exports.HIGH_SURROGATE_MIN) * 0x400 + second - exports.LOW_SURROGATE_MIN + 0x10000;\n\t            }\n\t        }\n\t        return first;\n\t    }\n\t    Shim.codePointAt = codePointAt;\n\t    /* TODO: Missing normalize */\n\t    function repeat(text, count) {\n\t        if (count === void 0) { count = 0; }\n\t        // Adapted from https://github.com/mathiasbynens/String.prototype.repeat\n\t        if (text == null) {\n\t            throw new TypeError('string.repeat requires a valid string.');\n\t        }\n\t        if (count !== count) {\n\t            count = 0;\n\t        }\n\t        if (count < 0 || count === Infinity) {\n\t            throw new RangeError('string.repeat requires a non-negative finite count.');\n\t        }\n\t        var result = '';\n\t        while (count) {\n\t            if (count % 2) {\n\t                result += text;\n\t            }\n\t            if (count > 1) {\n\t                text += text;\n\t            }\n\t            count >>= 1;\n\t        }\n\t        return result;\n\t    }\n\t    Shim.repeat = repeat;\n\t    function startsWith(text, search, position) {\n\t        if (position === void 0) { position = 0; }\n\t        search = String(search);\n\t        _a = normalizeSubstringArgs('startsWith', text, search, position), text = _a[0], search = _a[1], position = _a[2];\n\t        var end = position + search.length;\n\t        if (end > text.length) {\n\t            return false;\n\t        }\n\t        return text.slice(position, end) === search;\n\t        var _a;\n\t    }\n\t    Shim.startsWith = startsWith;\n\t    function endsWith(text, search, endPosition) {\n\t        if (endPosition == null) {\n\t            endPosition = text.length;\n\t        }\n\t        _a = normalizeSubstringArgs('endsWith', text, search, endPosition, true), text = _a[0], search = _a[1], endPosition = _a[2];\n\t        var start = endPosition - search.length;\n\t        if (start < 0) {\n\t            return false;\n\t        }\n\t        return text.slice(start, endPosition) === search;\n\t        var _a;\n\t    }\n\t    Shim.endsWith = endsWith;\n\t    function includes(text, search, position) {\n\t        if (position === void 0) { position = 0; }\n\t        _a = normalizeSubstringArgs('includes', text, search, position), text = _a[0], search = _a[1], position = _a[2];\n\t        return text.indexOf(search, position) !== -1;\n\t        var _a;\n\t    }\n\t    Shim.includes = includes;\n\t    function padEnd(text, maxLength, fillString) {\n\t        if (fillString === void 0) { fillString = ' '; }\n\t        if (text === null || text === undefined) {\n\t            throw new TypeError('string.repeat requires a valid string.');\n\t        }\n\t        if (maxLength === Infinity) {\n\t            throw new RangeError('string.padEnd requires a non-negative finite count.');\n\t        }\n\t        if (maxLength === null || maxLength === undefined || maxLength < 0) {\n\t            maxLength = 0;\n\t        }\n\t        var strText = String(text);\n\t        var padding = maxLength - strText.length;\n\t        if (padding > 0) {\n\t            strText += repeat(fillString, Math.floor(padding / fillString.length)) + fillString.slice(0, padding % fillString.length);\n\t        }\n\t        return strText;\n\t    }\n\t    Shim.padEnd = padEnd;\n\t    function padStart(text, maxLength, fillString) {\n\t        if (fillString === void 0) { fillString = ' '; }\n\t        if (text === null || text === undefined) {\n\t            throw new TypeError('string.repeat requires a valid string.');\n\t        }\n\t        if (maxLength === Infinity) {\n\t            throw new RangeError('string.padStart requires a non-negative finite count.');\n\t        }\n\t        if (maxLength === null || maxLength === undefined || maxLength < 0) {\n\t            maxLength = 0;\n\t        }\n\t        var strText = String(text);\n\t        var padding = maxLength - strText.length;\n\t        if (padding > 0) {\n\t            strText = repeat(fillString, Math.floor(padding / fillString.length)) + fillString.slice(0, padding % fillString.length) + strText;\n\t        }\n\t        return strText;\n\t    }\n\t    Shim.padStart = padStart;\n\t    /* TODO: Provide an iterator for a string to mimic [Symbol.iterator]? */\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\t/**\n\t * A tag function for template strings to get the template string's raw string form.\n\t *\n\t * @param callSite Call site object (or a template string in TypeScript, which will transpile to one)\n\t * @param substitutions Values to substitute within the template string (TypeScript will generate these automatically)\n\t * @return String containing the raw template string with variables substituted\n\t *\n\t * @example\n\t * // Within TypeScript; logs 'The answer is:\\\\n42'\n\t * let answer = 42;\n\t * console.log(string.raw`The answer is:\\n${answer}`);\n\t *\n\t * @example\n\t * // The same example as above, but directly specifying a JavaScript object and substitution\n\t * console.log(string.raw({ raw: [ 'The answer is:\\\\n', '' ] }, 42));\n\t */\n\texports.raw = has_1.default('es6-string-raw')\n\t    ? String.raw\n\t    : Shim.raw;\n\t/**\n\t * Returns the UTF-16 encoded code point value of a given position in a string.\n\t *\n\t * @param text The string containing the element whose code point is to be determined\n\t * @param position Position of an element within the string to retrieve the code point value from\n\t * @return A non-negative integer representing the UTF-16 encoded code point value\n\t */\n\texports.fromCodePoint = has_1.default('es6-string-fromcodepoint')\n\t    ? String.fromCodePoint\n\t    : Shim.fromCodePoint;\n\t/**\n\t * Returns the UTF-16 encoded code point value of a given position in a string.\n\t *\n\t * @param text The string containing the element whose code point is to be determined\n\t * @param position Position of an element within the string to retrieve the code point value from\n\t * @return A non-negative integer representing the UTF-16 encoded code point value\n\t */\n\texports.codePointAt = has_1.default('es6-string-codepointat')\n\t    ? util_1.wrapNative(String.prototype.codePointAt)\n\t    : Shim.codePointAt;\n\t/**\n\t * Returns a string containing the given string repeated the specified number of times.\n\t *\n\t * @param text The string to repeat\n\t * @param count The number of times to repeat the string\n\t * @return A string containing the input string repeated count times\n\t */\n\texports.repeat = has_1.default('es6-string-repeat')\n\t    ? util_1.wrapNative(String.prototype.repeat)\n\t    : Shim.repeat;\n\t/**\n\t * Determines whether a string begins with the given substring (optionally starting from a given index).\n\t *\n\t * @param text The string to look for the search string within\n\t * @param search The string to search for\n\t * @param position The index to begin searching at\n\t * @return Boolean indicating if the search string was found at the beginning of the given string\n\t */\n\texports.startsWith = has_1.default('es6-string-startswith')\n\t    ? util_1.wrapNative(String.prototype.startsWith)\n\t    : Shim.startsWith;\n\t/**\n\t * Determines whether a string ends with the given substring.\n\t *\n\t * @param text The string to look for the search string within\n\t * @param search The string to search for\n\t * @param endPosition The index searching should stop before (defaults to text.length)\n\t * @return Boolean indicating if the search string was found at the end of the given string\n\t */\n\texports.endsWith = has_1.default('es6-string-endswith')\n\t    ? util_1.wrapNative(String.prototype.endsWith)\n\t    : Shim.endsWith;\n\t/**\n\t * Determines whether a string includes the given substring (optionally starting from a given index).\n\t *\n\t * @param text The string to look for the search string within\n\t * @param search The string to search for\n\t * @param position The index to begin searching at\n\t * @return Boolean indicating if the search string was found within the given string\n\t */\n\texports.includes = has_1.default('es6-string-includes')\n\t    ? util_1.wrapNative(String.prototype.includes)\n\t    : Shim.includes;\n\t/**\n\t * Pads the beginning of a string with a fill string until the string is a certain length.\n\t *\n\t * @param text          The string to pad\n\t * @param maxLength     The desired length of the string\n\t * @param fillString    The string to be repeated (fully or partially) until text is the maximum length\n\t *\n\t * @return A string that is at least the maximum length specified, padded in the front if necessary.\n\t */\n\texports.padStart = has_1.default('es6-string-padstart')\n\t    ? util_1.wrapNative(String.prototype.padStart)\n\t    : Shim.padStart;\n\t/**\n\t * Pads the end of a string with a fill string until the string is a certain length.\n\t *\n\t * @param text          The string to pad\n\t * @param maxLength     The desired length of the string\n\t * @param fillString    The string to be repeated (fully or partially) until text is the maximum length\n\t *\n\t * @return A string that is at least the maximum length specified, padded at the end if necessary.\n\t */\n\texports.padEnd = has_1.default('es6-string-padend')\n\t    ? util_1.wrapNative(String.prototype.padEnd)\n\t    : Shim.padEnd;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(11);\n\tvar global_1 = __webpack_require__(12);\n\tvar util_1 = __webpack_require__(17);\n\tvar Shim;\n\t(function (Shim) {\n\t    /* tslint:disable-next-line:variable-name */\n\t    var Symbol;\n\t    /* tslint:disable-next-line:variable-name */\n\t    var InternalSymbol;\n\t    var defineProperties = Object.defineProperties;\n\t    var defineProperty = Object.defineProperty;\n\t    var create = Object.create;\n\t    var objPrototype = Object.prototype;\n\t    var globalSymbols = {};\n\t    var getSymbolName = (function () {\n\t        var created = create(null);\n\t        return function (desc) {\n\t            var postfix = 0;\n\t            var name;\n\t            while (created[String(desc) + (postfix || '')]) {\n\t                ++postfix;\n\t            }\n\t            desc += String(postfix || '');\n\t            created[desc] = true;\n\t            name = '@@' + desc;\n\t            // FIXME: Temporary guard until the duplicate execution when testing can be\n\t            // pinned down.\n\t            if (!Object.getOwnPropertyDescriptor(objPrototype, name)) {\n\t                defineProperty(objPrototype, name, {\n\t                    set: function (value) {\n\t                        defineProperty(this, name, util_1.getValueDescriptor(value));\n\t                    }\n\t                });\n\t            }\n\t            return name;\n\t        };\n\t    }());\n\t    InternalSymbol = function Symbol(description) {\n\t        if (this instanceof InternalSymbol) {\n\t            throw new TypeError('TypeError: Symbol is not a constructor');\n\t        }\n\t        return Symbol(description);\n\t    };\n\t    Symbol = function Symbol(description) {\n\t        if (this instanceof Symbol) {\n\t            throw new TypeError('TypeError: Symbol is not a constructor');\n\t        }\n\t        var sym = Object.create(InternalSymbol.prototype);\n\t        description = (description === undefined ? '' : String(description));\n\t        return defineProperties(sym, {\n\t            __description__: util_1.getValueDescriptor(description),\n\t            __name__: util_1.getValueDescriptor(getSymbolName(description))\n\t        });\n\t    };\n\t    /**\n\t     * A custom guard function that determines if an object is a symbol or not\n\t     * @param  {any}       value The value to check to see if it is a symbol or not\n\t     * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)\n\t     */\n\t    function isSymbol(value) {\n\t        return (value && ((typeof value === 'symbol') || (value['@@toStringTag'] === 'Symbol'))) || false;\n\t    }\n\t    Shim.isSymbol = isSymbol;\n\t    /**\n\t     * Throws if the value is not a symbol, used internally within the Shim\n\t     * @param  {any}    value The value to check\n\t     * @return {symbol}       Returns the symbol or throws\n\t     */\n\t    function validateSymbol(value) {\n\t        if (!isSymbol(value)) {\n\t            throw new TypeError(value + ' is not a symbol');\n\t        }\n\t        return value;\n\t    }\n\t    /* Decorate the Symbol function with the appropriate properties */\n\t    defineProperty(Symbol, 'for', util_1.getValueDescriptor(function (key) {\n\t        if (globalSymbols[key]) {\n\t            return globalSymbols[key];\n\t        }\n\t        return (globalSymbols[key] = Symbol(String(key)));\n\t    }));\n\t    defineProperties(Symbol, {\n\t        keyFor: util_1.getValueDescriptor(function (sym) {\n\t            var key;\n\t            validateSymbol(sym);\n\t            for (key in globalSymbols) {\n\t                if (globalSymbols[key] === sym) {\n\t                    return key;\n\t                }\n\t            }\n\t        }),\n\t        hasInstance: util_1.getValueDescriptor(Symbol.for('hasInstance'), false, false),\n\t        isConcatSpreadable: util_1.getValueDescriptor(Symbol.for('isConcatSpreadable'), false, false),\n\t        iterator: util_1.getValueDescriptor(Symbol.for('iterator'), false, false),\n\t        match: util_1.getValueDescriptor(Symbol.for('match'), false, false),\n\t        observable: util_1.getValueDescriptor(Symbol.for('observable'), false, false),\n\t        replace: util_1.getValueDescriptor(Symbol.for('replace'), false, false),\n\t        search: util_1.getValueDescriptor(Symbol.for('search'), false, false),\n\t        species: util_1.getValueDescriptor(Symbol.for('species'), false, false),\n\t        split: util_1.getValueDescriptor(Symbol.for('split'), false, false),\n\t        toPrimitive: util_1.getValueDescriptor(Symbol.for('toPrimitive'), false, false),\n\t        toStringTag: util_1.getValueDescriptor(Symbol.for('toStringTag'), false, false),\n\t        unscopables: util_1.getValueDescriptor(Symbol.for('unscopables'), false, false)\n\t    });\n\t    /* Decorate the InternalSymbol object */\n\t    defineProperties(InternalSymbol.prototype, {\n\t        constructor: util_1.getValueDescriptor(Symbol),\n\t        toString: util_1.getValueDescriptor(function () { return this.__name__; }, false, false)\n\t    });\n\t    /* Decorate the Symbol.prototype */\n\t    defineProperties(Symbol.prototype, {\n\t        toString: util_1.getValueDescriptor(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),\n\t        valueOf: util_1.getValueDescriptor(function () { return validateSymbol(this); })\n\t    });\n\t    defineProperty(Symbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(function () { return validateSymbol(this); }));\n\t    defineProperty(Symbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor('Symbol', false, false, true));\n\t    defineProperty(InternalSymbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(Symbol.prototype[Symbol.toPrimitive], false, false, true));\n\t    defineProperty(InternalSymbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor(Symbol.prototype[Symbol.toStringTag], false, false, true));\n\t    /* tslint:disable-next-line:variable-name */\n\t    Shim.Exposed = Symbol;\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\t/* tslint:disable-next-line:variable-name */\n\tvar SymbolShim = has_1.default('es6-symbol') ? global_1.default.Symbol : global_1.default.Symbol = Shim.Exposed;\n\t/**\n\t * Fill any missing well known symbols if the native Symbol is missing them\n\t */\n\t['hasInstance', 'isConcatSpreadable', 'iterator', 'species', 'replace', 'search', 'split', 'match', 'toPrimitive',\n\t    'toStringTag', 'unscopables', 'observable'].forEach(function (wellKnown) {\n\t    if (!Symbol[wellKnown]) {\n\t        Object.defineProperty(Symbol, wellKnown, util_1.getValueDescriptor(Symbol.for(wellKnown), false, false));\n\t    }\n\t});\n\texports.isSymbol = Shim.isSymbol;\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = SymbolShim;\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar global_1 = __webpack_require__(12);\n\t/**\n\t * The smallest interval between two representable numbers.\n\t */\n\texports.EPSILON = 1;\n\t/**\n\t * The maximum safe integer in JavaScript\n\t */\n\texports.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t/**\n\t * The minimum safe integer in JavaScript\n\t */\n\texports.MIN_SAFE_INTEGER = -exports.MAX_SAFE_INTEGER;\n\t/**\n\t * Determines whether the passed value is NaN without coersion.\n\t *\n\t * @param value The value to test\n\t * @return true if the value is NaN, false if it is not\n\t */\n\tfunction isNaN(value) {\n\t    return typeof value === 'number' && global_1.default.isNaN(value);\n\t}\n\texports.isNaN = isNaN;\n\t/**\n\t * Determines whether the passed value is a finite number without coersion.\n\t *\n\t * @param value The value to test\n\t * @return true if the value is finite, false if it is not\n\t */\n\tfunction isFinite(value) {\n\t    return typeof value === 'number' && global_1.default.isFinite(value);\n\t}\n\texports.isFinite = isFinite;\n\t/**\n\t * Determines whether the passed value is an integer.\n\t *\n\t * @param value The value to test\n\t * @return true if the value is an integer, false if it is not\n\t */\n\tfunction isInteger(value) {\n\t    return isFinite(value) && Math.floor(value) === value;\n\t}\n\texports.isInteger = isInteger;\n\t/**\n\t * Determines whether the passed value is an integer that is 'safe,' meaning:\n\t *   1. it can be expressed as an IEEE-754 double precision number\n\t *   2. it has a one-to-one mapping to a mathematical integer, meaning its\n\t *      IEEE-754 representation cannot be the result of rounding any other\n\t *      integer to fit the IEEE-754 representation\n\t *\n\t * @param value The value to test\n\t * @return true if the value is an integer, false if it is not\n\t */\n\tfunction isSafeInteger(value) {\n\t    return isInteger(value) && Math.abs(value) <= exports.MAX_SAFE_INTEGER;\n\t}\n\texports.isSafeInteger = isSafeInteger;\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar decorators_1 = __webpack_require__(23);\n\tvar global_1 = __webpack_require__(12);\n\tvar iterator_1 = __webpack_require__(18);\n\t__webpack_require__(20);\n\tvar Shim;\n\t(function (Shim) {\n\t    var DELETED = {};\n\t    function getUID() {\n\t        return Math.floor(Math.random() * 100000000);\n\t    }\n\t    var generateName = (function () {\n\t        var startId = Math.floor(Date.now() % 100000000);\n\t        return function generateName() {\n\t            return '__wm' + getUID() + (startId++ + '__');\n\t        };\n\t    })();\n\t    var WeakMap = (function () {\n\t        function WeakMap(iterable) {\n\t            var _this = this;\n\t            this[Symbol.toStringTag] = 'WeakMap';\n\t            Object.defineProperty(this, '_name', {\n\t                value: generateName()\n\t            });\n\t            this._frozenEntries = [];\n\t            if (iterable) {\n\t                iterator_1.forOf(iterable, function (_a) {\n\t                    var key = _a[0], value = _a[1];\n\t                    return _this.set(key, value);\n\t                });\n\t            }\n\t        }\n\t        WeakMap.prototype._getFrozenEntryIndex = function (key) {\n\t            for (var i = 0; i < this._frozenEntries.length; i++) {\n\t                if (this._frozenEntries[i].key === key) {\n\t                    return i;\n\t                }\n\t            }\n\t            return -1;\n\t        };\n\t        WeakMap.prototype.delete = function (key) {\n\t            if (key === undefined || key === null) {\n\t                return false;\n\t            }\n\t            var entry = key[this._name];\n\t            if (entry && entry.key === key && entry.value !== DELETED) {\n\t                entry.value = DELETED;\n\t                return true;\n\t            }\n\t            var frozenIndex = this._getFrozenEntryIndex(key);\n\t            if (frozenIndex >= 0) {\n\t                this._frozenEntries.splice(frozenIndex, 1);\n\t                return true;\n\t            }\n\t            return false;\n\t        };\n\t        WeakMap.prototype.get = function (key) {\n\t            if (key === undefined || key === null) {\n\t                return undefined;\n\t            }\n\t            var entry = key[this._name];\n\t            if (entry && entry.key === key && entry.value !== DELETED) {\n\t                return entry.value;\n\t            }\n\t            var frozenIndex = this._getFrozenEntryIndex(key);\n\t            if (frozenIndex >= 0) {\n\t                return this._frozenEntries[frozenIndex].value;\n\t            }\n\t        };\n\t        WeakMap.prototype.has = function (key) {\n\t            if (key === undefined || key === null) {\n\t                return false;\n\t            }\n\t            var entry = key[this._name];\n\t            if (Boolean(entry && entry.key === key && entry.value !== DELETED)) {\n\t                return true;\n\t            }\n\t            var frozenIndex = this._getFrozenEntryIndex(key);\n\t            if (frozenIndex >= 0) {\n\t                return true;\n\t            }\n\t            return false;\n\t        };\n\t        WeakMap.prototype.set = function (key, value) {\n\t            if (!key || (typeof key !== 'object' && typeof key !== 'function')) {\n\t                throw new TypeError('Invalid value used as weak map key');\n\t            }\n\t            var entry = key[this._name];\n\t            if (!entry || entry.key !== key) {\n\t                entry = Object.create(null, {\n\t                    key: { value: key }\n\t                });\n\t                if (Object.isFrozen(key)) {\n\t                    this._frozenEntries.push(entry);\n\t                }\n\t                else {\n\t                    Object.defineProperty(key, this._name, {\n\t                        value: entry\n\t                    });\n\t                }\n\t            }\n\t            entry.value = value;\n\t            return this;\n\t        };\n\t        return WeakMap;\n\t    }());\n\t    Shim.WeakMap = WeakMap;\n\t})(Shim || (Shim = {}));\n\tvar WeakMap = (function () {\n\t    /* istanbul ignore next */\n\t    function WeakMap(iterable) {\n\t        /* istanbul ignore next */\n\t        this[Symbol.toStringTag] = 'WeakMap';\n\t    }\n\t    /* istanbul ignore next */\n\t    WeakMap.prototype.delete = function (key) { throw new Error(); };\n\t    /* istanbul ignore next */\n\t    WeakMap.prototype.get = function (key) { throw new Error(); };\n\t    /* istanbul ignore next */\n\t    WeakMap.prototype.has = function (key) { throw new Error(); };\n\t    /* istanbul ignore next */\n\t    WeakMap.prototype.set = function (key, value) { throw new Error(); };\n\t    return WeakMap;\n\t}());\n\tWeakMap = __decorate([\n\t    decorators_1.hasClass('es6-weakmap', global_1.default.WeakMap, Shim.WeakMap)\n\t], WeakMap);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = WeakMap;\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(11);\n\t/**\n\t * A class decorator that provides either a native class or a shimmed class based on a feature\n\t * test\n\t * @param feature The has feature to check\n\t * @param trueClass The class to use if feature test returns `true`\n\t * @param falseClass The class to use if the feature test returns `false` or is not defined\n\t */\n\tfunction hasClass(feature, trueClass, falseClass) {\n\t    return function (target) {\n\t        return has_1.default(feature) ? trueClass : falseClass;\n\t    };\n\t}\n\texports.hasClass = hasClass;\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar WeakMap_1 = __webpack_require__(22);\n\t/**\n\t * Types of advice\n\t */\n\tvar AdviceType;\n\t(function (AdviceType) {\n\t    AdviceType[AdviceType[\"Before\"] = 0] = \"Before\";\n\t    AdviceType[AdviceType[\"After\"] = 1] = \"After\";\n\t    AdviceType[AdviceType[\"Around\"] = 2] = \"Around\";\n\t})(AdviceType = exports.AdviceType || (exports.AdviceType = {}));\n\t/**\n\t * A weak map of dispatchers used to apply the advice\n\t */\n\tvar dispatchAdviceMap = new WeakMap_1.default();\n\t/**\n\t * Returns the dispatcher function for a given joinPoint (method/function)\n\t *\n\t * @param joinPoint The function that is to be advised\n\t */\n\tfunction getDispatcher(joinPoint) {\n\t    function dispatcher() {\n\t        var _this = this;\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        var _a = dispatchAdviceMap.get(dispatcher), before = _a.before, after = _a.after, joinPoint = _a.joinPoint;\n\t        if (before) {\n\t            args = before.reduce(function (previousArgs, advice) {\n\t                var currentArgs = advice.apply(_this, previousArgs);\n\t                return currentArgs || previousArgs;\n\t            }, args);\n\t        }\n\t        var result = joinPoint.apply(this, args);\n\t        if (after) {\n\t            result = after.reduce(function (previousResult, advice) {\n\t                return advice.apply(_this, [previousResult].concat(args));\n\t            }, result);\n\t        }\n\t        return result;\n\t    }\n\t    /* We want to \"clone\" the advice that has been applied already, if this\n\t     * joinPoint is already advised */\n\t    if (dispatchAdviceMap.has(joinPoint)) {\n\t        var adviceMap = dispatchAdviceMap.get(joinPoint);\n\t        var before_1 = adviceMap.before, after_1 = adviceMap.after;\n\t        if (before_1) {\n\t            before_1 = before_1.slice(0);\n\t        }\n\t        if (after_1) {\n\t            after_1 = after_1.slice(0);\n\t        }\n\t        dispatchAdviceMap.set(dispatcher, {\n\t            joinPoint: adviceMap.joinPoint,\n\t            before: before_1,\n\t            after: after_1\n\t        });\n\t    }\n\t    else {\n\t        dispatchAdviceMap.set(dispatcher, { joinPoint: joinPoint });\n\t    }\n\t    return dispatcher;\n\t}\n\t/**\n\t * Advise a join point (function) with supplied advice\n\t *\n\t * @param joinPoint The function to be advised\n\t * @param type The type of advice to be applied\n\t * @param advice The advice to apply\n\t */\n\tfunction advise(joinPoint, type, advice) {\n\t    var dispatcher;\n\t    if (type === AdviceType.Around) {\n\t        dispatcher = getDispatcher(advice.apply(this, [joinPoint]));\n\t    }\n\t    else {\n\t        dispatcher = getDispatcher(joinPoint);\n\t        var adviceMap = dispatchAdviceMap.get(dispatcher);\n\t        if (type === AdviceType.Before) {\n\t            (adviceMap.before || (adviceMap.before = [])).unshift(advice);\n\t        }\n\t        else {\n\t            (adviceMap.after || (adviceMap.after = [])).push(advice);\n\t        }\n\t    }\n\t    return dispatcher;\n\t}\n\t/**\n\t * Apply advice *before* the supplied joinPoint (function)\n\t *\n\t * @param joinPoint A function that should have advice applied to\n\t * @param advice The before advice\n\t */\n\tfunction before(joinPoint, advice) {\n\t    return advise(joinPoint, AdviceType.Before, advice);\n\t}\n\texports.before = before;\n\t/**\n\t * Apply advice *after* the supplied joinPoint (function)\n\t *\n\t * @param joinPoint A function that should have advice applied to\n\t * @param advice The after advice\n\t */\n\tfunction after(joinPoint, advice) {\n\t    return advise(joinPoint, AdviceType.After, advice);\n\t}\n\texports.after = after;\n\t/**\n\t * Apply advice *around* the supplied joinPoint (function)\n\t *\n\t * @param joinPoint A function that should have advice applied to\n\t * @param advice The around advice\n\t */\n\tfunction around(joinPoint, advice) {\n\t    return advise(joinPoint, AdviceType.Around, advice);\n\t}\n\texports.around = around;\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(15);\n\t/**\n\t * Parses a query string, returning a ParamList object.\n\t */\n\tfunction parseQueryString(input) {\n\t    var query = {};\n\t    for (var _i = 0, _a = input.split('&'); _i < _a.length; _i++) {\n\t        var entry = _a[_i];\n\t        var indexOfFirstEquals = entry.indexOf('=');\n\t        var key = void 0;\n\t        var value = '';\n\t        if (indexOfFirstEquals >= 0) {\n\t            key = entry.slice(0, indexOfFirstEquals);\n\t            value = entry.slice(indexOfFirstEquals + 1);\n\t        }\n\t        else {\n\t            key = entry;\n\t        }\n\t        key = key ? decodeURIComponent(key) : '';\n\t        value = value ? decodeURIComponent(value) : '';\n\t        if (key in query) {\n\t            query[key].push(value);\n\t        }\n\t        else {\n\t            query[key] = [value];\n\t        }\n\t    }\n\t    return query;\n\t}\n\t/**\n\t * Represents a set of URL query search parameters.\n\t */\n\tvar UrlSearchParams = (function () {\n\t    /**\n\t     * Constructs a new UrlSearchParams from a query string, an object of parameters and values, or another\n\t     * UrlSearchParams.\n\t     */\n\t    function UrlSearchParams(input) {\n\t        var list;\n\t        if (input instanceof UrlSearchParams) {\n\t            // Copy the incoming UrlSearchParam's internal list\n\t            list = lang_1.duplicate(input._list);\n\t        }\n\t        else if (typeof input === 'object') {\n\t            // Copy the incoming object, assuming its property values are either arrays or strings\n\t            list = {};\n\t            for (var key in input) {\n\t                var value = input[key];\n\t                if (Array.isArray(value)) {\n\t                    list[key] = value.length ? value.slice() : [''];\n\t                }\n\t                else if (value == null) {\n\t                    list[key] = [''];\n\t                }\n\t                else {\n\t                    list[key] = [value];\n\t                }\n\t            }\n\t        }\n\t        else if (typeof input === 'string') {\n\t            // Parse the incoming string as a query string\n\t            list = parseQueryString(input);\n\t        }\n\t        else {\n\t            list = {};\n\t        }\n\t        Object.defineProperty(this, '_list', { value: list });\n\t    }\n\t    /**\n\t     * Appends a new value to the set of values for a key.\n\t     * @param key The key to add a value for\n\t     * @param value The value to add\n\t     */\n\t    UrlSearchParams.prototype.append = function (key, value) {\n\t        if (!this.has(key)) {\n\t            this.set(key, value);\n\t        }\n\t        else {\n\t            var values = this._list[key];\n\t            if (values) {\n\t                values.push(value);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Deletes all values for a key.\n\t     * @param key The key whose values are to be removed\n\t     */\n\t    UrlSearchParams.prototype.delete = function (key) {\n\t        // Set to undefined rather than deleting the key, for better consistency across browsers.\n\t        // If a deleted key is re-added, most browsers put it at the end of iteration order, but IE maintains\n\t        // its original position.  This approach maintains the original position everywhere.\n\t        this._list[key] = undefined;\n\t    };\n\t    /**\n\t     * Returns the first value associated with a key.\n\t     * @param key The key to return the first value for\n\t     * @return The first string value for the key\n\t     */\n\t    UrlSearchParams.prototype.get = function (key) {\n\t        if (!this.has(key)) {\n\t            return undefined;\n\t        }\n\t        var value = this._list[key];\n\t        return value ? value[0] : undefined;\n\t    };\n\t    /**\n\t     * Returns all the values associated with a key.\n\t     * @param key The key to return all values for\n\t     * @return An array of strings containing all values for the key\n\t     */\n\t    UrlSearchParams.prototype.getAll = function (key) {\n\t        if (!this.has(key)) {\n\t            return undefined;\n\t        }\n\t        return this._list[key];\n\t    };\n\t    /**\n\t     * Returns true if a key has been set to any value, false otherwise.\n\t     * @param key The key to test for existence\n\t     * @return A boolean indicating if the key has been set\n\t     */\n\t    UrlSearchParams.prototype.has = function (key) {\n\t        return Array.isArray(this._list[key]);\n\t    };\n\t    /**\n\t     * Returns an array of all keys which have been set.\n\t     * @return An array of strings containing all keys set in the UrlSearchParams instance\n\t     */\n\t    UrlSearchParams.prototype.keys = function () {\n\t        var keys = [];\n\t        for (var key in this._list) {\n\t            if (this.has(key)) {\n\t                keys.push(key);\n\t            }\n\t        }\n\t        return keys;\n\t    };\n\t    /**\n\t     * Sets the value associated with a key.\n\t     * @param key The key to set the value of\n\t     */\n\t    UrlSearchParams.prototype.set = function (key, value) {\n\t        this._list[key] = [value];\n\t    };\n\t    /**\n\t     * Returns this object's data as an encoded query string.\n\t     * @return A string in application/x-www-form-urlencoded format containing all of the set keys/values\n\t     */\n\t    UrlSearchParams.prototype.toString = function () {\n\t        var query = [];\n\t        for (var key in this._list) {\n\t            if (!this.has(key)) {\n\t                continue;\n\t            }\n\t            var values = this._list[key];\n\t            if (values) {\n\t                var encodedKey = encodeURIComponent(key);\n\t                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n\t                    var value = values_1[_i];\n\t                    query.push(encodedKey + (value ? ('=' + encodeURIComponent(value)) : ''));\n\t                }\n\t            }\n\t        }\n\t        return query.join('&');\n\t    };\n\t    return UrlSearchParams;\n\t}());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = UrlSearchParams;\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(7);\n\tvar createEvented_1 = __webpack_require__(27);\n\tvar Task_1 = __webpack_require__(36);\n\tvar on_1 = __webpack_require__(38);\n\tvar UrlSearchParams_1 = __webpack_require__(25);\n\tvar array_1 = __webpack_require__(16);\n\tvar Promise_1 = __webpack_require__(32);\n\tvar WeakMap_1 = __webpack_require__(22);\n\tvar path_1 = __webpack_require__(39);\n\tvar parentMap = new WeakMap_1.default();\n\t/**\n\t * Whether the route has been appended to another route or router.\n\t */\n\tfunction hasBeenAppended(route) {\n\t    return parentMap.has(route) || route.parent !== undefined;\n\t}\n\texports.hasBeenAppended = hasBeenAppended;\n\t/**\n\t * Finds the router whose route hierarchy the route has been appended to.\n\t *\n\t * Throws if the route was not appended to any router.\n\t */\n\tfunction findRouter(route) {\n\t    while (route.parent) {\n\t        route = route.parent;\n\t    }\n\t    var router = parentMap.get(route);\n\t    if (!router) {\n\t        throw new Error('Cannot generate link for route that is not in the hierarchy');\n\t    }\n\t    else {\n\t        return router;\n\t    }\n\t}\n\texports.findRouter = findRouter;\n\tvar privateStateMap = new WeakMap_1.default();\n\t// istanbul ignore next\n\tvar noop = function () { };\n\tfunction createDeferral() {\n\t    // Use noop since TypeScript doesn't know we're assigning cancel and resume in the promise executor.\n\t    var cancel = noop;\n\t    var resume = noop;\n\t    var promise = new Promise_1.default(function (resolve, reject) {\n\t        cancel = reject;\n\t        // Wrap resolve to avoid resume being called with a thenable if type checking is not used.\n\t        resume = function () { return resolve(); };\n\t    });\n\t    return { cancel: cancel, promise: promise, resume: resume };\n\t}\n\tfunction reportError(router, context, path, error) {\n\t    router.emit({\n\t        context: context,\n\t        error: error,\n\t        path: path,\n\t        target: router,\n\t        type: 'error'\n\t    });\n\t}\n\tfunction catchRejection(router, context, path, thenable) {\n\t    if (thenable) {\n\t        Promise_1.default.resolve(thenable).catch(function (error) {\n\t            reportError(router, context, path, error);\n\t        });\n\t    }\n\t}\n\tvar createRouter = compose_1.default.mixin(createEvented_1.default, {\n\t    mixin: {\n\t        append: function (add) {\n\t            var _this = this;\n\t            var routes = privateStateMap.get(this).routes;\n\t            var append = function (route) {\n\t                if (hasBeenAppended(route)) {\n\t                    throw new Error('Cannot append route that has already been appended');\n\t                }\n\t                routes.push(route);\n\t                parentMap.set(route, _this);\n\t            };\n\t            if (Array.isArray(add)) {\n\t                for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {\n\t                    var route = add_1[_i];\n\t                    append(route);\n\t                }\n\t            }\n\t            else {\n\t                append(add);\n\t            }\n\t        },\n\t        dispatch: function (context, path) {\n\t            var _this = this;\n\t            var state = privateStateMap.get(this);\n\t            var dispatchFromStart = state.dispatchFromStart;\n\t            // Reset, any further calls can't have come from start(). This is necessary since the navstart listeners\n\t            // may call dispatch() themselves.\n\t            state.dispatchFromStart = false;\n\t            var canceled = false;\n\t            var cancel = function () {\n\t                canceled = true;\n\t            };\n\t            var deferrals = [];\n\t            this.emit({\n\t                cancel: cancel,\n\t                defer: function () {\n\t                    var _a = createDeferral(), cancel = _a.cancel, promise = _a.promise, resume = _a.resume;\n\t                    deferrals.push(promise);\n\t                    return { cancel: cancel, resume: resume };\n\t                },\n\t                path: path,\n\t                target: this,\n\t                type: 'navstart'\n\t            });\n\t            // Synchronous cancelation.\n\t            if (canceled) {\n\t                return Task_1.default.resolve({ success: false });\n\t            }\n\t            var _a = path_1.parse(path), searchParams = _a.searchParams, segments = _a.segments, trailingSlash = _a.trailingSlash;\n\t            return new Task_1.default(function (resolve, reject) {\n\t                // *Always* start dispatching in a future turn, even if there were no deferrals.\n\t                Promise_1.default.all(deferrals).then(function () {\n\t                    // The cancel() function used in the NavigationStartEvent is reused as the Task canceler.\n\t                    // Strictly speaking any navstart listener can cancel the dispatch asynchronously, as long as it\n\t                    // manages to do so before this turn.\n\t                    if (canceled) {\n\t                        return { success: false };\n\t                    }\n\t                    var fallback = state.fallback, routes = state.routes;\n\t                    var redirect;\n\t                    var dispatched = routes.some(function (route) {\n\t                        var result = route.select(context, segments, trailingSlash, searchParams);\n\t                        if (typeof result === 'string') {\n\t                            redirect = result;\n\t                            return true;\n\t                        }\n\t                        if (result.length === 0) {\n\t                            return false;\n\t                        }\n\t                        // Update the selected routes after selecting new routes, but before invoking the handlers.\n\t                        // This means the original value is available to guard() and params() functions, and the\n\t                        // new value when the newly selected routes are executed.\n\t                        //\n\t                        // Reset selected routes if not dispatched from start().\n\t                        state.currentSelection = dispatchFromStart ? result : [];\n\t                        for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {\n\t                            var _a = result_1[_i], handler = _a.handler, params = _a.params;\n\t                            catchRejection(_this, context, path, handler({ context: context, params: params }));\n\t                        }\n\t                        return true;\n\t                    });\n\t                    // Reset the selected routes if the dispatch was unsuccessful, or if a redirect was requested.\n\t                    if (!dispatched || redirect !== undefined) {\n\t                        state.currentSelection = [];\n\t                    }\n\t                    if (!dispatched && fallback) {\n\t                        catchRejection(_this, context, path, fallback({ context: context, params: {} }));\n\t                        return { success: false };\n\t                    }\n\t                    var result = { success: dispatched };\n\t                    if (redirect !== undefined) {\n\t                        result.redirect = redirect;\n\t                    }\n\t                    return result;\n\t                }, \n\t                // When deferrals are canceled their corresponding promise is rejected. Ensure the task resolves\n\t                // with `false` instead of being rejected too.\n\t                function () {\n\t                    return { success: false };\n\t                }).then(resolve, function (error) {\n\t                    reportError(_this, context, path, error);\n\t                    reject(error);\n\t                });\n\t            }, cancel);\n\t        },\n\t        link: function (route, params) {\n\t            if (params === void 0) { params = {}; }\n\t            var _a = privateStateMap.get(this), history = _a.history, roots = _a.routes, currentSelection = _a.currentSelection;\n\t            var hierarchy = [route];\n\t            for (var parent_1 = route.parent; parent_1 !== undefined; parent_1 = parent_1.parent) {\n\t                hierarchy.unshift(parent_1);\n\t            }\n\t            if (!array_1.includes(roots, hierarchy[0])) {\n\t                throw new Error('Cannot generate link for route that is not in the hierarchy');\n\t            }\n\t            var addLeadingSlash = hierarchy[0].path.leadingSlash;\n\t            var addTrailingSlash = false;\n\t            var segments = [];\n\t            var searchParams = new UrlSearchParams_1.default();\n\t            hierarchy\n\t                .map(function (route, index) {\n\t                var path = route.path;\n\t                var currentPathValues;\n\t                var currentSearchParams;\n\t                var selection = currentSelection[index];\n\t                if (selection && selection.route === route) {\n\t                    currentPathValues = selection.rawPathValues;\n\t                    currentSearchParams = selection.rawSearchParams;\n\t                }\n\t                return { currentPathValues: currentPathValues, currentSearchParams: currentSearchParams, path: path };\n\t            })\n\t                .forEach(function (_a) {\n\t                var currentPathValues = _a.currentPathValues, currentSearchParams = _a.currentSearchParams, path = _a.path;\n\t                var expectedSegments = path.expectedSegments, searchParameters = path.searchParameters, trailingSlash = path.trailingSlash;\n\t                addTrailingSlash = trailingSlash;\n\t                var namedOffset = 0;\n\t                for (var _i = 0, expectedSegments_1 = expectedSegments; _i < expectedSegments_1.length; _i++) {\n\t                    var segment = expectedSegments_1[_i];\n\t                    if (path_1.isNamedSegment(segment)) {\n\t                        var value = params[segment.name];\n\t                        if (typeof value === 'string') {\n\t                            segments.push(value);\n\t                        }\n\t                        else if (Array.isArray(value)) {\n\t                            if (value.length === 1) {\n\t                                segments.push(value[0]);\n\t                            }\n\t                            else {\n\t                                throw new TypeError(\"Cannot generate link, multiple values for parameter '\" + segment.name + \"'\");\n\t                            }\n\t                        }\n\t                        else if (currentPathValues) {\n\t                            segments.push(currentPathValues[namedOffset]);\n\t                        }\n\t                        else {\n\t                            throw new Error(\"Cannot generate link, missing parameter '\" + segment.name + \"'\");\n\t                        }\n\t                        namedOffset++;\n\t                    }\n\t                    else {\n\t                        segments.push(segment.literal);\n\t                    }\n\t                }\n\t                for (var _b = 0, searchParameters_1 = searchParameters; _b < searchParameters_1.length; _b++) {\n\t                    var key = searchParameters_1[_b];\n\t                    // Don't repeat the search parameter if a previous route in the hierarchy has already appended\n\t                    // it.\n\t                    if (searchParams.has(key)) {\n\t                        continue;\n\t                    }\n\t                    var value = params[key];\n\t                    if (typeof value === 'string') {\n\t                        searchParams.append(key, value);\n\t                    }\n\t                    else if (Array.isArray(value)) {\n\t                        for (var _c = 0, value_1 = value; _c < value_1.length; _c++) {\n\t                            var item = value_1[_c];\n\t                            searchParams.append(key, item);\n\t                        }\n\t                    }\n\t                    else if (currentSearchParams) {\n\t                        for (var _d = 0, _e = currentSearchParams[key]; _d < _e.length; _d++) {\n\t                            var item = _e[_d];\n\t                            searchParams.append(key, item);\n\t                        }\n\t                    }\n\t                    else {\n\t                        throw new Error(\"Cannot generate link, missing search parameter '\" + key + \"'\");\n\t                    }\n\t                }\n\t            });\n\t            var pathname = segments.join('/');\n\t            if (addLeadingSlash) {\n\t                pathname = '/' + pathname;\n\t            }\n\t            if (addTrailingSlash) {\n\t                pathname += '/';\n\t            }\n\t            if (history) {\n\t                pathname = history.prefix(pathname);\n\t            }\n\t            var search = searchParams.toString();\n\t            var path = search ? pathname + \"?\" + search : pathname;\n\t            return path;\n\t        },\n\t        replacePath: function (path) {\n\t            var history = privateStateMap.get(this).history;\n\t            if (!history) {\n\t                throw new Error('Cannot replace path, router was created without a history manager');\n\t            }\n\t            history.replace(path);\n\t        },\n\t        setPath: function (path) {\n\t            var history = privateStateMap.get(this).history;\n\t            if (!history) {\n\t                throw new Error('Cannot set path, router was created without a history manager');\n\t            }\n\t            history.set(path);\n\t        },\n\t        start: function (_a) {\n\t            var _this = this;\n\t            var dispatchCurrent = (_a === void 0 ? { dispatchCurrent: true } : _a).dispatchCurrent;\n\t            var state = privateStateMap.get(this);\n\t            if (state.started) {\n\t                throw new Error('start can only be called once');\n\t            }\n\t            state.started = true;\n\t            var contextFactory = state.contextFactory, history = state.history;\n\t            if (!history) {\n\t                return {\n\t                    pause: function () { },\n\t                    resume: function () { },\n\t                    destroy: function () { }\n\t                };\n\t            }\n\t            var lastDispatch;\n\t            var redirectCount = 0;\n\t            var redirecting = false;\n\t            var dispatch = function (path) {\n\t                if (lastDispatch) {\n\t                    lastDispatch.cancel();\n\t                }\n\t                // Reset redirect count if the dispatch was triggered by a non-redirect history change. This allows\n\t                // a route's exec / fallback / index handler to change the history, setting off a new flurry of\n\t                // redirects, without being encumbered by the number of redirects that led to that route being selected.\n\t                if (!redirecting) {\n\t                    redirectCount = 0;\n\t                }\n\t                // Signal to dispatch() that it was called from here.\n\t                state.dispatchFromStart = true;\n\t                var context = contextFactory();\n\t                lastDispatch = _this.dispatch(context, path).then(function (dispatchResult) {\n\t                    var _a = dispatchResult || { success: false }, success = _a.success, _b = _a.redirect, redirect = _b === void 0 ? undefined : _b;\n\t                    if (success && redirect !== undefined) {\n\t                        redirectCount++;\n\t                        if (redirectCount > 20) {\n\t                            var error = new Error('More than 20 redirects, giving up');\n\t                            reportError(_this, context, path, error);\n\t                            throw error;\n\t                        }\n\t                        redirecting = true;\n\t                        // The history manager MUST emit the change event synchronously.\n\t                        history.replace(redirect);\n\t                        redirecting = false;\n\t                    }\n\t                    return dispatchResult;\n\t                });\n\t            };\n\t            var listener = on_1.pausable(history, 'change', function (event) {\n\t                dispatch(event.value);\n\t            });\n\t            this.own(listener);\n\t            if (dispatchCurrent) {\n\t                dispatch(history.current);\n\t            }\n\t            return listener;\n\t        }\n\t    },\n\t    initialize: function (instance, _a) {\n\t        var _b = _a === void 0 ? {} : _a, context = _b.context, fallback = _b.fallback, history = _b.history;\n\t        var contextFactory;\n\t        if (typeof context === 'function') {\n\t            contextFactory = context;\n\t        }\n\t        else if (typeof context === 'undefined') {\n\t            contextFactory = function () {\n\t                return {};\n\t            };\n\t        }\n\t        else {\n\t            // Assign to a constant since the context variable may be changed after the function is defined,\n\t            // which would violate its typing.\n\t            var sharedContext_1 = context;\n\t            contextFactory = function () { return sharedContext_1; };\n\t        }\n\t        if (history) {\n\t            instance.own(history);\n\t        }\n\t        privateStateMap.set(instance, {\n\t            contextFactory: contextFactory,\n\t            currentSelection: [],\n\t            dispatchFromStart: false,\n\t            fallback: fallback,\n\t            history: history,\n\t            routes: []\n\t        });\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createRouter;\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar aspect_1 = __webpack_require__(28);\n\tvar Map_1 = __webpack_require__(29);\n\tvar WeakMap_1 = __webpack_require__(22);\n\tvar createDestroyable_1 = __webpack_require__(31);\n\t/**\n\t * A weak map that contains a map of the listeners for an `Evented`\n\t */\n\tvar listenersMap = new WeakMap_1.default();\n\t/**\n\t * A guard which determines if the value is `Actionable`\n\t *\n\t * @param value The value to guard against\n\t */\n\tfunction isActionable(value) {\n\t    return Boolean(value && typeof value.do === 'function');\n\t}\n\t/**\n\t * An internal function that always returns an EventedCallback\n\t *\n\t * @param listener Either a `EventedCallback` or an `Actionable`\n\t */\n\tfunction resolveListener(listener) {\n\t    return isActionable(listener) ? function (event) { return listener.do({ event: event }); } : listener;\n\t}\n\texports.resolveListener = resolveListener;\n\t/**\n\t * Internal function to convert an array of handles to a single handle\n\t *\n\t * @param handles The array of handles to convert into a signle handle\n\t * @return The single handle\n\t */\n\tfunction handlesArraytoHandle(handles) {\n\t    return {\n\t        destroy: function () {\n\t            handles.forEach(function (handle) { return handle.destroy(); });\n\t        }\n\t    };\n\t}\n\t/**\n\t * Creates a new instance of an `Evented`\n\t */\n\tvar createEvented = createDestroyable_1.default\n\t    .mixin({\n\t    className: 'Evented',\n\t    mixin: {\n\t        emit: function (event) {\n\t            var method = listenersMap.get(this).get(event.type);\n\t            if (method) {\n\t                method.call(this, event);\n\t            }\n\t        },\n\t        on: function () {\n\t            var _this = this;\n\t            var args = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                args[_i] = arguments[_i];\n\t            }\n\t            var listenerMap = listenersMap.get(this);\n\t            if (args.length === 2) {\n\t                var _a = args, type_1 = _a[0], listeners = _a[1];\n\t                if (Array.isArray(listeners)) {\n\t                    var handles = listeners.map(function (listener) { return aspect_1.on(listenerMap, type_1, resolveListener(listener)); });\n\t                    return handlesArraytoHandle(handles);\n\t                }\n\t                else {\n\t                    return aspect_1.on(listenerMap, type_1, resolveListener(listeners));\n\t                }\n\t            }\n\t            else if (args.length === 1) {\n\t                var listenerMapArg_1 = args[0];\n\t                var handles = Object.keys(listenerMapArg_1).map(function (type) { return _this.on(type, listenerMapArg_1[type]); });\n\t                return handlesArraytoHandle(handles);\n\t            }\n\t            else {\n\t                throw new TypeError('Invalid arguments');\n\t            }\n\t        }\n\t    },\n\t    initialize: function (instance, options) {\n\t        listenersMap.set(instance, new Map_1.default());\n\t        if (options && options.listeners) {\n\t            instance.own(instance.on(options.listeners));\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createEvented;\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(15);\n\t/**\n\t * An internal type guard that determines if an value is MapLike or not\n\t *\n\t * @param value The value to guard against\n\t */\n\tfunction isMapLike(value) {\n\t    return value && typeof value.get === 'function' && typeof value.set === 'function';\n\t}\n\t/**\n\t * A UID for tracking advice ordering\n\t */\n\tvar nextId = 0;\n\t/**\n\t * Internal function that advises a join point\n\t *\n\t * @param dispatcher The current advice dispatcher\n\t * @param type The type of before or after advice to apply\n\t * @param advice The advice to apply\n\t * @param receiveArguments If true, the advice will receive the arguments passed to the join point\n\t * @return The handle that will remove the advice\n\t */\n\tfunction advise(dispatcher, type, advice, receiveArguments) {\n\t    var previous = dispatcher && dispatcher[type];\n\t    var advised = {\n\t        id: nextId++,\n\t        advice: advice,\n\t        receiveArguments: receiveArguments\n\t    };\n\t    if (previous) {\n\t        if (type === 'after') {\n\t            // add the listener to the end of the list\n\t            // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n\t            while (previous.next && (previous = previous.next)) { }\n\t            previous.next = advised;\n\t            advised.previous = previous;\n\t        }\n\t        else {\n\t            // add to the beginning\n\t            if (dispatcher) {\n\t                dispatcher.before = advised;\n\t            }\n\t            advised.next = previous;\n\t            previous.previous = advised;\n\t        }\n\t    }\n\t    else {\n\t        dispatcher && (dispatcher[type] = advised);\n\t    }\n\t    advice = previous = undefined;\n\t    return lang_1.createHandle(function () {\n\t        var _a = (advised || {}), _b = _a.previous, previous = _b === void 0 ? undefined : _b, _c = _a.next, next = _c === void 0 ? undefined : _c;\n\t        if (dispatcher && !previous && !next) {\n\t            dispatcher[type] = undefined;\n\t        }\n\t        else {\n\t            if (previous) {\n\t                previous.next = next;\n\t            }\n\t            else {\n\t                dispatcher && (dispatcher[type] = next);\n\t            }\n\t            if (next) {\n\t                next.previous = previous;\n\t            }\n\t        }\n\t        if (advised) {\n\t            delete advised.advice;\n\t        }\n\t        dispatcher = advised = undefined;\n\t    });\n\t}\n\t/**\n\t * An internal function that resolves or creates the dispatcher for a given join point\n\t *\n\t * @param target The target object or map\n\t * @param methodName The name of the method that the dispatcher should be resolved for\n\t * @return The dispatcher\n\t */\n\tfunction getDispatcher(target, methodName) {\n\t    var existing = isMapLike(target) ? target.get(methodName) : target && target[methodName];\n\t    var dispatcher;\n\t    if (!existing || existing.target !== target) {\n\t        /* There is no existing dispatcher, therefore we will create one */\n\t        dispatcher = function () {\n\t            var executionId = nextId;\n\t            var args = arguments;\n\t            var results;\n\t            var before = dispatcher.before;\n\t            while (before) {\n\t                if (before.advice) {\n\t                    args = before.advice.apply(this, args) || args;\n\t                }\n\t                before = before.next;\n\t            }\n\t            if (dispatcher.around && dispatcher.around.advice) {\n\t                results = dispatcher.around.advice(this, args);\n\t            }\n\t            var after = dispatcher.after;\n\t            while (after && after.id < executionId) {\n\t                if (after.advice) {\n\t                    if (after.receiveArguments) {\n\t                        var newResults = after.advice.apply(this, args);\n\t                        results = newResults === undefined ? results : newResults;\n\t                    }\n\t                    else {\n\t                        results = after.advice.call(this, results, args);\n\t                    }\n\t                }\n\t                after = after.next;\n\t            }\n\t            return results;\n\t        };\n\t        if (isMapLike(target)) {\n\t            target.set(methodName, dispatcher);\n\t        }\n\t        else {\n\t            target && (target[methodName] = dispatcher);\n\t        }\n\t        if (existing) {\n\t            dispatcher.around = {\n\t                advice: function (target, args) {\n\t                    return existing.apply(target, args);\n\t                }\n\t            };\n\t        }\n\t        dispatcher.target = target;\n\t    }\n\t    else {\n\t        dispatcher = existing;\n\t    }\n\t    return dispatcher;\n\t}\n\t/**\n\t * Attaches \"after\" advice to be executed after the original method.\n\t * The advising function will receive the original method's return value and arguments object.\n\t * The value it returns will be returned from the method when it is called (even if the return value is undefined).\n\t *\n\t * @param target Object whose method will be aspected\n\t * @param methodName Name of method to aspect\n\t * @param advice Advising function which will receive the original method's return value and arguments object\n\t * @return A handle which will remove the aspect when destroy is called\n\t */\n\tfunction after(target, methodName, advice) {\n\t    return advise(getDispatcher(target, methodName), 'after', advice);\n\t}\n\texports.after = after;\n\t/**\n\t * Attaches \"around\" advice around the original method.\n\t *\n\t * @param target Object whose method will be aspected\n\t * @param methodName Name of method to aspect\n\t * @param advice Advising function which will receive the original function\n\t * @return A handle which will remove the aspect when destroy is called\n\t */\n\tfunction around(target, methodName, advice) {\n\t    var dispatcher = getDispatcher(target, methodName);\n\t    var previous = dispatcher.around;\n\t    var advised;\n\t    if (advice) {\n\t        advised = advice(function () {\n\t            if (previous && previous.advice) {\n\t                return previous.advice(this, arguments);\n\t            }\n\t        });\n\t    }\n\t    dispatcher.around = {\n\t        advice: function (target, args) {\n\t            return advised ? advised.apply(target, args) : previous && previous.advice && previous.advice(target, args);\n\t        }\n\t    };\n\t    return lang_1.createHandle(function () {\n\t        advised = dispatcher = undefined;\n\t    });\n\t}\n\texports.around = around;\n\t/**\n\t * Attaches \"before\" advice to be executed before the original method.\n\t *\n\t * @param target Object whose method will be aspected\n\t * @param methodName Name of method to aspect\n\t * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n\t * @return A handle which will remove the aspect when destroy is called\n\t */\n\tfunction before(target, methodName, advice) {\n\t    return advise(getDispatcher(target, methodName), 'before', advice);\n\t}\n\texports.before = before;\n\t/**\n\t * Attaches advice to be executed after the original method.\n\t * The advising function will receive the same arguments as the original method.\n\t * The value it returns will be returned from the method when it is called *unless* its return value is undefined.\n\t *\n\t * @param target Object whose method will be aspected\n\t * @param methodName Name of method to aspect\n\t * @param advice Advising function which will receive the same arguments as the original method\n\t * @return A handle which will remove the aspect when destroy is called\n\t */\n\tfunction on(target, methodName, advice) {\n\t    return advise(getDispatcher(target, methodName), 'after', advice, true);\n\t}\n\texports.on = on;\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar decorators_1 = __webpack_require__(23);\n\tvar global_1 = __webpack_require__(12);\n\tvar iterator_1 = __webpack_require__(18);\n\tvar object_1 = __webpack_require__(30);\n\t__webpack_require__(20);\n\tvar Shim;\n\t(function (Shim) {\n\t    /**\n\t     * An implementation analogous to the Map specification in ES2015.\n\t     */\n\t    var Map = (function () {\n\t        /**\n\t         * Creates a new Map\n\t         *\n\t         * @constructor\n\t         *\n\t         * @param iterator\n\t         * Array or iterator containing two-item tuples used to initially populate the map.\n\t         * The first item in each tuple corresponds to the key of the map entry.\n\t         * The second item corresponds to the value of the map entry.\n\t         */\n\t        function Map(iterable) {\n\t            var _this = this;\n\t            this._keys = [];\n\t            this._values = [];\n\t            this[Symbol.toStringTag] = 'Map';\n\t            if (iterable) {\n\t                iterator_1.forOf(iterable, function (value) {\n\t                    _this.set(value[0], value[1]);\n\t                });\n\t            }\n\t        }\n\t        /**\n\t         * An alternative to Array.prototype.indexOf using Object.is\n\t         * to check for equality. See http://mzl.la/1zuKO2V\n\t         */\n\t        Map.prototype._indexOfKey = function (keys, key) {\n\t            for (var i = 0, length_1 = keys.length; i < length_1; i++) {\n\t                if (object_1.is(keys[i], key)) {\n\t                    return i;\n\t                }\n\t            }\n\t            return -1;\n\t        };\n\t        Object.defineProperty(Map.prototype, \"size\", {\n\t            /**\n\t             * Returns the number of key / value pairs in the Map.\n\t             *\n\t             * @return the number of key / value pairs in the Map\n\t             */\n\t            get: function () {\n\t                return this._keys.length;\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * Deletes all keys and their associated values.\n\t         */\n\t        Map.prototype.clear = function () {\n\t            this._keys.length = this._values.length = 0;\n\t        };\n\t        /**\n\t         * Deletes a given key and its associated value.\n\t         *\n\t         * @param key The key to delete\n\t         * @return true if the key exists, false if it does not\n\t         */\n\t        Map.prototype.delete = function (key) {\n\t            var index = this._indexOfKey(this._keys, key);\n\t            if (index < 0) {\n\t                return false;\n\t            }\n\t            this._keys.splice(index, 1);\n\t            this._values.splice(index, 1);\n\t            return true;\n\t        };\n\t        /**\n\t         * Returns an iterator that yields each key/value pair as an array.\n\t         *\n\t         * @return An iterator for each key/value pair in the instance.\n\t         */\n\t        Map.prototype.entries = function () {\n\t            var _this = this;\n\t            var values = this._keys.map(function (key, i) {\n\t                return [key, _this._values[i]];\n\t            });\n\t            return new iterator_1.ShimIterator(values);\n\t        };\n\t        /**\n\t         * Executes a given function for each map entry. The function\n\t         * is invoked with three arguments: the element value, the\n\t         * element key, and the associated Map instance.\n\t         *\n\t         * @param callback The function to execute for each map entry,\n\t         * @param context The value to use for `this` for each execution of the calback\n\t         */\n\t        Map.prototype.forEach = function (callback, context) {\n\t            var keys = this._keys;\n\t            var values = this._values;\n\t            for (var i = 0, length_2 = keys.length; i < length_2; i++) {\n\t                callback.call(context, values[i], keys[i], this);\n\t            }\n\t        };\n\t        /**\n\t         * Returns the value associated with a given key.\n\t         *\n\t         * @param key The key to look up\n\t         * @return The value if one exists or undefined\n\t         */\n\t        Map.prototype.get = function (key) {\n\t            var index = this._indexOfKey(this._keys, key);\n\t            return index < 0 ? undefined : this._values[index];\n\t        };\n\t        /**\n\t         * Checks for the presence of a given key.\n\t         *\n\t         * @param key The key to check for\n\t         * @return true if the key exists, false if it does not\n\t         */\n\t        Map.prototype.has = function (key) {\n\t            return this._indexOfKey(this._keys, key) > -1;\n\t        };\n\t        /**\n\t         * Returns an iterator that yields each key in the map.\n\t         *\n\t         * @return An iterator containing the instance's keys.\n\t         */\n\t        Map.prototype.keys = function () {\n\t            return new iterator_1.ShimIterator(this._keys);\n\t        };\n\t        /**\n\t         * Sets the value associated with a given key.\n\t         *\n\t         * @param key The key to define a value to\n\t         * @param value The value to assign\n\t         * @return The Map instance\n\t         */\n\t        Map.prototype.set = function (key, value) {\n\t            var index = this._indexOfKey(this._keys, key);\n\t            index = index < 0 ? this._keys.length : index;\n\t            this._keys[index] = key;\n\t            this._values[index] = value;\n\t            return this;\n\t        };\n\t        /**\n\t         * Returns an iterator that yields each value in the map.\n\t         *\n\t         * @return An iterator containing the instance's values.\n\t         */\n\t        Map.prototype.values = function () {\n\t            return new iterator_1.ShimIterator(this._values);\n\t        };\n\t        Map.prototype[Symbol.iterator] = function () {\n\t            return this.entries();\n\t        };\n\t        return Map;\n\t    }());\n\t    Shim.Map = Map;\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\tvar Map = (function () {\n\t    /* istanbul ignore next */\n\t    function Map(iterable) {\n\t        /* istanbul ignore next */\n\t        this[Symbol.toStringTag] = 'Map';\n\t    }\n\t    ;\n\t    Object.defineProperty(Map.prototype, \"size\", {\n\t        /* istanbul ignore next */\n\t        get: function () { throw new Error('Abstract method'); },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.clear = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.delete = function (key) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.entries = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.forEach = function (callback, context) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.get = function (key) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.has = function (key) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.keys = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.set = function (key, value) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype.values = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Map.prototype[Symbol.iterator] = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    return Map;\n\t}());\n\tMap = __decorate([\n\t    decorators_1.hasClass('es6-map', global_1.default.Map, Shim.Map)\n\t], Map);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Map;\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar has_1 = __webpack_require__(11);\n\tvar Symbol_1 = __webpack_require__(20);\n\tvar Shim;\n\t(function (Shim) {\n\t    function is(value1, value2) {\n\t        if (value1 === value2) {\n\t            return value1 !== 0 || 1 / value1 === 1 / value2; // -0\n\t        }\n\t        return value1 !== value1 && value2 !== value2; // NaN\n\t    }\n\t    Shim.is = is;\n\t    function getOwnPropertySymbols(o) {\n\t        return Object.getOwnPropertyNames(o).filter(function (key) { return Boolean(key.match(/^@@.+/)); })\n\t            .map(function (key) { return Symbol.for(key.substring(2)); });\n\t    }\n\t    Shim.getOwnPropertySymbols = getOwnPropertySymbols;\n\t    function getOwnPropertyNames(o) {\n\t        return Object.getOwnPropertyNames(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });\n\t    }\n\t    Shim.getOwnPropertyNames = getOwnPropertyNames;\n\t    function symbolAwareKeys(o) {\n\t        return Object.keys(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });\n\t    }\n\t    Shim.symbolAwareKeys = symbolAwareKeys;\n\t    function getOwnPropertyDescriptor(o, prop) {\n\t        if (Symbol_1.isSymbol(prop)) {\n\t            return Object.getOwnPropertyDescriptor(o, prop);\n\t        }\n\t        else {\n\t            return Object.getOwnPropertyDescriptor(o, prop);\n\t        }\n\t    }\n\t    Shim.getOwnPropertyDescriptor = getOwnPropertyDescriptor;\n\t    function values(o) {\n\t        return exports.keys(o).map(function (key) { return o[key]; });\n\t    }\n\t    Shim.values = values;\n\t    function entries(o) {\n\t        return exports.keys(o).map(function (key) { return [key, o[key]]; });\n\t    }\n\t    Shim.entries = entries;\n\t})(Shim || (Shim = {}));\n\t/**\n\t * Determines whether two values are the same value.\n\t *\n\t * @param value1 The first value to compare\n\t * @param value2 The second value to compare\n\t * @return true if the values are the same; false otherwise\n\t */\n\texports.is = 'is' in Object\n\t    ? Object.is\n\t    : Shim.is;\n\t/**\n\t * Detect if there is native support for Symbol properties in Object\n\t */\n\tvar hasGetOwnPropertySymbols = has_1.default('es6-symbol') && 'getOwnPropertySymbols' in Object;\n\t/**\n\t * Returns an array of own properties who key is a symbol\n\t *\n\t * @param o The object to return the properties for\n\t */\n\texports.getOwnPropertySymbols = hasGetOwnPropertySymbols\n\t    ? Object.getOwnPropertySymbols\n\t    : Shim.getOwnPropertySymbols;\n\t/**\n\t * Returns an array of own properties who key is a string\n\t *\n\t * @param o The object to return the properties for\n\t */\n\t/* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n\t * when there is no support for symbols */\n\texports.getOwnPropertyNames = hasGetOwnPropertySymbols\n\t    ? Object.getOwnPropertyNames\n\t    : Shim.getOwnPropertyNames;\n\t/**\n\t * Returns the names of the enumerable properties and methods of an object.\n\t * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n\t */\n\t/* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n\t * when there is no support for symbols */\n\texports.keys = hasGetOwnPropertySymbols\n\t    ? Object.keys\n\t    : Shim.symbolAwareKeys;\n\t/**\n\t * Returns the values of the enumerable properties and methods of an object.\n\t * @param o Object that contains the properties and methods.\n\t */\n\texports.values = 'values' in Object\n\t    ? Object.values\n\t    : Shim.values;\n\t/**\n\t * Returns the keys and values of the enumerable properties and methods of an object. Each entry will be returned as an\n\t * array holding the [key, value].\n\t * @param o Object that contains the properties and methods.\n\t */\n\texports.entries = 'entries' in Object\n\t    ? Object.entries\n\t    : Shim.entries;\n\texports.getOwnPropertyDescriptor = hasGetOwnPropertySymbols\n\t    ? Object.getOwnPropertyDescriptor\n\t    : Shim.getOwnPropertyDescriptor;\n\tfunction getOwnPropertyDescriptorsWrapper(o) {\n\t    var descriptors = exports.getOwnPropertyNames(o).reduce(function (descriptors, key) {\n\t        descriptors[key] = exports.getOwnPropertyDescriptor(o, key);\n\t        return descriptors;\n\t    }, {});\n\t    exports.getOwnPropertySymbols(o).forEach(function (sym) {\n\t        descriptors[sym] = exports.getOwnPropertyDescriptor(o, sym);\n\t    });\n\t    return descriptors;\n\t}\n\t/* Return descriptors for enumerable and non enumerable properties on an object */\n\texports.getOwnPropertyDescriptors = 'getOwnPropertyDescriptors' in Object\n\t    ? Object.getOwnPropertyDescriptors\n\t    : getOwnPropertyDescriptorsWrapper;\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Promise_1 = __webpack_require__(32);\n\tvar WeakMap_1 = __webpack_require__(22);\n\tvar compose_1 = __webpack_require__(7);\n\t/**\n\t * A reference to a function that always returns a promise which resolves to false\n\t */\n\tfunction noop() {\n\t    return Promise_1.default.resolve(false);\n\t}\n\t/**\n\t * A reference to a function that throws, used to replace the `own()` method after\n\t * destruction\n\t */\n\tfunction destroyed() {\n\t    throw new Error('Call made to destroyed method');\n\t}\n\t/**\n\t * A weak map for *owning* handles on instances\n\t */\n\tvar handlesWeakMap = new WeakMap_1.default();\n\t/**\n\t * A type guard that determines if the value is a Destroyable\n\t *\n\t * @param value The value to guard for\n\t */\n\tfunction isDestroyable(value) {\n\t    return Boolean(value && 'destroy' in value && typeof value.destroy === 'function');\n\t}\n\texports.isDestroyable = isDestroyable;\n\t/**\n\t * A mixin which adds the concepts of being able to *destroy* handles which the instance\n\t * *owns*\n\t */\n\tvar createDestroyable = compose_1.default('Destroyable', {\n\t    own: function (handle) {\n\t        var handles = handlesWeakMap.get(this);\n\t        handles.push(handle);\n\t        return {\n\t            destroy: function () {\n\t                handles.splice(handles.indexOf(handle));\n\t                handle.destroy();\n\t            }\n\t        };\n\t    },\n\t    destroy: function () {\n\t        var _this = this;\n\t        return new Promise_1.default(function (resolve) {\n\t            handlesWeakMap.get(_this).forEach(function (handle) {\n\t                handle && handle.destroy && handle.destroy();\n\t            });\n\t            _this.destroy = noop;\n\t            _this.own = destroyed;\n\t            resolve(true);\n\t        });\n\t    }\n\t}, function (instance) {\n\t    handlesWeakMap.set(instance, []);\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createDestroyable;\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar global_1 = __webpack_require__(12);\n\tvar queue_1 = __webpack_require__(33);\n\tvar iterator_1 = __webpack_require__(18);\n\t__webpack_require__(20);\n\tvar decorators_1 = __webpack_require__(23);\n\tvar Shim;\n\t(function (Shim) {\n\t    /**\n\t     * Returns true if a given value has a `then` method.\n\t     * @param {any} value The value to check if is Thenable\n\t     * @returns {is Thenable<T>} A type guard if the value is thenable\n\t     */\n\t    function isThenable(value) {\n\t        return value && typeof value.then === 'function';\n\t    }\n\t    Shim.isThenable = isThenable;\n\t    /**\n\t     * Promise is a partial implementation of the ES2015 Promise specification. It relies on Promise to do some safety\n\t     * checks such as verifying that a Promise isn't resolved with itself. This class is exported for testability, and is\n\t     * not intended to be used directly.\n\t     *\n\t     * @borrows Promise.all as Promise.all\n\t     * @borrows Promise.race as Promise.race\n\t     * @borrows Promise.reject as Promise.reject\n\t     * @borrows Promise.resolve as Promise.resolve\n\t     * @borrows Promise#catch as Promise#catch\n\t     * @borrows Promise#then as Promise#then\n\t     */\n\t    var Promise = (function () {\n\t        /**\n\t         * Creates a new Promise.\n\t         *\n\t         * @constructor\n\t         *\n\t         * @param executor\n\t         * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t         * starting the asynchronous operation when it is invoked.\n\t         *\n\t         * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t         * successfully, or the `reject` function when the operation fails.\n\t         */\n\t        function Promise(executor) {\n\t            var _this = this;\n\t            /**\n\t             * The current state of this promise.\n\t             */\n\t            this.state = 1 /* Pending */;\n\t            this[Symbol.toStringTag] = 'Promise';\n\t            /**\n\t             * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n\t             */\n\t            var isChained = false;\n\t            /**\n\t             * Whether or not this promise is in a resolved state.\n\t             */\n\t            var isResolved = function () {\n\t                return _this.state !== 1 /* Pending */ || isChained;\n\t            };\n\t            /**\n\t             * Callbacks that should be invoked once the asynchronous operation has completed.\n\t             */\n\t            var callbacks = [];\n\t            /**\n\t             * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n\t             * enqueues callbacks for execution on the next event loop turn.\n\t             */\n\t            var whenFinished = function (callback) {\n\t                if (callbacks) {\n\t                    callbacks.push(callback);\n\t                }\n\t            };\n\t            /**\n\t             * Settles this promise.\n\t             *\n\t             * @param newState The resolved state for this promise.\n\t             * @param {T|any} value The resolved value for this promise.\n\t             */\n\t            var settle = function (newState, value) {\n\t                // A promise can only be settled once.\n\t                if (_this.state !== 1 /* Pending */) {\n\t                    return;\n\t                }\n\t                _this.state = newState;\n\t                _this.resolvedValue = value;\n\t                whenFinished = queue_1.queueMicroTask;\n\t                // Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n\t                // wait an extra turn.\n\t                if (callbacks && callbacks.length > 0) {\n\t                    queue_1.queueMicroTask(function () {\n\t                        if (callbacks) {\n\t                            var count = callbacks.length;\n\t                            for (var i = 0; i < count; ++i) {\n\t                                callbacks[i].call(null);\n\t                            }\n\t                            callbacks = null;\n\t                        }\n\t                    });\n\t                }\n\t            };\n\t            /**\n\t             * Resolves this promise.\n\t             *\n\t             * @param newState The resolved state for this promise.\n\t             * @param {T|any} value The resolved value for this promise.\n\t             */\n\t            var resolve = function (newState, value) {\n\t                if (isResolved()) {\n\t                    return;\n\t                }\n\t                if (isThenable(value)) {\n\t                    value.then(settle.bind(null, 0 /* Fulfilled */), settle.bind(null, 2 /* Rejected */));\n\t                    isChained = true;\n\t                }\n\t                else {\n\t                    settle(newState, value);\n\t                }\n\t            };\n\t            this.then = function (onFulfilled, onRejected) {\n\t                return new Promise(function (resolve, reject) {\n\t                    // whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n\t                    // promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n\t                    // event loop.\n\t                    whenFinished(function () {\n\t                        var callback = _this.state === 2 /* Rejected */ ? onRejected : onFulfilled;\n\t                        if (typeof callback === 'function') {\n\t                            try {\n\t                                resolve(callback(_this.resolvedValue));\n\t                            }\n\t                            catch (error) {\n\t                                reject(error);\n\t                            }\n\t                        }\n\t                        else if (_this.state === 2 /* Rejected */) {\n\t                            reject(_this.resolvedValue);\n\t                        }\n\t                        else {\n\t                            resolve(_this.resolvedValue);\n\t                        }\n\t                    });\n\t                });\n\t            };\n\t            try {\n\t                executor(resolve.bind(null, 0 /* Fulfilled */), resolve.bind(null, 2 /* Rejected */));\n\t            }\n\t            catch (error) {\n\t                settle(2 /* Rejected */, error);\n\t            }\n\t        }\n\t        Promise.all = function (iterable) {\n\t            return new this(function (resolve, reject) {\n\t                var values = [];\n\t                var complete = 0;\n\t                var total = 0;\n\t                var populating = true;\n\t                function fulfill(index, value) {\n\t                    values[index] = value;\n\t                    ++complete;\n\t                    finish();\n\t                }\n\t                function finish() {\n\t                    if (populating || complete < total) {\n\t                        return;\n\t                    }\n\t                    resolve(values);\n\t                }\n\t                function processItem(index, item) {\n\t                    ++total;\n\t                    if (isThenable(item)) {\n\t                        // If an item Promise rejects, this Promise is immediately rejected with the item\n\t                        // Promise's rejection error.\n\t                        item.then(fulfill.bind(null, index), reject);\n\t                    }\n\t                    else {\n\t                        Promise.resolve(item).then(fulfill.bind(null, index));\n\t                    }\n\t                }\n\t                var i = 0;\n\t                iterator_1.forOf(iterable, function (value) {\n\t                    processItem(i, value);\n\t                    i++;\n\t                });\n\t                populating = false;\n\t                finish();\n\t            });\n\t        };\n\t        Promise.race = function (iterable) {\n\t            return new this(function (resolve, reject) {\n\t                iterator_1.forOf(iterable, function (item) {\n\t                    if (item instanceof Promise) {\n\t                        // If a Promise item rejects, this Promise is immediately rejected with the item\n\t                        // Promise's rejection error.\n\t                        item.then(resolve, reject);\n\t                    }\n\t                    else {\n\t                        Promise.resolve(item).then(resolve);\n\t                    }\n\t                });\n\t            });\n\t        };\n\t        Promise.reject = function (reason) {\n\t            return new this(function (resolve, reject) {\n\t                reject(reason);\n\t            });\n\t        };\n\t        Promise.resolve = function (value) {\n\t            return new this(function (resolve) {\n\t                resolve(value);\n\t            });\n\t        };\n\t        Promise.prototype.catch = function (onRejected) {\n\t            return this.then(undefined, onRejected);\n\t        };\n\t        return Promise;\n\t    }());\n\t    Shim.Promise = Promise;\n\t})(Shim || (Shim = {}));\n\tvar Promise = (function () {\n\t    /**\n\t     * Creates a new Promise.\n\t     *\n\t     * @constructor\n\t     *\n\t     * @param executor\n\t     * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t     * starting the asynchronous operation when it is invoked.\n\t     *\n\t     * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t     * successfully, or the `reject` function when the operation fails.\n\t     */\n\t    /* istanbul ignore next */\n\t    function Promise(executor) {\n\t    }\n\t    /**\n\t     * Converts an iterable object containing promises into a single promise that resolves to a new iterable object\n\t     * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the\n\t     * iterable. Iterable values that are not promises are converted to promises using Promise.resolve.\n\t     *\n\t     * @example\n\t     * Promise.all([ Promise.resolve('foo'), 'bar' ]).then(function (value) {\n\t     *     value[0] === 'foo'; // true\n\t     *     value[1] === 'bar'; // true\n\t     * });\n\t     *\n\t     * @example\n\t     * Promise.all({\n\t     *     foo: Promise.resolve('foo'),\n\t     *     bar: 'bar'\n\t     * }).then((value) => {\n\t     *     value.foo === 'foo'; // true\n\t     *     value.bar === 'bar'; // true\n\t     * });\n\t     */\n\t    /* istanbul ignore next */\n\t    Promise.all = function (iterable) {\n\t        throw new Error();\n\t    };\n\t    ;\n\t    /**\n\t     * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of\n\t     * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in\n\t     * the iterable that are not Promises are converted to Promises with Promise.resolve.\n\t     *\n\t     * @example\n\t     * Promise.race([ Promise.resolve('foo'), Promise.resolve('bar') ]).then((value) => {\n\t     *     value === 'foo'; // true\n\t     * });\n\t     *\n\t     * @example\n\t     * Promise.race({\n\t     *     foo: Promise.resolve('foo'),\n\t     *     bar: Promise.resolve('bar')\n\t     * }).then((value) => {\n\t     *     value === 'foo'; // true\n\t     * });\n\t     */\n\t    /* istanbul ignore next */\n\t    Promise.race = function (iterable) {\n\t        throw new Error();\n\t    };\n\t    /**\n\t     * Creates a new promise that is rejected with the given error.\n\t     */\n\t    /* istanbul ignore next */\n\t    Promise.reject = function (reason) {\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    Promise.resolve = function (value) {\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    Promise.prototype.catch = function (onRejected) {\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    Promise.prototype.then = function (onFulfilled, onRejected) {\n\t        throw new Error();\n\t    };\n\t    return Promise;\n\t}());\n\tPromise = __decorate([\n\t    decorators_1.hasClass('es6-promise', global_1.default.Promise, Shim.Promise)\n\t], Promise);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Promise;\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(clearImmediate, setImmediate, process) {\"use strict\";\n\tvar global_1 = __webpack_require__(12);\n\tvar has_1 = __webpack_require__(11);\n\t/**\n\t * Executes a task\n\t * @param item The task to execute\n\t */\n\tfunction executeTask(item) {\n\t    if (item && item.isActive) {\n\t        item.callback();\n\t    }\n\t}\n\t/**\n\t * Get a handle to be able to remove an item from the queue\n\t */\n\tfunction getQueueHandle(item, destructor) {\n\t    return {\n\t        destroy: function () {\n\t            this.destroy = function () { };\n\t            if (item) {\n\t                item.isActive = false;\n\t            }\n\t            if (destructor) {\n\t                destructor();\n\t            }\n\t        }\n\t    };\n\t}\n\tvar microTasks = [];\n\tvar microTaskQueued = false;\n\tvar checkMicroTaskQueue = function () { };\n\t/**\n\t * Schedules a callback to the macrotask queue.\n\t *\n\t * @param callback the function to be queued and later executed.\n\t * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n\t */\n\texports.queueTask = (function () {\n\t    var destructor;\n\t    var enqueue;\n\t    /* IE and Edge's setImmediate does not always resolve as a macro task, sometimes as a microtask */\n\t    if (has_1.default('postmessage')) {\n\t        var queue_1 = [];\n\t        addEventListener('message', function (event) {\n\t            // Confirm that the event was triggered by the current window and by this particular implementation.\n\t            if (event.source === global_1.default && event.data === 'dojo-queue-message') {\n\t                event.stopPropagation();\n\t                if (queue_1.length) {\n\t                    executeTask(queue_1.shift());\n\t                }\n\t            }\n\t        });\n\t        enqueue = function (item) {\n\t            queue_1.push(item);\n\t            postMessage('dojo-queue-message', '*');\n\t        };\n\t    }\n\t    else if (has_1.default('setimmediate')) {\n\t        destructor = clearImmediate;\n\t        enqueue = function (item) {\n\t            return setImmediate(executeTask.bind(null, item));\n\t        };\n\t    }\n\t    else {\n\t        destructor = clearTimeout;\n\t        enqueue = function (item) {\n\t            return setTimeout(executeTask.bind(null, item), 0);\n\t        };\n\t    }\n\t    function queueTask(callback) {\n\t        var item = {\n\t            isActive: true,\n\t            callback: callback\n\t        };\n\t        var id = enqueue(item);\n\t        return getQueueHandle(item, destructor && function () {\n\t            destructor(id);\n\t        });\n\t    }\n\t    ;\n\t    // TODO: Use aspect.before when it is available.\n\t    return has_1.default('microtasks') ? queueTask : function (callback) {\n\t        checkMicroTaskQueue();\n\t        return queueTask(callback);\n\t    };\n\t})();\n\tcheckMicroTaskQueue = !has_1.default('microtasks')\n\t    ? function () {\n\t        if (!microTaskQueued) {\n\t            microTaskQueued = true;\n\t            exports.queueTask(function () {\n\t                microTaskQueued = false;\n\t                if (microTasks.length) {\n\t                    var item = void 0;\n\t                    while (item = microTasks.shift()) {\n\t                        executeTask(item);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t    } : checkMicroTaskQueue;\n\t/**\n\t * Schedules a callback to the microtask queue.\n\t *\n\t * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native\n\t * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask\n\t * registered with `queueTask` or `queueAnimationTask`.\n\t *\n\t * @param callback the function to be queued and later executed.\n\t * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n\t */\n\texports.queueMicroTask = (function () {\n\t    var enqueue;\n\t    if (has_1.default('host-node')) {\n\t        enqueue = function (item) {\n\t            process.nextTick(executeTask.bind(null, item));\n\t        };\n\t    }\n\t    else if (has_1.default('es6-promise') && !has_1.default('setimmediate') && !has_1.default('host-node')) {\n\t        enqueue = function (item) {\n\t            global_1.default.Promise.resolve(item).then(executeTask);\n\t        };\n\t    }\n\t    else if (has_1.default('dom-mutationobserver')) {\n\t        /* tslint:disable-next-line:variable-name */\n\t        var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;\n\t        var node_1 = document.createElement('div');\n\t        var queue_2 = [];\n\t        var observer = new HostMutationObserver(function () {\n\t            while (queue_2.length > 0) {\n\t                var item = queue_2.shift();\n\t                if (item && item.isActive) {\n\t                    item.callback();\n\t                }\n\t            }\n\t        });\n\t        observer.observe(node_1, { attributes: true });\n\t        enqueue = function (item) {\n\t            queue_2.push(item);\n\t            node_1.setAttribute('queueStatus', '1');\n\t        };\n\t    }\n\t    else {\n\t        enqueue = function (item) {\n\t            checkMicroTaskQueue();\n\t            microTasks.push(item);\n\t        };\n\t    }\n\t    return function (callback) {\n\t        var item = {\n\t            isActive: true,\n\t            callback: callback\n\t        };\n\t        enqueue(item);\n\t        return getQueueHandle(item);\n\t    };\n\t})();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34).clearImmediate, __webpack_require__(34).setImmediate, __webpack_require__(14)))\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar apply = Function.prototype.apply;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) {\n\t  if (timeout) {\n\t    timeout.close();\n\t  }\n\t};\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// setimmediate attaches itself to the global object\n\t__webpack_require__(35);\n\texports.setImmediate = setImmediate;\n\texports.clearImmediate = clearImmediate;\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n\t    \"use strict\";\n\t\n\t    if (global.setImmediate) {\n\t        return;\n\t    }\n\t\n\t    var nextHandle = 1; // Spec says greater than zero\n\t    var tasksByHandle = {};\n\t    var currentlyRunningATask = false;\n\t    var doc = global.document;\n\t    var registerImmediate;\n\t\n\t    function setImmediate(callback) {\n\t      // Callback can either be a function or a string\n\t      if (typeof callback !== \"function\") {\n\t        callback = new Function(\"\" + callback);\n\t      }\n\t      // Copy function arguments\n\t      var args = new Array(arguments.length - 1);\n\t      for (var i = 0; i < args.length; i++) {\n\t          args[i] = arguments[i + 1];\n\t      }\n\t      // Store and register the task\n\t      var task = { callback: callback, args: args };\n\t      tasksByHandle[nextHandle] = task;\n\t      registerImmediate(nextHandle);\n\t      return nextHandle++;\n\t    }\n\t\n\t    function clearImmediate(handle) {\n\t        delete tasksByHandle[handle];\n\t    }\n\t\n\t    function run(task) {\n\t        var callback = task.callback;\n\t        var args = task.args;\n\t        switch (args.length) {\n\t        case 0:\n\t            callback();\n\t            break;\n\t        case 1:\n\t            callback(args[0]);\n\t            break;\n\t        case 2:\n\t            callback(args[0], args[1]);\n\t            break;\n\t        case 3:\n\t            callback(args[0], args[1], args[2]);\n\t            break;\n\t        default:\n\t            callback.apply(undefined, args);\n\t            break;\n\t        }\n\t    }\n\t\n\t    function runIfPresent(handle) {\n\t        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n\t        // So if we're currently running a task, we'll need to delay this invocation.\n\t        if (currentlyRunningATask) {\n\t            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n\t            // \"too much recursion\" error.\n\t            setTimeout(runIfPresent, 0, handle);\n\t        } else {\n\t            var task = tasksByHandle[handle];\n\t            if (task) {\n\t                currentlyRunningATask = true;\n\t                try {\n\t                    run(task);\n\t                } finally {\n\t                    clearImmediate(handle);\n\t                    currentlyRunningATask = false;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function installNextTickImplementation() {\n\t        registerImmediate = function(handle) {\n\t            process.nextTick(function () { runIfPresent(handle); });\n\t        };\n\t    }\n\t\n\t    function canUsePostMessage() {\n\t        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n\t        // where `global.postMessage` means something completely different and can't be used for this purpose.\n\t        if (global.postMessage && !global.importScripts) {\n\t            var postMessageIsAsynchronous = true;\n\t            var oldOnMessage = global.onmessage;\n\t            global.onmessage = function() {\n\t                postMessageIsAsynchronous = false;\n\t            };\n\t            global.postMessage(\"\", \"*\");\n\t            global.onmessage = oldOnMessage;\n\t            return postMessageIsAsynchronous;\n\t        }\n\t    }\n\t\n\t    function installPostMessageImplementation() {\n\t        // Installs an event handler on `global` for the `message` event: see\n\t        // * https://developer.mozilla.org/en/DOM/window.postMessage\n\t        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\t\n\t        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\t        var onGlobalMessage = function(event) {\n\t            if (event.source === global &&\n\t                typeof event.data === \"string\" &&\n\t                event.data.indexOf(messagePrefix) === 0) {\n\t                runIfPresent(+event.data.slice(messagePrefix.length));\n\t            }\n\t        };\n\t\n\t        if (global.addEventListener) {\n\t            global.addEventListener(\"message\", onGlobalMessage, false);\n\t        } else {\n\t            global.attachEvent(\"onmessage\", onGlobalMessage);\n\t        }\n\t\n\t        registerImmediate = function(handle) {\n\t            global.postMessage(messagePrefix + handle, \"*\");\n\t        };\n\t    }\n\t\n\t    function installMessageChannelImplementation() {\n\t        var channel = new MessageChannel();\n\t        channel.port1.onmessage = function(event) {\n\t            var handle = event.data;\n\t            runIfPresent(handle);\n\t        };\n\t\n\t        registerImmediate = function(handle) {\n\t            channel.port2.postMessage(handle);\n\t        };\n\t    }\n\t\n\t    function installReadyStateChangeImplementation() {\n\t        var html = doc.documentElement;\n\t        registerImmediate = function(handle) {\n\t            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t            var script = doc.createElement(\"script\");\n\t            script.onreadystatechange = function () {\n\t                runIfPresent(handle);\n\t                script.onreadystatechange = null;\n\t                html.removeChild(script);\n\t                script = null;\n\t            };\n\t            html.appendChild(script);\n\t        };\n\t    }\n\t\n\t    function installSetTimeoutImplementation() {\n\t        registerImmediate = function(handle) {\n\t            setTimeout(runIfPresent, 0, handle);\n\t        };\n\t    }\n\t\n\t    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\t    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n\t    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\t\n\t    // Don't get fooled by e.g. browserify environments.\n\t    if ({}.toString.call(global.process) === \"[object process]\") {\n\t        // For Node.js before 0.9\n\t        installNextTickImplementation();\n\t\n\t    } else if (canUsePostMessage()) {\n\t        // For non-IE10 modern browsers\n\t        installPostMessageImplementation();\n\t\n\t    } else if (global.MessageChannel) {\n\t        // For web workers, where supported\n\t        installMessageChannelImplementation();\n\t\n\t    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n\t        // For IE 68\n\t        installReadyStateChangeImplementation();\n\t\n\t    } else {\n\t        // For older browsers\n\t        installSetTimeoutImplementation();\n\t    }\n\t\n\t    attachTo.setImmediate = setImmediate;\n\t    attachTo.clearImmediate = clearImmediate;\n\t}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(14)))\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t\"use strict\";\n\tvar ExtensiblePromise_1 = __webpack_require__(37);\n\t/**\n\t * A type guard that determines if `value` is a `Task`\n\t * @param value The value to guard\n\t */\n\tfunction isTask(value) {\n\t    return Boolean(value && typeof value.cancel === 'function' && Array.isArray(value.children) && isThenable(value));\n\t}\n\texports.isTask = isTask;\n\t/**\n\t * Returns true if a given value has a `then` method.\n\t * @param {any} value The value to check if is Thenable\n\t * @returns {is Thenable<T>} A type guard if the value is thenable\n\t */\n\tfunction isThenable(value) {\n\t    return value && typeof value.then === 'function';\n\t}\n\texports.isThenable = isThenable;\n\t/**\n\t * Task is an extension of Promise that supports cancellation and the Task#finally method.\n\t */\n\tvar Task = (function (_super) {\n\t    __extends(Task, _super);\n\t    /**\n\t     * @constructor\n\t     *\n\t     * Create a new task. Executor is run immediately. The canceler will be called when the task is canceled.\n\t     *\n\t     * @param executor Method that initiates some task\n\t     * @param canceler Method to call when the task is canceled\n\t     *\n\t     */\n\t    function Task(executor, canceler) {\n\t        var _this = this;\n\t        // we have to initialize these to avoid a compiler error of using them before they are initialized\n\t        var superResolve = function () { };\n\t        var superReject = function () { };\n\t        _this = _super.call(this, function (resolve, reject) {\n\t            superResolve = resolve;\n\t            superReject = reject;\n\t        }) || this;\n\t        _this._state = 1 /* Pending */;\n\t        _this.children = [];\n\t        _this.canceler = function () {\n\t            if (canceler) {\n\t                canceler();\n\t            }\n\t            _this._cancel();\n\t        };\n\t        // Don't let the Task resolve if it's been canceled\n\t        try {\n\t            executor(function (value) {\n\t                if (_this._state === 3 /* Canceled */) {\n\t                    return;\n\t                }\n\t                _this._state = 0 /* Fulfilled */;\n\t                superResolve(value);\n\t            }, function (reason) {\n\t                if (_this._state === 3 /* Canceled */) {\n\t                    return;\n\t                }\n\t                _this._state = 2 /* Rejected */;\n\t                superReject(reason);\n\t            });\n\t        }\n\t        catch (reason) {\n\t            _this._state = 2 /* Rejected */;\n\t            superReject(reason);\n\t        }\n\t        return _this;\n\t    }\n\t    /**\n\t     * Return a Task that resolves when one of the passed in objects have resolved\n\t     *\n\t     * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t     * @returns {Task}\n\t     */\n\t    Task.race = function (iterable) {\n\t        return _super.race.call(this, iterable);\n\t    };\n\t    /**\n\t     * Return a rejected promise wrapped in a Task\n\t     *\n\t     * @param {Error?} reason    The reason for the rejection\n\t     * @returns {Task}\n\t     */\n\t    Task.reject = function (reason) {\n\t        return new this(function (resolve, reject) { return reject(reason); });\n\t    };\n\t    Task.resolve = function (value) {\n\t        return new this(function (resolve, reject) { return resolve(value); });\n\t    };\n\t    Task.all = function (iterable) {\n\t        return _super.all.call(this, iterable);\n\t    };\n\t    Object.defineProperty(Task.prototype, \"state\", {\n\t        get: function () {\n\t            return this._state;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    /**\n\t     * Propagates cancellation down through a Task tree. The Task's state is immediately set to canceled. If a Thenable\n\t     * finally task was passed in, it is resolved before calling this Task's finally callback; otherwise, this Task's\n\t     * finally callback is immediately executed. `_cancel` is called for each child Task, passing in the value returned\n\t     * by this Task's finally callback or a Promise chain that will eventually resolve to that value.\n\t     */\n\t    Task.prototype._cancel = function (finallyTask) {\n\t        var _this = this;\n\t        this._state = 3 /* Canceled */;\n\t        var runFinally = function () {\n\t            try {\n\t                return _this._finally();\n\t            }\n\t            catch (error) {\n\t            }\n\t        };\n\t        if (this._finally) {\n\t            if (isThenable(finallyTask)) {\n\t                finallyTask = finallyTask.then(runFinally, runFinally);\n\t            }\n\t            else {\n\t                finallyTask = runFinally();\n\t            }\n\t        }\n\t        this.children.forEach(function (child) {\n\t            child._cancel(finallyTask);\n\t        });\n\t    };\n\t    /**\n\t     * Immediately cancels this task if it has not already resolved. This Task and any descendants are synchronously set\n\t     * to the Canceled state and any `finally` added downstream from the canceled Task are invoked.\n\t     */\n\t    Task.prototype.cancel = function () {\n\t        if (this._state === 1 /* Pending */) {\n\t            this.canceler();\n\t        }\n\t    };\n\t    Task.prototype.catch = function (onRejected) {\n\t        return this.then(undefined, onRejected);\n\t    };\n\t    /**\n\t     * Allows for cleanup actions to be performed after resolution of a Promise.\n\t     */\n\t    Task.prototype.finally = function (callback) {\n\t        // if this task is already canceled, call the task\n\t        if (this._state === 3 /* Canceled */) {\n\t            return Task.resolve(callback());\n\t        }\n\t        var task = this.then(function (value) { return Task.resolve(callback()).then(function () { return value; }); }, function (reason) { return Task.resolve(callback()).then(function () {\n\t            throw reason;\n\t        }); });\n\t        // Keep a reference to the callback; it will be called if the Task is canceled\n\t        task._finally = callback;\n\t        return task;\n\t    };\n\t    Task.prototype.then = function (onFulfilled, onRejected) {\n\t        var _this = this;\n\t        // FIXME\n\t        // tslint:disable-next-line:no-var-keyword\n\t        var task = _super.prototype.then.call(this, \n\t        // Don't call the onFulfilled or onRejected handlers if this Task is canceled\n\t        function (value) {\n\t            if (task._state === 3 /* Canceled */) {\n\t                return;\n\t            }\n\t            if (onFulfilled) {\n\t                return onFulfilled(value);\n\t            }\n\t            return value;\n\t        }, function (error) {\n\t            if (task._state === 3 /* Canceled */) {\n\t                return;\n\t            }\n\t            if (onRejected) {\n\t                return onRejected(error);\n\t            }\n\t            throw error;\n\t        });\n\t        task.canceler = function () {\n\t            // If task's parent (this) hasn't been resolved, cancel it; downward propagation will start at the first\n\t            // unresolved parent\n\t            if (_this._state === 1 /* Pending */) {\n\t                _this.cancel();\n\t            }\n\t            else {\n\t                task._cancel();\n\t            }\n\t        };\n\t        // Keep track of child Tasks for propogating cancelation back down the chain\n\t        this.children.push(task);\n\t        return task;\n\t    };\n\t    return Task;\n\t}(ExtensiblePromise_1.default));\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Task;\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar iterator_1 = __webpack_require__(18);\n\tvar Promise_1 = __webpack_require__(32);\n\t/**\n\t * Take a list of values, and if any are ExtensiblePromise objects, insert the wrapped Promise in its place,\n\t * otherwise use the original object. We use this to help use the native Promise methods like `all` and `race`.\n\t *\n\t * @param iterable    The list of objects to iterate over\n\t * @returns {any[]}    The list of objects, as an array, with ExtensiblePromises being replaced by Promises.\n\t */\n\tfunction unwrapPromises(iterable) {\n\t    var unwrapped = [];\n\t    iterator_1.forOf(iterable, function (item) {\n\t        unwrapped.push(item instanceof ExtensiblePromise ? item._promise : item);\n\t    });\n\t    return unwrapped;\n\t}\n\t/**\n\t * An extensible base to allow Promises to be extended in ES5. This class basically wraps a native Promise object,\n\t * giving an API like a native promise.\n\t */\n\tvar ExtensiblePromise = (function () {\n\t    /**\n\t     * Creates a new extended Promise.\n\t     *\n\t     * @constructor\n\t     *\n\t     * @param executor\n\t     * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t     * starting the asynchronous operation when it is invoked.\n\t     *\n\t     * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t     * successfully, or the `reject` function when the operation fails.\n\t     */\n\t    function ExtensiblePromise(executor) {\n\t        this._promise = new Promise_1.default(executor);\n\t    }\n\t    /**\n\t     * Return a rejected promise wrapped in an ExtensiblePromise\n\t     *\n\t     * @param {Error?} reason    The reason for the rejection\n\t     * @returns {ExtensiblePromise}\n\t     */\n\t    ExtensiblePromise.reject = function (reason) {\n\t        return new this(function (resolve, reject) { return reject(reason); });\n\t    };\n\t    ExtensiblePromise.resolve = function (value) {\n\t        return new this(function (resolve, reject) { return resolve(value); });\n\t    };\n\t    ExtensiblePromise.all = function (iterable) {\n\t        if (!iterator_1.isArrayLike(iterable) && !iterator_1.isIterable(iterable)) {\n\t            var promiseKeys_1 = Object.keys(iterable);\n\t            return new this(function (resolve, reject) {\n\t                Promise_1.default.all(promiseKeys_1.map(function (key) { return iterable[key]; })).then(function (promiseResults) {\n\t                    var returnValue = {};\n\t                    promiseResults.forEach(function (value, index) {\n\t                        returnValue[promiseKeys_1[index]] = value;\n\t                    });\n\t                    resolve(returnValue);\n\t                }, reject);\n\t            });\n\t        }\n\t        return new this(function (resolve, reject) {\n\t            Promise_1.default.all(unwrapPromises(iterable)).then(resolve, reject);\n\t        });\n\t    };\n\t    /**\n\t     * Return a ExtensiblePromise that resolves when one of the passed in objects have resolved\n\t     *\n\t     * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t     * @returns {ExtensiblePromise}\n\t     */\n\t    ExtensiblePromise.race = function (iterable) {\n\t        return new this(function (resolve, reject) {\n\t            Promise_1.default.race(unwrapPromises(iterable)).then(resolve, reject);\n\t        });\n\t    };\n\t    ExtensiblePromise.prototype.catch = function (onRejected) {\n\t        return this.then(undefined, onRejected);\n\t    };\n\t    ExtensiblePromise.prototype.then = function (onFulfilled, onRejected) {\n\t        var _this = this;\n\t        var e = function (resolve, reject) {\n\t            function handler(rejected, valueOrError) {\n\t                var callback = rejected ? onRejected : onFulfilled;\n\t                if (typeof callback === 'function') {\n\t                    try {\n\t                        resolve(callback(valueOrError));\n\t                    }\n\t                    catch (error) {\n\t                        reject(error);\n\t                    }\n\t                }\n\t                else if (rejected) {\n\t                    reject(valueOrError);\n\t                }\n\t                else {\n\t                    resolve(valueOrError);\n\t                }\n\t            }\n\t            _this._promise.then(handler.bind(null, false), handler.bind(null, true));\n\t        };\n\t        return new this.constructor(e);\n\t    };\n\t    return ExtensiblePromise;\n\t}());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = ExtensiblePromise;\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(15);\n\tfunction emit(target, event) {\n\t    if (target.dispatchEvent &&\n\t        ((target.ownerDocument && target.ownerDocument.createEvent) ||\n\t            (target.document && target.document.createEvent) ||\n\t            target.createEvent) /* matches document */) {\n\t        var nativeEvent = (target.ownerDocument || target.document || target).createEvent('HTMLEvents');\n\t        nativeEvent.initEvent(event.type, Boolean(event.bubbles), Boolean(event.cancelable));\n\t        for (var key in event) {\n\t            if (!(key in nativeEvent)) {\n\t                nativeEvent[key] = event[key];\n\t            }\n\t        }\n\t        return target.dispatchEvent(nativeEvent);\n\t    }\n\t    if (target.emit) {\n\t        if (target.removeListener) {\n\t            // Node.js EventEmitter\n\t            target.emit(event.type, event);\n\t            return false;\n\t        }\n\t        else if (target.on) {\n\t            // Dojo Evented or similar\n\t            target.emit(event);\n\t            return false;\n\t        }\n\t    }\n\t    throw new Error('Target must be an event emitter');\n\t}\n\texports.emit = emit;\n\tfunction on(target, type, listener, capture) {\n\t    if (Array.isArray(type)) {\n\t        var handles = type.map(function (type) {\n\t            return on(target, type, listener, capture);\n\t        });\n\t        return lang_1.createCompositeHandle.apply(void 0, handles);\n\t    }\n\t    var callback = function () {\n\t        listener.apply(this, arguments);\n\t    };\n\t    // DOM EventTarget\n\t    if (target.addEventListener && target.removeEventListener) {\n\t        target.addEventListener(type, callback, capture);\n\t        return lang_1.createHandle(function () {\n\t            target.removeEventListener(type, callback, capture);\n\t        });\n\t    }\n\t    if (target.on) {\n\t        // EventEmitter\n\t        if (target.removeListener) {\n\t            target.on(type, callback);\n\t            return lang_1.createHandle(function () {\n\t                target.removeListener(type, callback);\n\t            });\n\t        }\n\t        else if (target.emit) {\n\t            return target.on(type, listener);\n\t        }\n\t    }\n\t    throw new TypeError('Unknown event emitter object');\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = on;\n\tfunction once(target, type, listener, capture) {\n\t    // FIXME\n\t    // tslint:disable-next-line:no-var-keyword\n\t    var handle = on(target, type, function () {\n\t        handle.destroy();\n\t        return listener.apply(this, arguments);\n\t    }, capture);\n\t    return handle;\n\t}\n\texports.once = once;\n\tfunction pausable(target, type, listener, capture) {\n\t    var paused;\n\t    var handle = on(target, type, function () {\n\t        if (!paused) {\n\t            return listener.apply(this, arguments);\n\t        }\n\t    }, capture);\n\t    handle.pause = function () {\n\t        paused = true;\n\t    };\n\t    handle.resume = function () {\n\t        paused = false;\n\t    };\n\t    return handle;\n\t}\n\texports.pausable = pausable;\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar UrlSearchParams_1 = __webpack_require__(25);\n\t/**\n\t * Parses a path\n\t * @param path The path to parse.\n\t * @return The search params, pathname segments, and whether it ended with a trailing slash.\n\t */\n\tfunction parse(path) {\n\t    var tokens = path.split(/([/?#])/).filter(Boolean);\n\t    var pathnameTokens = tokens;\n\t    var searchParams;\n\t    var searchStart = tokens.indexOf('?');\n\t    var hashStart = tokens.indexOf('#');\n\t    if (searchStart >= 0) {\n\t        if (hashStart >= 0) {\n\t            // Either `/foo?bar#baz` or `/foo#bar?baz`\n\t            pathnameTokens = tokens.slice(0, Math.min(searchStart, hashStart));\n\t            searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1, hashStart).join(''));\n\t        }\n\t        else {\n\t            // `/foo?bar`\n\t            pathnameTokens = tokens.slice(0, searchStart);\n\t            searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1).join(''));\n\t        }\n\t    }\n\t    else {\n\t        searchParams = new UrlSearchParams_1.default();\n\t        if (hashStart >= 0) {\n\t            // `/foo#bar`\n\t            pathnameTokens = tokens.slice(0, hashStart);\n\t        }\n\t    }\n\t    var segments = pathnameTokens.filter(function (t) { return t !== '/'; });\n\t    var trailingSlash = pathnameTokens[pathnameTokens.length - 1] === '/' && segments.length > 0;\n\t    return {\n\t        searchParams: searchParams,\n\t        segments: segments,\n\t        trailingSlash: trailingSlash\n\t    };\n\t}\n\texports.parse = parse;\n\t/**\n\t * Determines whether a DeconstructedPath is a (partial) match for given pathname segments.\n\t * @param expectedSegments Part of a DeconstructedPath object.\n\t * @param segments Pathname segments as returned by `parse()`\n\t * @return A result object.\n\t */\n\tfunction match(_a, segments) {\n\t    var expectedSegments = _a.expectedSegments;\n\t    if (expectedSegments.length === 0) {\n\t        return {\n\t            hasRemaining: segments.length > 0,\n\t            offset: 0,\n\t            values: []\n\t        };\n\t    }\n\t    if (expectedSegments.length > segments.length) {\n\t        return null;\n\t    }\n\t    var isMatch = true;\n\t    var values = [];\n\t    for (var i = 0; isMatch && i < expectedSegments.length; i++) {\n\t        var value = segments[i];\n\t        var expected = expectedSegments[i];\n\t        if (isNamedSegment(expected)) {\n\t            values.push(value);\n\t        }\n\t        else if (expected.literal !== value) {\n\t            isMatch = false;\n\t        }\n\t    }\n\t    if (!isMatch) {\n\t        return null;\n\t    }\n\t    return {\n\t        hasRemaining: expectedSegments.length < segments.length,\n\t        offset: expectedSegments.length,\n\t        values: values\n\t    };\n\t}\n\texports.match = match;\n\t/**\n\t * Determine whether the segment is a NamedSegment.\n\t *\n\t * @param segment The segment to be checked\n\t * @return true if the segment is a NamedSegment, false otherwise\n\t */\n\tfunction isNamedSegment(segment) {\n\t    return segment.name !== undefined;\n\t}\n\texports.isNamedSegment = isNamedSegment;\n\t/**\n\t * Deconstruct a route path into its constituent parts.\n\t * @param path The path to deconstruct.\n\t * @return An object describing the path's constituent parts.\n\t */\n\tfunction deconstruct(path) {\n\t    var expectedSegments = [];\n\t    var parameters = [];\n\t    var searchParameters = [];\n\t    var trailingSlash = false;\n\t    var tokens = path.split(/([/{}?&])/).filter(Boolean);\n\t    var leadingSlash = tokens[0] === '/';\n\t    var i = 0;\n\t    var consume = function () { return tokens[i++]; };\n\t    var peek = function () { return tokens[i]; };\n\t    var inSearchComponent = false;\n\t    while (i < tokens.length) {\n\t        var t = consume();\n\t        switch (t) {\n\t            case '{': {\n\t                var name_1 = consume();\n\t                if (!name_1 || name_1 === '}') {\n\t                    throw new TypeError('Parameter must have a name');\n\t                }\n\t                // Reserve : for future use, e.g. including type data in the parameter declaration.\n\t                if (name_1 === '{' || name_1 === '&' || /:/.test(name_1)) {\n\t                    throw new TypeError('Parameter name must not contain \\'{\\', \\'&\\' or \\':\\'');\n\t                }\n\t                if (parameters.indexOf(name_1) !== -1 || searchParameters.indexOf(name_1) !== -1) {\n\t                    throw new TypeError(\"Parameter must have a unique name, got '\" + name_1 + \"'\");\n\t                }\n\t                var closing = consume();\n\t                if (!closing || closing !== '}') {\n\t                    throw new TypeError(\"Parameter name must be followed by '}', got '\" + closing + \"'\");\n\t                }\n\t                var separator = peek();\n\t                if (separator) {\n\t                    if (inSearchComponent) {\n\t                        if (separator !== '&') {\n\t                            throw new TypeError(\"Search parameter must be followed by '&', got '\" + separator + \"'\");\n\t                        }\n\t                    }\n\t                    else if (separator !== '/' && separator !== '?') {\n\t                        throw new TypeError(\"Parameter must be followed by '/' or '?', got '\" + separator + \"'\");\n\t                    }\n\t                }\n\t                if (inSearchComponent) {\n\t                    searchParameters.push(name_1);\n\t                }\n\t                else {\n\t                    parameters.push(name_1);\n\t                    expectedSegments.push(Object.freeze({ name: name_1 }));\n\t                }\n\t                break;\n\t            }\n\t            case '?':\n\t            case '/':\n\t                if (inSearchComponent) {\n\t                    throw new TypeError(\"Expected parameter in search component, got '\" + t + \"'\");\n\t                }\n\t                if (t === '?') {\n\t                    inSearchComponent = true;\n\t                    if (expectedSegments.length === 0) {\n\t                        throw new TypeError('Path must contain at least one segment');\n\t                    }\n\t                }\n\t                if (t === '/') {\n\t                    var next_1 = peek();\n\t                    if (next_1 === '/') {\n\t                        throw new TypeError('Path segment must not be empty');\n\t                    }\n\t                    if (expectedSegments.length > 0 && (!next_1 || next_1 === '?')) {\n\t                        trailingSlash = true;\n\t                    }\n\t                }\n\t                break;\n\t            case '&':\n\t                if (!inSearchComponent) {\n\t                    throw new TypeError('Path segment must not contain \\'&\\'');\n\t                }\n\t                var next = peek();\n\t                if (next === '&') {\n\t                    throw new TypeError('Expected parameter in search component, got \\'&\\'');\n\t                }\n\t                break;\n\t            default:\n\t                if (inSearchComponent) {\n\t                    throw new TypeError(\"Expected parameter in search component, got '\" + t + \"'\");\n\t                }\n\t                expectedSegments.push(Object.freeze({ literal: t }));\n\t        }\n\t    }\n\t    return Object.freeze({\n\t        expectedSegments: Object.freeze(expectedSegments),\n\t        leadingSlash: leadingSlash,\n\t        parameters: Object.freeze(parameters),\n\t        searchParameters: Object.freeze(searchParameters),\n\t        trailingSlash: trailingSlash\n\t    });\n\t}\n\texports.deconstruct = deconstruct;\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(7);\n\tvar createEvented_1 = __webpack_require__(27);\n\tvar global_1 = __webpack_require__(10);\n\tvar on_1 = __webpack_require__(38);\n\tvar WeakMap_1 = __webpack_require__(22);\n\tvar privateStateMap = new WeakMap_1.default();\n\tvar createHashHistory = compose_1.default.mixin(createEvented_1.default, {\n\t    mixin: {\n\t        get current() {\n\t            return privateStateMap.get(this).current;\n\t        },\n\t        prefix: function (path) {\n\t            return \"#\" + path;\n\t        },\n\t        set: function (path) {\n\t            var privateState = privateStateMap.get(this);\n\t            if (privateState.current === path) {\n\t                return;\n\t            }\n\t            privateState.current = path;\n\t            privateState.browserLocation.hash = this.prefix(path);\n\t            this.emit({\n\t                type: 'change',\n\t                value: path\n\t            });\n\t        },\n\t        replace: function (path) {\n\t            var privateState = privateStateMap.get(this);\n\t            if (privateState.current === path) {\n\t                return;\n\t            }\n\t            privateState.current = path;\n\t            var _a = privateState.browserLocation, pathname = _a.pathname, search = _a.search;\n\t            privateState.browserLocation.replace(pathname + search + this.prefix(path));\n\t            this.emit({\n\t                type: 'change',\n\t                value: path\n\t            });\n\t        }\n\t    },\n\t    initialize: function (instance, _a) {\n\t        var window = (_a === void 0 ? { window: global_1.default } : _a).window;\n\t        var browserLocation = window.location;\n\t        var privateState = {\n\t            current: browserLocation.hash.slice(1),\n\t            browserLocation: browserLocation\n\t        };\n\t        privateStateMap.set(instance, privateState);\n\t        instance.own(on_1.default(window, 'hashchange', function () {\n\t            var path = browserLocation.hash.slice(1);\n\t            // Ignore hashchange for the current path. Guards against browsers firing hashchange when the history\n\t            // manager sets the hash.\n\t            if (path !== privateState.current) {\n\t                privateState.current = path;\n\t                instance.emit({\n\t                    type: 'change',\n\t                    value: path\n\t                });\n\t            }\n\t        }));\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createHashHistory;\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar widgetStore_1 = __webpack_require__(42);\n\tvar todoStore_1 = __webpack_require__(57);\n\texports.putTodo = function (_a) {\n\t    var _b = _a.afterAll, afterAll = _b === void 0 ? [] : _b;\n\t    var completedCount = afterAll.filter(function (_a) {\n\t        var completed = _a.completed;\n\t        return completed;\n\t    }).length;\n\t    var activeCount = afterAll.length - completedCount;\n\t    var allCompleted = afterAll.length === completedCount;\n\t    return widgetStore_1.default.patch({ id: 'todo-app', todos: afterAll, activeCount: activeCount, completedCount: completedCount, allCompleted: allCompleted });\n\t};\n\texports.setHierarchy = function (widgets) {\n\t    widgetStore_1.default.patch({ id: 'todo-app', widgets: widgets });\n\t};\n\texports.filterAndView = function (filter, view) {\n\t    var _a = this.state, _b = _a === void 0 ? {} : _a, _c = _b.activeView, activeView = _c === void 0 ? view : _c, _d = _b.activeFilter, activeFilter = _d === void 0 ? filter : _d;\n\t    widgetStore_1.default.patch({ id: 'todo-app', activeView: activeView, activeFilter: activeFilter });\n\t};\n\texports.showTodoDetails = function (todoId) {\n\t    return todoStore_1.default.get(todoId).then(function (todo) {\n\t        widgetStore_1.default.patch({ id: 'todo-details', todoDetails: todo }).then(function () {\n\t            exports.setHierarchy([['main', {}], ['todo-details', { id: 'todo-details', externalState: widgetStore_1.default }]]);\n\t        });\n\t    });\n\t};\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createObservableStore_1 = __webpack_require__(43);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createObservableStore_1.default({\n\t    data: [\n\t        {\n\t            id: 'todo-app',\n\t            todo: '',\n\t            todos: [],\n\t            completedCount: 0,\n\t            activeCount: 0,\n\t            activeFilter: 'all',\n\t            activeView: 'list',\n\t            search: '',\n\t            widgets: []\n\t        },\n\t        {\n\t            id: 'todo-details',\n\t            todoDetails: undefined\n\t        }\n\t    ]\n\t});\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createStore_1 = __webpack_require__(44);\n\tvar createObservableStoreMixin_1 = __webpack_require__(54);\n\tvar createObservableStore = createStore_1.default.mixin(createObservableStoreMixin_1.default());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createObservableStore;\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Promise_1 = __webpack_require__(32);\n\tvar WeakMap_1 = __webpack_require__(22);\n\tvar Map_1 = __webpack_require__(29);\n\tvar lang_1 = __webpack_require__(15);\n\tvar compose_1 = __webpack_require__(7);\n\tvar Observable_1 = __webpack_require__(45);\n\tvar createPatch_1 = __webpack_require__(47);\n\tvar createStoreObservable_1 = __webpack_require__(51);\n\tvar createInMemoryStorage_1 = __webpack_require__(52);\n\tvar instanceStateMap = new WeakMap_1.default();\n\tfunction isPatchArray(patches) {\n\t    return isPatch(patches[0]);\n\t}\n\tfunction isPatch(patchObj) {\n\t    var patch = patchObj && patchObj.patch;\n\t    var id = patchObj && patchObj.id;\n\t    return typeof id === 'string' && patch && Array.isArray(patch.operations) && typeof patch.apply === 'function' &&\n\t        typeof patch.toString === 'function';\n\t}\n\tfunction createStoreObservable(storeResultsPromise) {\n\t    return createStoreObservable_1.default(new Observable_1.Observable(function subscribe(observer) {\n\t        storeResultsPromise\n\t            .then(function (results) {\n\t            observer.next(results);\n\t            observer.complete();\n\t        }, function (error) {\n\t            observer.error(error);\n\t        });\n\t    }), function (results) {\n\t        return results.successfulData;\n\t    });\n\t}\n\tvar createStore = compose_1.default({\n\t    get: function (ids) {\n\t        var state = instanceStateMap.get(this);\n\t        return state.initialAddPromise.then(function () {\n\t            if (Array.isArray(ids)) {\n\t                return state.storage.get(ids).then(function (items) { return items.filter(function (item) { return Boolean(item); }); });\n\t            }\n\t            else {\n\t                return state.storage.get([ids]).then(function (items) { return items[0]; });\n\t            }\n\t        });\n\t    },\n\t    add: function (items, options) {\n\t        var self = this;\n\t        var state = instanceStateMap.get(self);\n\t        var storeResultsPromise = state.initialAddPromise.then(function () {\n\t            return state.storage.add(Array.isArray(items) ? items : [items], options);\n\t        });\n\t        return createStoreObservable(storeResultsPromise);\n\t    },\n\t    put: function (items, options) {\n\t        var self = this;\n\t        var state = instanceStateMap.get(self);\n\t        var storeResultsPromise = state.initialAddPromise.then(function () {\n\t            return state.storage.put(Array.isArray(items) ? items : [items], options);\n\t        });\n\t        return createStoreObservable(storeResultsPromise);\n\t    },\n\t    patch: function (updates, options) {\n\t        var self = this;\n\t        var state = instanceStateMap.get(self);\n\t        var patchEntries = [];\n\t        if (Array.isArray(updates)) {\n\t            if (isPatchArray(updates)) {\n\t                patchEntries = updates;\n\t            }\n\t            else {\n\t                patchEntries = self.identify(updates).map(function (id, index) {\n\t                    return { id: id, patch: createPatch_1.diff(updates[index]) };\n\t                });\n\t            }\n\t        }\n\t        else if (updates instanceof Map_1.default) {\n\t            updates.forEach(function (value, key) {\n\t                patchEntries.push({\n\t                    id: key,\n\t                    patch: value\n\t                });\n\t            });\n\t        }\n\t        else if (isPatch(updates)) {\n\t            patchEntries = [updates];\n\t        }\n\t        else {\n\t            var dupe = lang_1.duplicate(updates);\n\t            var idInOptions = (options && options.id);\n\t            var id = idInOptions || dupe.id;\n\t            if (!idInOptions) {\n\t                delete dupe.id;\n\t            }\n\t            patchEntries = [{ id: id, patch: createPatch_1.diff(dupe) }];\n\t        }\n\t        var storeResultsPromise = state.initialAddPromise.then(function () {\n\t            return state.storage.patch(patchEntries);\n\t        });\n\t        return createStoreObservable(storeResultsPromise);\n\t    },\n\t    delete: function (ids) {\n\t        var self = this;\n\t        var state = instanceStateMap.get(self);\n\t        var storeResultsPromise = state.initialAddPromise.then(function () {\n\t            return state.storage.delete(Array.isArray(ids) ? ids : [ids]);\n\t        });\n\t        return createStoreObservable(storeResultsPromise);\n\t    },\n\t    fetch: function (query) {\n\t        var state = instanceStateMap.get(this);\n\t        var resolveTotalLength;\n\t        var rejectTotalLength;\n\t        var totalLength = new Promise_1.default(function (resolve, reject) {\n\t            resolveTotalLength = resolve;\n\t            rejectTotalLength = reject;\n\t        });\n\t        var fetchResult = state.initialAddPromise.then(function () {\n\t            var result = state.storage.fetch(query);\n\t            result.totalLength.then(resolveTotalLength, rejectTotalLength);\n\t            return result;\n\t        });\n\t        fetchResult.totalLength = fetchResult.dataLength = totalLength;\n\t        return fetchResult;\n\t    },\n\t    identify: function (items) {\n\t        var storage = instanceStateMap.get(this).storage;\n\t        if (Array.isArray(items)) {\n\t            return storage.identify(items);\n\t        }\n\t        else {\n\t            return storage.identify([items])[0];\n\t        }\n\t    },\n\t    createId: function () {\n\t        return instanceStateMap.get(this).storage.createId();\n\t    }\n\t}, function (instance, options) {\n\t    options = options || {};\n\t    var data = options.data;\n\t    options.data = undefined;\n\t    var instanceState = {\n\t        storage: options.storage || createInMemoryStorage_1.default(options),\n\t        initialAddPromise: Promise_1.default.resolve()\n\t    };\n\t    instanceStateMap.set(instance, instanceState);\n\t    if (data) {\n\t        instanceState.initialAddPromise = instance.add(data).catch(function (error) {\n\t            console.error(error);\n\t        });\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createStore;\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(46);\n\tvar Promise_1 = __webpack_require__(32);\n\tfunction isSubscribable(object) {\n\t    return object && object.subscribe !== undefined;\n\t}\n\tvar Observable = (function (_super) {\n\t    __extends(Observable, _super);\n\t    function Observable() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    Observable.of = function () {\n\t        var items = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            items[_i] = arguments[_i];\n\t        }\n\t        return _super.of.apply(this, items);\n\t    };\n\t    Observable.from = function (item) {\n\t        return _super.from.call(this, item);\n\t    };\n\t    Observable.defer = function (deferFunction) {\n\t        return new Observable(function (observer) {\n\t            var trueObservable = deferFunction();\n\t            return trueObservable.subscribe({\n\t                next: function (value) {\n\t                    return observer.next(value);\n\t                },\n\t                error: function (errorValue) {\n\t                    return observer.error(errorValue);\n\t                },\n\t                complete: function (completeValue) {\n\t                    observer.complete(completeValue);\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Observable.prototype.toPromise = function () {\n\t        var _this = this;\n\t        return new Promise_1.default(function (resolve, reject) {\n\t            _this.subscribe({\n\t                next: function (value) {\n\t                    resolve(value);\n\t                },\n\t                error: function (error) {\n\t                    reject(error);\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Observable.prototype.map = function (mapFunction) {\n\t        var self = this;\n\t        if (typeof mapFunction !== 'function') {\n\t            throw new TypeError('Map parameter must be a function');\n\t        }\n\t        return new Observable(function (observer) {\n\t            self.subscribe({\n\t                next: function (value) {\n\t                    try {\n\t                        var result = mapFunction(value);\n\t                        return observer.next(result);\n\t                    }\n\t                    catch (e) {\n\t                        return observer.error(e);\n\t                    }\n\t                },\n\t                error: function (errorValue) {\n\t                    return observer.error(errorValue);\n\t                },\n\t                complete: function (completeValue) {\n\t                    return observer.complete(completeValue);\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Observable.prototype.filter = function (filterFunction) {\n\t        var self = this;\n\t        if (typeof filterFunction !== 'function') {\n\t            throw new TypeError('Filter argument must be a function');\n\t        }\n\t        return new Observable(function (observer) {\n\t            self.subscribe({\n\t                next: function (value) {\n\t                    try {\n\t                        if (filterFunction(value)) {\n\t                            return observer.next(value);\n\t                        }\n\t                    }\n\t                    catch (e) {\n\t                        return observer.error(e);\n\t                    }\n\t                },\n\t                error: function (errorValue) {\n\t                    return observer.error(errorValue);\n\t                },\n\t                complete: function (completeValue) {\n\t                    return observer.complete(completeValue);\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Observable.prototype.toArray = function () {\n\t        var self = this;\n\t        return new Observable(function (observer) {\n\t            var values = [];\n\t            self.subscribe({\n\t                next: function (value) {\n\t                    values.push(value);\n\t                },\n\t                error: function (errorValue) {\n\t                    return observer.error(errorValue);\n\t                },\n\t                complete: function (completeValue) {\n\t                    observer.next(values);\n\t                    observer.complete(completeValue);\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Observable.prototype.mergeAll = function (concurrent) {\n\t        var self = this;\n\t        return new Observable(function (observer) {\n\t            var active = [];\n\t            var queue = [];\n\t            function checkForComplete() {\n\t                if (active.length === 0 && queue.length === 0) {\n\t                    observer.complete();\n\t                }\n\t                else if (queue.length > 0 && active.length < concurrent) {\n\t                    var item = queue.shift();\n\t                    if (isSubscribable(item)) {\n\t                        var itemIndex_1 = active.length;\n\t                        active.push(item);\n\t                        item.subscribe({\n\t                            next: function (value) {\n\t                                observer.next(value);\n\t                            },\n\t                            complete: function () {\n\t                                active.splice(itemIndex_1, 1);\n\t                                checkForComplete();\n\t                            }\n\t                        });\n\t                    }\n\t                    else {\n\t                        observer.next(item);\n\t                        checkForComplete();\n\t                    }\n\t                }\n\t            }\n\t            self.subscribe({\n\t                next: function (value) {\n\t                    queue.push(value);\n\t                },\n\t                complete: function () {\n\t                    checkForComplete();\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return Observable;\n\t}(Observable_1.default));\n\texports.Observable = Observable;\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Observable;\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar iterator_1 = __webpack_require__(18);\n\tvar decorators_1 = __webpack_require__(23);\n\tvar global_1 = __webpack_require__(12);\n\t__webpack_require__(20);\n\tvar Shim;\n\t(function (Shim) {\n\t    /*\n\t     * Decorator to mark a single method/property as non-enumerable. ES spec requires pretty much every\n\t     * method or property in Subscription, Observable, and SubscriptionObserver to be non-enumerable.\n\t     */\n\t    function nonEnumerable(target, key, descriptor) {\n\t        descriptor.enumerable = false;\n\t    }\n\t    /*\n\t     * Create a subscription observer for a given observer, and return the subscription.  The \"logic\" for Observerables\n\t     * is in here!\n\t     */\n\t    function startSubscription(executor, observer) {\n\t        var closed = false;\n\t        var cleanUp;\n\t        function unsubscribe() {\n\t            if (!closed) {\n\t                closed = true;\n\t                if (cleanUp) {\n\t                    cleanUp();\n\t                }\n\t            }\n\t        }\n\t        function start(subscriptionObserver) {\n\t            if (observer.start) {\n\t                observer.start(subscription);\n\t            }\n\t            if (closed) {\n\t                return;\n\t            }\n\t            try {\n\t                var result = executor(subscriptionObserver);\n\t                if (typeof result === 'function') {\n\t                    cleanUp = result;\n\t                }\n\t                else if (result && 'unsubscribe' in result) {\n\t                    cleanUp = result.unsubscribe;\n\t                }\n\t                else if (result !== undefined && result !== null) {\n\t                    throw new TypeError('Subscriber must return a callable or subscription');\n\t                }\n\t                if (closed) {\n\t                    if (cleanUp) {\n\t                        cleanUp();\n\t                    }\n\t                }\n\t            }\n\t            catch (e) {\n\t                error(e);\n\t            }\n\t        }\n\t        function next(value) {\n\t            if (closed) {\n\t                return;\n\t            }\n\t            var next = observer.next;\n\t            try {\n\t                if (typeof next === 'function') {\n\t                    return next(value);\n\t                }\n\t                else if (next !== undefined && next !== null) {\n\t                    throw new TypeError('Observer.next is not a function');\n\t                }\n\t            }\n\t            catch (e) {\n\t                error(e);\n\t            }\n\t        }\n\t        function error(errorValue) {\n\t            if (!closed) {\n\t                var cleanUpError = undefined;\n\t                try {\n\t                    unsubscribe();\n\t                }\n\t                catch (e) {\n\t                    cleanUpError = e;\n\t                }\n\t                var observerError = observer.error;\n\t                if (observerError !== undefined && observerError !== null) {\n\t                    if (typeof observerError === 'function') {\n\t                        var errorResult = observerError(errorValue);\n\t                        if (cleanUpError !== undefined) {\n\t                            throw cleanUpError;\n\t                        }\n\t                        return errorResult;\n\t                    }\n\t                    else {\n\t                        throw new TypeError('Observer.error is not a function');\n\t                    }\n\t                }\n\t                else if (observer.complete) {\n\t                    return observer.complete(errorValue);\n\t                }\n\t                else {\n\t                    throw errorValue;\n\t                }\n\t            }\n\t            else {\n\t                throw errorValue;\n\t            }\n\t        }\n\t        function complete(completeValue) {\n\t            if (!closed) {\n\t                var cleanUpError = undefined;\n\t                try {\n\t                    unsubscribe();\n\t                }\n\t                catch (e) {\n\t                    cleanUpError = e;\n\t                }\n\t                var observerComplete = observer.complete;\n\t                if (observerComplete !== undefined && observerComplete !== null) {\n\t                    if (typeof observerComplete === 'function') {\n\t                        var completeResult = observerComplete(completeValue);\n\t                        if (cleanUpError !== undefined) {\n\t                            throw cleanUpError;\n\t                        }\n\t                        return completeResult;\n\t                    }\n\t                    else {\n\t                        throw new TypeError('Observer.complete is not a function');\n\t                    }\n\t                }\n\t                else if (cleanUpError) {\n\t                    throw cleanUpError;\n\t                }\n\t            }\n\t        }\n\t        var subscription = Object.create(Object.create({}, {\n\t            'closed': {\n\t                enumerable: false,\n\t                configurable: true,\n\t                get: function () {\n\t                    return closed;\n\t                }\n\t            },\n\t            'unsubscribe': {\n\t                enumerable: false,\n\t                configurable: true,\n\t                writable: true,\n\t                value: unsubscribe\n\t            }\n\t        }));\n\t        var prototype = Object.create({}, {\n\t            'next': {\n\t                enumerable: false,\n\t                writable: true,\n\t                value: next,\n\t                configurable: true\n\t            },\n\t            'error': {\n\t                enumerable: false,\n\t                writable: true,\n\t                value: error,\n\t                configurable: true\n\t            },\n\t            'complete': {\n\t                enumerable: false,\n\t                writable: true,\n\t                value: complete,\n\t                configurable: true\n\t            },\n\t            'closed': {\n\t                enumerable: false,\n\t                configurable: true,\n\t                get: function () {\n\t                    return closed;\n\t                }\n\t            }\n\t        });\n\t        // create the SubscriptionObserver and kick things off\n\t        start(Object.create(prototype));\n\t        // the ONLY way to control the SubscriptionObserver is with the subscription or from a subscriber\n\t        return subscription;\n\t    }\n\t    var ShimObservable = (function () {\n\t        function ShimObservable(subscriber) {\n\t            if (typeof subscriber !== 'function') {\n\t                throw new TypeError('subscriber is not a function');\n\t            }\n\t            this._executor = subscriber;\n\t        }\n\t        ShimObservable.prototype[_a = Symbol.observable] = function () {\n\t            return this;\n\t        };\n\t        ShimObservable.prototype.subscribe = function (observerOrNext) {\n\t            var listeners = [];\n\t            for (var _i = 1; _i < arguments.length; _i++) {\n\t                listeners[_i - 1] = arguments[_i];\n\t            }\n\t            var _a = listeners.slice(), onError = _a[0], onComplete = _a[1];\n\t            if (!observerOrNext || typeof observerOrNext === 'number' || typeof observerOrNext === 'string' || typeof observerOrNext === 'boolean') {\n\t                throw new TypeError('parameter must be a function or an observer');\n\t            }\n\t            var observer;\n\t            if (typeof observerOrNext === 'function') {\n\t                observer = {\n\t                    next: observerOrNext\n\t                };\n\t                if (typeof onError === 'function') {\n\t                    observer.error = onError;\n\t                }\n\t                if (typeof onComplete === 'function') {\n\t                    observer.complete = onComplete;\n\t                }\n\t            }\n\t            else {\n\t                observer = observerOrNext;\n\t            }\n\t            return startSubscription(this._executor, observer);\n\t        };\n\t        ShimObservable.of = function () {\n\t            var items = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                items[_i] = arguments[_i];\n\t            }\n\t            var constructor;\n\t            if (typeof this !== 'function') {\n\t                constructor = ShimObservable;\n\t            }\n\t            else {\n\t                constructor = this;\n\t            }\n\t            return new constructor(function (observer) {\n\t                iterator_1.forOf(items, function (o) {\n\t                    observer.next(o);\n\t                });\n\t                observer.complete();\n\t            });\n\t        };\n\t        ShimObservable.from = function (item) {\n\t            if (item === null || item === undefined) {\n\t                throw new TypeError('item cannot be null or undefined');\n\t            }\n\t            var constructor;\n\t            if (typeof this !== 'function') {\n\t                constructor = ShimObservable;\n\t            }\n\t            else {\n\t                constructor = this;\n\t            }\n\t            var observableSymbol = item[Symbol.observable];\n\t            if (observableSymbol !== undefined) {\n\t                if (typeof observableSymbol !== 'function') {\n\t                    throw new TypeError('Symbol.observable must be a function');\n\t                }\n\t                var result = observableSymbol.call(item);\n\t                if (result === undefined || result === null || typeof result === 'number' || typeof result === 'boolean' || typeof result === 'string') {\n\t                    throw new TypeError('Return value of Symbol.observable must be object');\n\t                }\n\t                if (result.constructor && result.constructor === this || result instanceof ShimObservable) {\n\t                    return result;\n\t                }\n\t                else if (result.subscribe) {\n\t                    return new constructor(result.subscribe);\n\t                }\n\t                else {\n\t                    if (constructor.of) {\n\t                        return constructor.of(result);\n\t                    }\n\t                    else {\n\t                        return ShimObservable.of(result);\n\t                    }\n\t                }\n\t            }\n\t            else if (iterator_1.isIterable(item) || iterator_1.isArrayLike(item)) {\n\t                return new constructor(function (observer) {\n\t                    iterator_1.forOf(item, function (o) {\n\t                        observer.next(o);\n\t                    });\n\t                    observer.complete();\n\t                });\n\t            }\n\t            else {\n\t                throw new TypeError('Parameter is neither Observable nor Iterable');\n\t            }\n\t        };\n\t        return ShimObservable;\n\t    }());\n\t    __decorate([\n\t        nonEnumerable\n\t    ], ShimObservable.prototype, _a, null);\n\t    __decorate([\n\t        nonEnumerable\n\t    ], ShimObservable.prototype, \"subscribe\", null);\n\t    __decorate([\n\t        nonEnumerable\n\t    ], ShimObservable, \"of\", null);\n\t    __decorate([\n\t        nonEnumerable\n\t    ], ShimObservable, \"from\", null);\n\t    Shim.ShimObservable = ShimObservable;\n\t    var _a;\n\t})(Shim || (Shim = {}));\n\tvar Observable = (function () {\n\t    /* istanbul ignore next */\n\t    /**\n\t     * Create a new observerable with a subscriber function. The subscriber function will get called with a\n\t     * SubscriptionObserver parameter for controlling the subscription.  I a function is returned, it will be\n\t     * run when the subscription is complete.\n\t     *\n\t     * @param {Subscriber<T>} subscriber    The subscription function to be called when observers are subscribed\n\t     *\n\t     * @example\n\t     * const source = new Observer<number>((observer) => {\n\t     *     observer.next(1);\n\t     *     observer.next(2);\n\t     *     observer.next(3);\n\t     * });\n\t     */\n\t    function Observable(subscriber) {\n\t    }\n\t    /* istanbul ignore next */\n\t    Observable.prototype.subscribe = function (observerOrNext, onError, onComplete) {\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    /**\n\t     * Create an Observable from a list of values.\n\t     *\n\t     * @param {...T} items The values to be emitted\n\t     *\n\t     * @return {Observable<T>}    An Observable that will emit the specified values\n\t     *\n\t     * @example\n\t     *\n\t     * let source = Observable.of(1, 2, 3);\n\t     *\n\t     * // will emit three separate values, 1, 2, and 3.\n\t     */\n\t    Observable.of = function () {\n\t        var items = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            items[_i] = arguments[_i];\n\t        }\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    /**\n\t     * Create an Observable from another object. If the object is in itself Observable, the object will be returned.\n\t     * Otherwise, the value will be wrapped in an Observable. If the object is iterable, an Observable will be created\n\t     * that emits each item of the iterable.\n\t     *\n\t     * @param {Iterable<T> | ArrayLike<T> | ObservableObject} item The item to be turned into an Observable\n\t     *\n\t     * @return {Observable<T>}    An observable for the item you passed in\n\t     */\n\t    Observable.from = function (item) {\n\t        throw new Error();\n\t    };\n\t    /* istanbul ignore next */\n\t    Observable.prototype[Symbol.observable] = function () {\n\t        throw new Error();\n\t    };\n\t    return Observable;\n\t}());\n\tObservable = __decorate([\n\t    decorators_1.hasClass('es-observable', global_1.default.Observable, Shim.ShimObservable)\n\t], Observable);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Observable;\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar utils_1 = __webpack_require__(48);\n\tvar createOperation_1 = __webpack_require__(49);\n\tvar createJsonPointer_1 = __webpack_require__(50);\n\tfunction _diff(to, from, startingPath) {\n\t    if (!utils_1.shouldRecurseInto(from) || !utils_1.shouldRecurseInto(to)) {\n\t        return [];\n\t    }\n\t    var path = startingPath || createJsonPointer_1.default();\n\t    var fromKeys = Object.keys(from);\n\t    var toKeys = Object.keys(to);\n\t    var operations = [];\n\t    fromKeys.forEach(function (key) {\n\t        if (!utils_1.isEqual(from[key], to[key])) {\n\t            if ((key in from) && !(key in to)) {\n\t                operations.push(createOperation_1.default(1 /* Remove */, path.push(key)));\n\t            }\n\t            else if (utils_1.shouldRecurseInto(from[key]) && utils_1.shouldRecurseInto(to[key])) {\n\t                operations.push.apply(operations, _diff(to[key], from[key], path.push(key)));\n\t            }\n\t            else {\n\t                operations.push(createOperation_1.default(2 /* Replace */, path.push(key), to[key], undefined, from[key]));\n\t            }\n\t        }\n\t    });\n\t    toKeys.forEach(function (key) {\n\t        if (!(key in from) && (key in to)) {\n\t            operations.push(createOperation_1.default(0 /* Add */, path.push(key), to[key]));\n\t        }\n\t    });\n\t    return operations;\n\t}\n\tfunction diff(to, from) {\n\t    if (from === void 0) { from = {}; }\n\t    return createPatch(_diff(to, from));\n\t}\n\texports.diff = diff;\n\tfunction createPatch(operations) {\n\t    return {\n\t        operations: operations,\n\t        apply: function (target) {\n\t            return this.operations.reduce(function (prev, next) { return next.apply(prev); }, target);\n\t        },\n\t        toString: function () {\n\t            return '[' + this.operations.reduce(function (prev, next) {\n\t                if (prev) {\n\t                    return prev + ',' + next.toString();\n\t                }\n\t                else {\n\t                    return next.toString();\n\t                }\n\t            }, '') + ']';\n\t        }\n\t    };\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createPatch;\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction shouldRecurseInto(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\texports.shouldRecurseInto = shouldRecurseInto;\n\tfunction isEqual(a, b) {\n\t    if (Array.isArray(a) && Array.isArray(b)) {\n\t        return a.length === b.length && a.every(function (element, i) { return isEqual(element, b[i]); });\n\t    }\n\t    else if (shouldRecurseInto(a) && shouldRecurseInto(b)) {\n\t        var keysForA = Object.keys(a).sort();\n\t        var keysforB = Object.keys(b).sort();\n\t        return isEqual(keysForA, keysforB) && keysForA.every(function (key) { return isEqual(a[key], b[key]); });\n\t    }\n\t    else {\n\t        return a === b;\n\t    }\n\t}\n\texports.isEqual = isEqual;\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar utils_1 = __webpack_require__(48);\n\tvar createJsonPointer_1 = __webpack_require__(50);\n\tfunction navigatePath(target, path) {\n\t    var currentPath = '';\n\t    var lastSegment = '';\n\t    var pathSegments = path.segments();\n\t    pathSegments.forEach(function (segment, index) {\n\t        currentPath += \"/\" + segment;\n\t        if (!target) {\n\t            throw new Error(\"Invalid path: \" + currentPath + \" doesn't exist in target\");\n\t        }\n\t        else if (index + 1 < pathSegments.length) {\n\t            target = target[segment];\n\t        }\n\t        else {\n\t            lastSegment = segment;\n\t        }\n\t    });\n\t    return {\n\t        object: target,\n\t        property: lastSegment\n\t    };\n\t}\n\tfunction add(target) {\n\t    var applyTo = navigatePath(target, this.path);\n\t    applyTo.object[applyTo.property] = this.value;\n\t    return target;\n\t}\n\tfunction remove(target) {\n\t    var applyTo = navigatePath(target, this.path);\n\t    delete applyTo.object[applyTo.property];\n\t    return target;\n\t}\n\tfunction replace(target) {\n\t    var applyTo = navigatePath(target, this.path);\n\t    if (!(applyTo.property in applyTo.object)) {\n\t        throw new Error(\"Cannot replace undefined path: \" + this.path.toString() + \" on object\");\n\t    }\n\t    applyTo.object[applyTo.property] = this.value;\n\t    return target;\n\t}\n\tfunction copyOrMove(from, to, target, toDelete) {\n\t    var moveFrom = navigatePath(target, from);\n\t    if (!(moveFrom.property in moveFrom.object)) {\n\t        throw new Error(\"Cannot move from undefined path: \" + from.toString() + \" on object\");\n\t    }\n\t    var applyTo = navigatePath(target, to);\n\t    applyTo.object[applyTo.property] = moveFrom.object[moveFrom.property];\n\t    if (toDelete) {\n\t        delete moveFrom.object[moveFrom.property];\n\t    }\n\t}\n\tfunction move(target) {\n\t    copyOrMove(this.from, this.path, target, true);\n\t    return target;\n\t}\n\tfunction copy(target) {\n\t    copyOrMove(this.from, this.path, target, false);\n\t    return target;\n\t}\n\tfunction test(target) {\n\t    var applyTo = navigatePath(target, this.path);\n\t    return utils_1.isEqual(applyTo.object[applyTo.property], this.value);\n\t}\n\tfunction getPath(path) {\n\t    if (Array.isArray(path)) {\n\t        return createJsonPointer_1.default.apply(void 0, path);\n\t    }\n\t    else {\n\t        return path;\n\t    }\n\t}\n\tfunction toString() {\n\t    var jsonObj = {};\n\t    jsonObj.op = this.op;\n\t    jsonObj.path = this.path.toString();\n\t    if (this.value) {\n\t        jsonObj.value = this.value;\n\t    }\n\t    if (this.from) {\n\t        jsonObj.from = this.from.toString();\n\t    }\n\t    return JSON.stringify(jsonObj);\n\t}\n\tfunction createOperation(type, path, value, from, oldValue) {\n\t    switch (type) {\n\t        case 0 /* Add */:\n\t            return {\n\t                op: 'add',\n\t                path: getPath(path),\n\t                value: value,\n\t                apply: add,\n\t                toString: toString\n\t            };\n\t        case 1 /* Remove */:\n\t            return {\n\t                op: 'remove',\n\t                path: getPath(path),\n\t                apply: remove,\n\t                toString: toString\n\t            };\n\t        case 2 /* Replace */:\n\t            return {\n\t                op: 'replace',\n\t                path: getPath(path),\n\t                value: value,\n\t                oldValue: oldValue,\n\t                apply: replace,\n\t                toString: toString\n\t            };\n\t        case 4 /* Move */:\n\t            if (!from) {\n\t                throw new Error('From value is required for Move operations');\n\t            }\n\t            return {\n\t                op: 'move',\n\t                path: getPath(path),\n\t                from: getPath(from),\n\t                apply: move,\n\t                toString: toString\n\t            };\n\t        case 3 /* Copy */:\n\t            if (!from) {\n\t                throw new Error('From value is required in Copy operation');\n\t            }\n\t            return {\n\t                op: 'copy',\n\t                path: getPath(path),\n\t                from: getPath(from),\n\t                apply: copy,\n\t                toString: toString\n\t            };\n\t        case 5 /* Test */:\n\t            return {\n\t                op: 'test',\n\t                path: getPath(path),\n\t                value: value,\n\t                apply: test,\n\t                toString: toString\n\t            };\n\t    }\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createOperation;\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction navigate(path, target) {\n\t    return path.segments().reduce(function (prev, next) {\n\t        return prev ? prev[next] : prev;\n\t    }, target);\n\t}\n\texports.navigate = navigate;\n\tfunction decode(segment) {\n\t    return segment.replace(/~1/g, '/').replace(/~0/g, '~');\n\t}\n\tfunction encode(segment) {\n\t    return segment.replace(/~/g, '~0').replace(/\\//g, '~1');\n\t}\n\tfunction toString() {\n\t    var segments = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        segments[_i] = arguments[_i];\n\t    }\n\t    return segments.reduce(function (prev, next) {\n\t        return prev + '/' + encode(next);\n\t    });\n\t}\n\tfunction createJsonPointer() {\n\t    var segments = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        segments[_i] = arguments[_i];\n\t    }\n\t    return {\n\t        segments: function () {\n\t            return segments.map(function (segment) { return decode(segment); });\n\t        }, toString: function () {\n\t            return toString.apply(void 0, segments);\n\t        },\n\t        push: function (segment) {\n\t            return createJsonPointer.apply(void 0, segments.concat(segment));\n\t        },\n\t        pop: function () {\n\t            return createJsonPointer.apply(void 0, segments.slice(0, segments.length - 1));\n\t        }\n\t    };\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createJsonPointer;\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Promise_1 = __webpack_require__(32);\n\tvar global_1 = __webpack_require__(10);\n\tglobal_1.default.Rx = { config: { Promise: Promise_1.default } };\n\tfunction createStoreObservable(observable, transform) {\n\t    // Cast to any because the signatures of catch between the Observable and Promise interfaces are not\n\t    // compatible\n\t    var storeObservable = observable;\n\t    storeObservable.then = function (onFulfilled, onRejected) {\n\t        // Wrap in a shim promise because the interface that leaks through observable.toPromise is missing some\n\t        // properties on the shim(e.g. promise)\n\t        return Promise_1.default.resolve(observable.toPromise())\n\t            .then(transform)\n\t            .then(onFulfilled, onRejected);\n\t    };\n\t    storeObservable.catch = function (onRejected) {\n\t        return observable.toPromise().then(transform).then(undefined, onRejected);\n\t    };\n\t    return storeObservable;\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createStoreObservable;\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(7);\n\tvar Promise_1 = __webpack_require__(32);\n\tvar WeakMap_1 = __webpack_require__(22);\n\tvar Map_1 = __webpack_require__(29);\n\tvar lang_1 = __webpack_require__(15);\n\tvar uuid_1 = __webpack_require__(53);\n\tvar instanceStateMap = new WeakMap_1.default();\n\tfunction putSync(instance, items, options) {\n\t    var state = instanceStateMap.get(instance);\n\t    var ids = instance.identify(items);\n\t    var updatedItems = [];\n\t    var oldIndices = [];\n\t    var newIds = [];\n\t    var newItems = [];\n\t    ids.forEach(function (id, index) {\n\t        var oldIndex = state.index.get(id);\n\t        if (typeof oldIndex === 'undefined') {\n\t            newIds.push(id);\n\t            newItems.push(items[index]);\n\t        }\n\t        else {\n\t            updatedItems.push(items[index]);\n\t            oldIndices.push(oldIndex);\n\t        }\n\t    });\n\t    if (oldIndices.length && options && options.rejectOverwrite) {\n\t        throw Error('Objects already exist in store');\n\t    }\n\t    var data = state.data;\n\t    updatedItems.forEach(function (item, index) {\n\t        data[oldIndices[index]] = item;\n\t    });\n\t    newItems.forEach(function (item, index) {\n\t        state.index.set(newIds[index], data.push(item) - 1);\n\t    });\n\t    return {\n\t        successfulData: items,\n\t        type: 1 /* Put */\n\t    };\n\t}\n\tvar createInMemoryStorage = compose_1.default({\n\t    identify: function (items) {\n\t        var state = instanceStateMap.get(this);\n\t        var itemArray = Array.isArray(items) ? items : [items];\n\t        if (state.idProperty) {\n\t            var idProperty_1 = state.idProperty;\n\t            return itemArray.map(function (item) {\n\t                return item[idProperty_1];\n\t            });\n\t        }\n\t        else if (state.idFunction) {\n\t            return itemArray.map(state.idFunction);\n\t        }\n\t        else {\n\t            return itemArray.map(function (item) {\n\t                return item.id;\n\t            });\n\t        }\n\t    },\n\t    createId: function () {\n\t        return Promise_1.default.resolve(uuid_1.default());\n\t    },\n\t    fetch: function (query) {\n\t        var state = instanceStateMap.get(this);\n\t        var fullData = state.data;\n\t        var data = (query ? query.apply(fullData) : fullData).slice();\n\t        var returnPromise = state.returnsPromise.then(function () { return data; });\n\t        state.returnsPromise = returnPromise;\n\t        returnPromise.totalLength = returnPromise.dataLength = Promise_1.default.resolve(fullData.length);\n\t        return returnPromise;\n\t    },\n\t    get: function (ids) {\n\t        var state = instanceStateMap.get(this);\n\t        var data = state.data;\n\t        var objects = [];\n\t        return Promise_1.default.resolve(ids.reduce(function (prev, next) {\n\t            return state.index.has(next) ? prev.concat(data[state.index.get(next)]) : prev;\n\t        }, objects));\n\t    },\n\t    put: function (items, options) {\n\t        var state = instanceStateMap.get(this);\n\t        try {\n\t            var result_1 = putSync(this, items, options);\n\t            // Don't control the order operations are executed in, but make sure that the results\n\t            // resolve in the order they were actually executed in.\n\t            var returnPromise = state.returnsPromise.then(function () { return result_1; });\n\t            state.returnsPromise = returnPromise;\n\t            return returnPromise;\n\t        }\n\t        catch (error) {\n\t            return Promise_1.default.reject(error);\n\t        }\n\t    },\n\t    add: function (items, options) {\n\t        options = options || {};\n\t        var state = instanceStateMap.get(this);\n\t        if (typeof options.rejectOverwrite === 'undefined') {\n\t            options.rejectOverwrite = true;\n\t        }\n\t        try {\n\t            var result_2 = putSync(this, items, options);\n\t            // Don't control the order operations are executed in, but make sure that the results\n\t            // resolve in the order they were actually executed in.\n\t            var returnPromise = state.returnsPromise.then(function () {\n\t                result_2.type = 0 /* Add */;\n\t                return result_2;\n\t            });\n\t            state.returnsPromise = returnPromise;\n\t            return returnPromise;\n\t        }\n\t        catch (error) {\n\t            return Promise_1.default.reject(error);\n\t        }\n\t    },\n\t    delete: function (ids) {\n\t        var state = instanceStateMap.get(this);\n\t        var data = state.data;\n\t        var idsToRemove = ids.filter(function (id) {\n\t            return state.index.has(id);\n\t        });\n\t        var indices = idsToRemove\n\t            .map(function (id) {\n\t            return state.index.get(id);\n\t        })\n\t            .sort();\n\t        idsToRemove.forEach(function (id) {\n\t            state.index.delete(id);\n\t        });\n\t        indices.forEach(function (index, indexArrayIndex) {\n\t            return data.splice(index - indexArrayIndex, 1);\n\t        });\n\t        if (indices.length) {\n\t            var firstInvalidIndex_1 = indices[0];\n\t            var updateIndexForIds = this.identify(data.slice(firstInvalidIndex_1));\n\t            updateIndexForIds.forEach(function (id, index) {\n\t                state.index.set(id, index + firstInvalidIndex_1);\n\t            });\n\t        }\n\t        // Don't control the order operations are executed in, but make sure that the results\n\t        // resolve in the order they were actually executed in.\n\t        var returnPromise = state.returnsPromise.then(function () { return ({\n\t            successfulData: idsToRemove,\n\t            type: 3 /* Delete */\n\t        }); });\n\t        state.returnsPromise = returnPromise;\n\t        return returnPromise;\n\t    },\n\t    patch: function (updates) {\n\t        var state = instanceStateMap.get(this);\n\t        var data = state.data;\n\t        var filteredUpdates = updates.filter(function (update) {\n\t            return state.index.has(update.id);\n\t        });\n\t        var oldIndices = filteredUpdates.map(function (update) {\n\t            return state.index.get(update.id);\n\t        });\n\t        try {\n\t            var updatedItems_1 = filteredUpdates.map(function (update, index) {\n\t                var item = lang_1.duplicate(data[oldIndices[index]]);\n\t                var updatedItem = update.patch.apply(item);\n\t                data[oldIndices[index]] = updatedItem;\n\t                return updatedItem;\n\t            });\n\t            // Don't control the order operations are executed in, but make sure that the results\n\t            // resolve in the order they were actually executed in.\n\t            var returnsPromise = state.returnsPromise.then(function () { return ({\n\t                successfulData: updatedItems_1,\n\t                type: 2 /* Patch */\n\t            }); });\n\t            state.returnsPromise = returnsPromise;\n\t            return returnsPromise;\n\t        }\n\t        catch (error) {\n\t            return Promise_1.default.reject(error);\n\t        }\n\t    },\n\t    isUpdate: function (item) {\n\t        var state = instanceStateMap.get(this);\n\t        var id = this.identify([item])[0];\n\t        var isUpdate = state.index.has(id);\n\t        return Promise_1.default.resolve({\n\t            id: id,\n\t            item: item,\n\t            isUpdate: isUpdate\n\t        });\n\t    }\n\t}, function (instance, options) {\n\t    options = options || {};\n\t    instanceStateMap.set(instance, {\n\t        data: [],\n\t        index: new Map_1.default(),\n\t        idProperty: options.idProperty,\n\t        idFunction: options.idFunction,\n\t        returnsPromise: Promise_1.default.resolve()\n\t    });\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createInMemoryStorage;\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * Returns a v4 compliant UUID.\n\t *\n\t * @returns {string}\n\t */\n\tfunction uuid() {\n\t    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t        var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n\t        return v.toString(16);\n\t    });\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = uuid;\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createStore_1 = __webpack_require__(44);\n\tvar Observable_1 = __webpack_require__(45);\n\tvar WeakMap_1 = __webpack_require__(22);\n\tvar Map_1 = __webpack_require__(29);\n\tvar Set_1 = __webpack_require__(55);\n\tvar aspect_1 = __webpack_require__(24);\n\tvar util_1 = __webpack_require__(56);\n\t/**\n\t * Combines several sequential deltas into a single delta.\n\t * It performs several checks to remove redundant data.\n\t * \t- Checks for repeated copies items with the same ID in\n\t * \tadds and updates, or just the same ID in deletes, and keeps\n\t * \tonly the last.\n\t * \t- Checks for deletes followed by adds or updates and replaces with a\n\t * \tsingle update\n\t * \t- Checks for adds followed by deletes and removes both\n\t * \t- Checks for updates followed by deletes and removes the update\n\t * @param instance The instance that can identify these items\n\t * @param currentUpdate The current store delta\n\t * @param newUpdate The new update to merge\n\t * @returns The merged delta\n\t */\n\tfunction mergeDeltas(instance, currentUpdate, newUpdate) {\n\t    /**\n\t     * Takes the last instance of an item repeated in the list\n\t     * @param items Added or updated items\n\t     * @returns The added or updated items with repeated items replaced by only the latest version of the item\n\t     */\n\t    function takeLastItem(items) {\n\t        var found = {};\n\t        var ids = instance.identify(items);\n\t        return items.reverse().filter(function (_, index) {\n\t            var id = ids[index];\n\t            var exists = Boolean(found[id]);\n\t            found[id] = true;\n\t            return !exists;\n\t        }).reverse();\n\t    }\n\t    /**\n\t     * Takes the last instance of an id repeated in the list\n\t     * @param ids IDs of deleted items\n\t     * @returns The list with duplicates removed\n\t     */\n\t    function takeLastId(ids) {\n\t        var found = {};\n\t        return ids.reverse().filter(function (id) {\n\t            var exists = Boolean(found[id]);\n\t            found[id] = true;\n\t            return !exists;\n\t        }).reverse();\n\t    }\n\t    /**\n\t     * Removes updates for items that were later deleted\n\t     * @param newDeletes Deletes from delta(s) after the updates\n\t     * @param oldUpdates Updates from delta(s) before the deletes\n\t     * @return The updates without updates for subsequently deleted items\n\t     */\n\t    function removeOutdatedItems(newDeletes, oldUpdates) {\n\t        var deletedIds = newDeletes.reduce(function (prev, next) {\n\t            prev.set(next, null);\n\t            return prev;\n\t        }, new Map_1.default());\n\t        var ids = instance.identify(oldUpdates);\n\t        return oldUpdates.filter(function (_, index) {\n\t            return !deletedIds.has(ids[index]);\n\t        });\n\t    }\n\t    /**\n\t     * Finds cases where an older update has an add, and a newer update has a delete, and removes\n\t     * both, since the net effect is that the operations are cancelled out\n\t     * @param newDeletes Deletes form delta(s) after the adds\n\t     * @param oldAdds Adds from delta(s) before the deletes\n\t     * @returns An object with the filtered adds and deletes\n\t     */\n\t    function removeCancellingUpdates(newDeletes, oldAdds) {\n\t        var deletedIds = newDeletes.reduce(function (prev, next) {\n\t            prev.set(next, null);\n\t            return prev;\n\t        }, new Map_1.default());\n\t        var ids = instance.identify(oldAdds);\n\t        var addIds = ids.reduce(function (prev, next) {\n\t            prev.set(next, null);\n\t            return prev;\n\t        }, new Map_1.default());\n\t        return {\n\t            oldAdds: oldAdds.filter(function (_, index) {\n\t                return !deletedIds.has(ids[index]);\n\t            }),\n\t            newDeletes: newDeletes.filter(function (id) { return !addIds.has(id); })\n\t        };\n\t    }\n\t    /**\n\t     * Finds places where an item was deleted and then added or updated, and removes the delete. If the item was added,\n\t     * the add is also replaced with an update since it should already exist in the collection receiving the updates,\n\t     * as it will never receive the delete\n\t     * @param oldDeletes - Deletes from delta(s) before the adds and updates\n\t     * @param newAdds - Adds from delta(s) after the deletes\n\t     * @param newUpdates - Updates from delta(s) after the deletes\n\t     * @returns An object containing the updated deletes, adds, and updates\n\t     */\n\t    function convertReplacementToUpdate(oldDeletes, newAdds, newUpdates) {\n\t        var deletes = oldDeletes.reduce(function (prev, next) {\n\t            prev.set(next, null);\n\t            return prev;\n\t        }, new Map_1.default());\n\t        var addIds = instance.identify(newAdds);\n\t        var updateIds = instance.identify(newUpdates);\n\t        var adds = addIds.concat(updateIds).reduce(function (prev, next) {\n\t            prev.set(next, null);\n\t            return prev;\n\t        }, new Map_1.default());\n\t        var updatedUpdates = newUpdates.slice();\n\t        return {\n\t            oldDeletes: oldDeletes.filter(function (id) { return !adds.has(id); }),\n\t            newAdds: newAdds.filter(function (item, index) {\n\t                var shouldKeep = !deletes.has(addIds[index]);\n\t                if (!shouldKeep) {\n\t                    // Always add it to the beginning, because it may have been updated as well, but the add\n\t                    // has to have come first.\n\t                    updatedUpdates.unshift(item);\n\t                }\n\t                return shouldKeep;\n\t            }),\n\t            newUpdates: updatedUpdates\n\t        };\n\t    }\n\t    var _a = convertReplacementToUpdate(currentUpdate.deletes, newUpdate.adds, newUpdate.updates), oldDeletes = _a.oldDeletes, newAdds = _a.newAdds, newUpdates = _a.newUpdates;\n\t    var oldUpdates = removeOutdatedItems(newUpdate.deletes, currentUpdate.updates);\n\t    var _b = removeCancellingUpdates(newUpdate.deletes, currentUpdate.adds), newDeletes = _b.newDeletes, oldAdds = _b.oldAdds;\n\t    return {\n\t        updates: takeLastItem(oldUpdates.concat(newUpdates)),\n\t        adds: takeLastItem(oldAdds.concat(newAdds)),\n\t        deletes: takeLastId(oldDeletes.concat(newDeletes)),\n\t        beforeAll: currentUpdate.beforeAll,\n\t        afterAll: newUpdate.afterAll\n\t    };\n\t}\n\texports.mergeDeltas = mergeDeltas;\n\tvar instanceStateMap = new WeakMap_1.default();\n\t/**\n\t * Takes a collection of items and creates a new copy modified according to the provided updates. This can be used to\n\t * attempt to track updates in the local collection when fetching after each update is disabled.\n\t * @param store\n\t * @param state\n\t * @param data\n\t * @param update\n\t * @returns A new collection with the modifications specified by the update\n\t */\n\tfunction addUpdateDelete(store, state, data, update) {\n\t    var newData = data.slice();\n\t    update.adds.forEach(function (item) {\n\t        newData.push(item);\n\t    });\n\t    store.identify(update.updates).forEach(function (id, index) {\n\t        if (state.localIndex.has(id)) {\n\t            newData[state.localIndex.get(id)] = update.updates[index];\n\t        }\n\t        else {\n\t            newData.push(update.updates[index]);\n\t        }\n\t    });\n\t    update.deletes.sort().reverse().forEach(function (id) {\n\t        if (state.localIndex.has(id)) {\n\t            newData.splice(state.localIndex.get(id), 1);\n\t        }\n\t    });\n\t    return newData;\n\t}\n\t/**\n\t * Build a map of ids to indices for the provided collection. This requires that the array of IDs is either what\n\t * the index if for, or that the array of items the IDs represent is in the same order, which is already the case\n\t * if the IDs were generated using the Store's identify function.\n\t * @param ids - The IDS to build the index for\n\t * @returns An index mapping ids to indices\n\t */\n\tfunction buildIndex(ids) {\n\t    return ids.reduce(function (map, id, index) {\n\t        map.set(id, index);\n\t        return map;\n\t    }, new Map_1.default());\n\t}\n\texports.buildIndex = buildIndex;\n\t/**\n\t * Merges the latest queued updates, updates the local data and index based on the latest data,\n\t * sends out updates to observers, and then removes observers that unsubscribed during the update process from the list\n\t * of observers. If after is provided, it is assumed that that is the latest data for the store, if it is not provided\n\t * the local data is updated according to the merged delta and that is used as the new local data.\n\t * @param store\n\t * @param after - Optional array of items containing the latest data for the store.\n\t */\n\tfunction sendUpdates(store, after) {\n\t    var state = instanceStateMap.get(store);\n\t    var storeDelta = state.queuedUpdate || {\n\t        updates: [],\n\t        adds: [],\n\t        deletes: [],\n\t        beforeAll: [],\n\t        afterAll: []\n\t    };\n\t    state.queuedUpdate = undefined;\n\t    after = after || addUpdateDelete(store, state, state.localData, storeDelta);\n\t    storeDelta.beforeAll = state.localData;\n\t    storeDelta.afterAll = after;\n\t    state.localData = after;\n\t    state.localIndex = buildIndex(store.identify(after));\n\t    state.observers.forEach(function (observer) {\n\t        observer.next({\n\t            updates: storeDelta.updates.slice(),\n\t            adds: storeDelta.adds.slice(),\n\t            deletes: storeDelta.deletes.slice(),\n\t            beforeAll: storeDelta.beforeAll.slice(),\n\t            afterAll: storeDelta.afterAll.slice()\n\t        });\n\t    });\n\t}\n\t/**\n\t * Determines whether this is a single observer or a set entry\n\t * @param observer\n\t * @returns {boolean}\n\t */\n\tfunction isObserverEntry(observer) {\n\t    return observer.observes instanceof Set_1.default;\n\t}\n\t/**\n\t * Determines whether this is a single observer or a set entry\n\t * @param observer\n\t * @returns {boolean}\n\t */\n\tfunction isObserver(observer) {\n\t    return !isObserverEntry(observer);\n\t}\n\t/**\n\t * Iterates through the provided items and/or IDs and notifies observers. If items is provided, then the\n\t * observers for that item, and the observers for sets of items that include that are updated. If items is null, then\n\t * these are delete notifications for observers of multiple items. In this case, no update is sent to individual\n\t * observers, and observers of sets receive `ItemUpdate` objects with the IDs of the deleted items and an undefined item\n\t *\n\t * @param items Items to send updates for, or null if these are delete notifications for item set observers\n\t * @param ids - IDs of the items, should be in the same order as items\n\t * @param state\n\t * @param store\n\t */\n\tfunction notifyItemObservers(items, ids, state, store) {\n\t    function notify(id, after) {\n\t        if (state.itemObservers.has(id)) {\n\t            state.itemObservers.get(id).map(function (observerOrEntry) {\n\t                if (isObserverEntry(observerOrEntry)) {\n\t                    return observerOrEntry.observer;\n\t                }\n\t                else {\n\t                    return null;\n\t                }\n\t            }).filter(function (observerEntry) {\n\t                return observerEntry;\n\t            }).forEach(function (observer) {\n\t                observer.next({\n\t                    item: after,\n\t                    id: id\n\t                });\n\t            });\n\t            if (after) {\n\t                state.itemObservers.get(id).map(function (observerOrEntry) {\n\t                    if (isObserver(observerOrEntry)) {\n\t                        return observerOrEntry;\n\t                    }\n\t                    else {\n\t                        return null;\n\t                    }\n\t                }).filter(function (observer) {\n\t                    return observer;\n\t                }).forEach(function (observer) {\n\t                    observer.next(after);\n\t                });\n\t            }\n\t        }\n\t    }\n\t    if (items) {\n\t        items.forEach(function (after, index) {\n\t            var id = ids[index] || store.identify(after);\n\t            notify(id, after);\n\t        });\n\t    }\n\t    else {\n\t        ids.forEach(function (id) {\n\t            notify(id, undefined);\n\t        });\n\t    }\n\t}\n\t/**\n\t * Queues the appropriate update and then either starts up a fetch or just triggers sending the updates depending\n\t * on the `fetchAroundUpdates` property\n\t * @param state\n\t * @param store\n\t * @param updates Updated items\n\t * @param adds Added items\n\t * @param deletes Deleted IDs\n\t */\n\tfunction sendUpdatesOrFetch(state, store, updates, adds, deletes) {\n\t    var newUpdate = {\n\t        updates: updates,\n\t        adds: adds,\n\t        deletes: deletes,\n\t        beforeAll: [],\n\t        afterAll: []\n\t    };\n\t    state.queuedUpdate = state.queuedUpdate ? mergeDeltas(store, state.queuedUpdate, newUpdate) : newUpdate;\n\t    if (state.fetchAroundUpdates) {\n\t        state.fetchAndSendUpdates(store);\n\t    }\n\t    else {\n\t        sendUpdates(store);\n\t    }\n\t}\n\tfunction createObservableStoreMixin() {\n\t    return {\n\t        mixin: {\n\t            observe: function (idOrIds) {\n\t                if (idOrIds) {\n\t                    var self_1 = this;\n\t                    var state_1 = instanceStateMap.get(self_1);\n\t                    if (Array.isArray(idOrIds)) {\n\t                        var ids_1 = idOrIds;\n\t                        var idSet_1 = new Set_1.default(ids_1);\n\t                        var observable = new Observable_1.Observable(function subscribe(observer) {\n\t                            var observerEntry = {\n\t                                observes: idSet_1,\n\t                                observer: observer\n\t                            };\n\t                            ids_1.forEach(function (id) {\n\t                                if (state_1.itemObservers.has(id)) {\n\t                                    state_1.itemObservers.get(id).push(observerEntry);\n\t                                }\n\t                                else {\n\t                                    state_1.itemObservers.set(id, [observerEntry]);\n\t                                }\n\t                            });\n\t                            var foundIds = new Set_1.default();\n\t                            observer.next = aspect_1.after(observer.next, function (result, itemUpdate) {\n\t                                foundIds.add(itemUpdate.id);\n\t                                return result;\n\t                            });\n\t                            self_1.get(ids_1).then(function (items) {\n\t                                if (foundIds.size !== ids_1.length) {\n\t                                    var retrievedIdSet_1 = new Set_1.default(self_1.identify(items));\n\t                                    var missingItemIds = ids_1.filter(function (id) { return !retrievedIdSet_1.has(id); });\n\t                                    if (retrievedIdSet_1.size !== idSet_1.size || missingItemIds.length) {\n\t                                        observer.error(new Error(\"ID(s) \\\"\" + missingItemIds + \"\\\" not found in store\"));\n\t                                    }\n\t                                    else {\n\t                                        items.forEach(function (item, index) { return observer.next({\n\t                                            item: item,\n\t                                            id: ids_1[index]\n\t                                        }); });\n\t                                    }\n\t                                }\n\t                            });\n\t                        });\n\t                        return observable;\n\t                    }\n\t                    else {\n\t                        var id_1 = idOrIds;\n\t                        return new Observable_1.Observable(function subscribe(observer) {\n\t                            self_1.get(id_1).then(function (item) {\n\t                                if (!item) {\n\t                                    observer.error(new Error(\"ID \\\"\" + id_1 + \"\\\" not found in store\"));\n\t                                }\n\t                                else {\n\t                                    if (state_1.itemObservers.has(id_1)) {\n\t                                        state_1.itemObservers.get(id_1).push(observer);\n\t                                    }\n\t                                    else {\n\t                                        state_1.itemObservers.set(id_1, [observer]);\n\t                                    }\n\t                                    observer.next(item);\n\t                                }\n\t                            });\n\t                        });\n\t                    }\n\t                }\n\t                else {\n\t                    return instanceStateMap.get(this).storeObservable;\n\t                }\n\t            }\n\t        },\n\t        aspectAdvice: {\n\t            after: {\n\t                /**\n\t                 * After fetching, sends updates if no query was used. If a custom query was used then the data retrieved\n\t                 * is not indicative of the local data and can't be used. We shouldn't apply the query locally because we\n\t                 * have no knowledge of the underlying storage implementation or the amount of data and it may be too much\n\t                 * data to retrieve or update in memory. If this is the initialFetch, don't update since that update\n\t                 * will be sent to each subscriber at the time of subscription. If we're not sending updates, still set\n\t                 * the local data and index to the newly retrieved data.\n\t                 * @param result\n\t                 * @param query\n\t                 * @returns {Promise<T[]>}\n\t                 */\n\t                fetch: function (result, query) {\n\t                    var _this = this;\n\t                    if (!query) {\n\t                        result.then(function (data) {\n\t                            var state = instanceStateMap.get(_this);\n\t                            if (result !== state.initialFetch) {\n\t                                sendUpdates(_this, data);\n\t                            }\n\t                            else {\n\t                                state.localData = data;\n\t                                state.localIndex = buildIndex(_this.identify(data));\n\t                            }\n\t                        }, \n\t                        // Ignore errors here, they should be handled by the caller not observers\n\t                        function () { });\n\t                    }\n\t                    return result;\n\t                },\n\t                /**\n\t                 * After the put is completed, notify the item observers, and then either queue a fetch to send updates\n\t                 * if fetchAroundUpdates is true, or just send updates if not.\n\t                 * @param result\n\t                 * @returns {StoreObservable<T, any>}\n\t                 */\n\t                put: function (result) {\n\t                    var _this = this;\n\t                    result.then(function (updatedItems) {\n\t                        var state = instanceStateMap.get(_this);\n\t                        notifyItemObservers(updatedItems, [], state, _this);\n\t                        sendUpdatesOrFetch(state, _this, updatedItems, [], []);\n\t                    }, \n\t                    // Ignore errors here, they should be handled by the caller not observers\n\t                    function () { });\n\t                    return result;\n\t                },\n\t                /**\n\t                 * After the patch is completed, notify the item observers, and then either queue a fetch to send updates\n\t                 * if fetchAroundUpdates is true, or just send updates if not.\n\t                 * @param result\n\t                 * @returns {StoreObservable<T, any>}\n\t                 */\n\t                patch: function (result) {\n\t                    var _this = this;\n\t                    result.then(function (updatedItems) {\n\t                        var state = instanceStateMap.get(_this);\n\t                        notifyItemObservers(updatedItems, [], state, _this);\n\t                        sendUpdatesOrFetch(state, _this, updatedItems, [], []);\n\t                    }, \n\t                    // Ignore errors here, they should be handled by the caller not observers\n\t                    function () { });\n\t                    return result;\n\t                },\n\t                /**\n\t                 * After the add is completed notify observers. If this is the initial add AND we are fetching around\n\t                 * updates, then the first update to subscribers will already contain this data, since the initial fetch\n\t                 * is performed after the initial add. In this case we do not need to send an update. We can tell this\n\t                 * is the first add because it'll be triggered in the createStore base before the state is created for\n\t                 * this instance in the mixin's initializer\n\t                 * @param result\n\t                 * @returns {StoreObservable<T, U>}\n\t                 */\n\t                add: function (result) {\n\t                    var _this = this;\n\t                    var isFirstAdd = !instanceStateMap.get(this);\n\t                    result.then(function (addedItems) {\n\t                        var state = instanceStateMap.get(_this);\n\t                        if (!isFirstAdd || !state.fetchAroundUpdates) {\n\t                            sendUpdatesOrFetch(state, _this, [], addedItems, []);\n\t                        }\n\t                    }, \n\t                    // Ignore errors here, they should be handled by the caller not observers\n\t                    function () { });\n\t                    return result;\n\t                },\n\t                /**\n\t                 * After the items are deleted, notify item set observers of the deletion of one of the items they are\n\t                 * observing, and then complete any observables that need to be completed.\n\t                 * Completing observables is dones as follows\n\t                 * \t- For observers of a single item, just complete the observer\n\t                 * \t- For observers of a set of items\n\t                 * \t\t- Remove the deleted ID of this item from the set of observed IDs\n\t                 * \t\t- If there are now no observed IDs for the set, complete the observable\n\t                 * \t- Remove the item observer entry for the deleted ID\n\t                 * @param result\n\t                 * @param ids\n\t                 * @returns {StoreObservable<string, any>}\n\t                 */\n\t                delete: function (result, ids) {\n\t                    var _this = this;\n\t                    result.then(function (deleted) {\n\t                        var state = instanceStateMap.get(_this);\n\t                        notifyItemObservers(null, deleted, state, _this);\n\t                        deleted.forEach(function (id) {\n\t                            if (state.itemObservers.has(id)) {\n\t                                state.itemObservers.get(id).forEach(function (observerOrEntry) {\n\t                                    if (isObserver(observerOrEntry)) {\n\t                                        observerOrEntry.complete();\n\t                                    }\n\t                                    else {\n\t                                        observerOrEntry.observes.delete(id);\n\t                                        if (!observerOrEntry.observes.size) {\n\t                                            observerOrEntry.observer.complete();\n\t                                        }\n\t                                    }\n\t                                });\n\t                                state.itemObservers.delete(id);\n\t                            }\n\t                        });\n\t                        sendUpdatesOrFetch(state, _this, [], [], deleted);\n\t                    }, \n\t                    // Ignore errors here, they should be handled by the caller not observers\n\t                    function () { });\n\t                    return result;\n\t                }\n\t            }\n\t        },\n\t        initialize: function (instance, options) {\n\t            options = options || {};\n\t            var itemObservers = new Map_1.default();\n\t            var storeObservable = new Observable_1.Observable(function (observer) {\n\t                var state = instanceStateMap.get(this);\n\t                state.observers.push(observer);\n\t                if (state.initialFetch) {\n\t                    state.initialFetch.then(function () {\n\t                        observer.next({\n\t                            updates: [],\n\t                            deletes: [],\n\t                            adds: [],\n\t                            beforeAll: [],\n\t                            afterAll: state.localData.slice()\n\t                        });\n\t                    });\n\t                }\n\t                else {\n\t                    observer.next({\n\t                        updates: [],\n\t                        deletes: [],\n\t                        adds: [],\n\t                        beforeAll: [],\n\t                        afterAll: state.localData.slice()\n\t                    });\n\t                }\n\t                return function () {\n\t                    function remove(observer) {\n\t                        state.observers.splice(state.observers.indexOf(observer), 1);\n\t                    }\n\t                    setTimeout(function () {\n\t                        remove(observer);\n\t                    });\n\t                };\n\t            }.bind(instance));\n\t            var state = {\n\t                fetchAroundUpdates: Boolean(options.fetchAroundUpdates),\n\t                fetchAndSendUpdates: util_1.debounce(function (store) {\n\t                    store.fetch();\n\t                }, options.fetchAroundUpdateDebounce || 20),\n\t                itemObservers: itemObservers,\n\t                observers: [],\n\t                storeObservable: storeObservable,\n\t                localData: [],\n\t                localIndex: new Map_1.default()\n\t            };\n\t            if (options.fetchAroundUpdates) {\n\t                state.initialFetch = instance.fetch();\n\t            }\n\t            instanceStateMap.set(instance, state);\n\t        }\n\t    };\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createObservableStoreMixin;\n\texports.createObservableStore = createStore_1.default\n\t    .mixin(createObservableStoreMixin());\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t\"use strict\";\n\tvar decorators_1 = __webpack_require__(23);\n\tvar global_1 = __webpack_require__(12);\n\tvar iterator_1 = __webpack_require__(18);\n\t__webpack_require__(20);\n\tvar Shim;\n\t(function (Shim) {\n\t    var Set = (function () {\n\t        function Set(iterable) {\n\t            var _this = this;\n\t            this._setData = [];\n\t            this[Symbol.toStringTag] = 'Set';\n\t            if (iterable) {\n\t                iterator_1.forOf(iterable, function (value) { return _this.add(value); });\n\t            }\n\t        }\n\t        ;\n\t        Set.prototype.add = function (value) {\n\t            if (this.has(value)) {\n\t                return this;\n\t            }\n\t            this._setData.push(value);\n\t            return this;\n\t        };\n\t        ;\n\t        Set.prototype.clear = function () {\n\t            this._setData.length = 0;\n\t        };\n\t        ;\n\t        Set.prototype.delete = function (value) {\n\t            var idx = this._setData.indexOf(value);\n\t            if (idx === -1) {\n\t                return false;\n\t            }\n\t            this._setData.splice(idx, 1);\n\t            return true;\n\t        };\n\t        ;\n\t        Set.prototype.entries = function () {\n\t            return new iterator_1.ShimIterator(this._setData.map(function (value) { return [value, value]; }));\n\t        };\n\t        ;\n\t        Set.prototype.forEach = function (callbackfn, thisArg) {\n\t            var iterator = this.values();\n\t            var result = iterator.next();\n\t            while (!result.done) {\n\t                callbackfn.call(thisArg, result.value, result.value, this);\n\t                result = iterator.next();\n\t            }\n\t        };\n\t        ;\n\t        Set.prototype.has = function (value) {\n\t            return this._setData.indexOf(value) > -1;\n\t        };\n\t        ;\n\t        Set.prototype.keys = function () {\n\t            return new iterator_1.ShimIterator(this._setData);\n\t        };\n\t        ;\n\t        Object.defineProperty(Set.prototype, \"size\", {\n\t            get: function () {\n\t                return this._setData.length;\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        ;\n\t        Set.prototype.values = function () {\n\t            return new iterator_1.ShimIterator(this._setData);\n\t        };\n\t        ;\n\t        Set.prototype[Symbol.iterator] = function () {\n\t            return new iterator_1.ShimIterator(this._setData);\n\t        };\n\t        ;\n\t        return Set;\n\t    }());\n\t    Shim.Set = Set;\n\t})(Shim = exports.Shim || (exports.Shim = {}));\n\tvar Set = (function () {\n\t    /* istanbul ignore next */\n\t    function Set(iterable) {\n\t        /* istanbul ignore next */\n\t        this[Symbol.toStringTag] = 'Set';\n\t    }\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.add = function (value) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.clear = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.delete = function (value) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.entries = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.forEach = function (callbackfn, thisArg) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.has = function (value) { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.keys = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    Object.defineProperty(Set.prototype, \"size\", {\n\t        /* istanbul ignore next */\n\t        get: function () { throw new Error('Abstract method'); },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype.values = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    /* istanbul ignore next */\n\t    Set.prototype[Symbol.iterator] = function () { throw new Error('Abstract method'); };\n\t    ;\n\t    return Set;\n\t}());\n\tSet = __decorate([\n\t    decorators_1.hasClass('es6-set', global_1.default.Set, Shim.Set)\n\t], Set);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Set;\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(15);\n\t/**\n\t * Wraps a setTimeout call in a handle, allowing the timeout to be cleared by calling destroy.\n\t *\n\t * @param callback Callback to be called when the timeout elapses\n\t * @param delay Number of milliseconds to wait before calling the callback\n\t * @return Handle which can be destroyed to clear the timeout\n\t */\n\tfunction createTimer(callback, delay) {\n\t    var timerId = setTimeout(callback, delay);\n\t    return lang_1.createHandle(function () {\n\t        if (timerId) {\n\t            clearTimeout(timerId);\n\t            timerId = null;\n\t        }\n\t    });\n\t}\n\texports.createTimer = createTimer;\n\t/**\n\t * Wraps a callback, returning a function which fires after no further calls are received over a set interval.\n\t *\n\t * @param callback Callback to wrap\n\t * @param delay Number of milliseconds to wait after any invocations before calling the original callback\n\t * @return Debounced function\n\t */\n\tfunction debounce(callback, delay) {\n\t    // node.d.ts clobbers setTimeout/clearTimeout with versions that return/receive NodeJS.Timer,\n\t    // but browsers return/receive a number\n\t    var timer;\n\t    return function () {\n\t        timer && clearTimeout(timer);\n\t        var context = this;\n\t        var args = arguments;\n\t        timer = setTimeout(function () {\n\t            callback.apply(context, args);\n\t            args = context = timer = null;\n\t        }, delay);\n\t    };\n\t}\n\texports.debounce = debounce;\n\t/**\n\t * Wraps a callback, returning a function which fires at most once per set interval.\n\t *\n\t * @param callback Callback to wrap\n\t * @param delay Number of milliseconds to wait before allowing the original callback to be called again\n\t * @return Throttled function\n\t */\n\tfunction throttle(callback, delay) {\n\t    var ran;\n\t    return function () {\n\t        if (ran) {\n\t            return;\n\t        }\n\t        ran = true;\n\t        callback.apply(this, arguments);\n\t        setTimeout(function () {\n\t            ran = null;\n\t        }, delay);\n\t    };\n\t}\n\texports.throttle = throttle;\n\t/**\n\t * Like throttle, but calls the callback at the end of each interval rather than the beginning.\n\t * Useful for e.g. resize or scroll events, when debounce would appear unresponsive.\n\t *\n\t * @param callback Callback to wrap\n\t * @param delay Number of milliseconds to wait before calling the original callback and allowing it to be called again\n\t * @return Throttled function\n\t */\n\tfunction throttleAfter(callback, delay) {\n\t    var ran;\n\t    return function () {\n\t        if (ran) {\n\t            return;\n\t        }\n\t        ran = true;\n\t        var context = this;\n\t        var args = arguments;\n\t        setTimeout(function () {\n\t            callback.apply(context, args);\n\t            args = context = ran = null;\n\t        }, delay);\n\t    };\n\t}\n\texports.throttleAfter = throttleAfter;\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createObservableStore_1 = __webpack_require__(43);\n\tvar widgetStoreActions_1 = __webpack_require__(41);\n\tvar todoStore = createObservableStore_1.default({\n\t    data: [],\n\t    fetchAroundUpdates: true\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = todoStore;\n\tfunction bindActions() {\n\t    return todoStore\n\t        .observe()\n\t        .subscribe(function (options) {\n\t        widgetStoreActions_1.putTodo(options);\n\t    });\n\t}\n\texports.bindActions = bindActions;\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __assign = (this && this.__assign) || Object.assign || function(t) {\n\t    for (var s, i = 1, n = arguments.length; i < n; i++) {\n\t        s = arguments[i];\n\t        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n\t            t[p] = s[p];\n\t    }\n\t    return t;\n\t};\n\t\"use strict\";\n\tvar createProjector_1 = __webpack_require__(59);\n\tvar externalState_1 = __webpack_require__(67);\n\tvar d_1 = __webpack_require__(62);\n\tvar createTodoDetails_1 = __webpack_require__(68);\n\tvar FactoryRegistry_1 = __webpack_require__(64);\n\tvar createHome_1 = __webpack_require__(76);\n\tvar widgetRegistry = new FactoryRegistry_1.default();\n\twidgetRegistry.define('main', createHome_1.default);\n\twidgetRegistry.define('todo-details', createTodoDetails_1.default);\n\tvar createApp = createProjector_1.default\n\t    .mixin(externalState_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        registry: widgetRegistry,\n\t        getChildrenNodes: function () {\n\t            var _this = this;\n\t            var _a = this.state.widgets, widgets = _a === void 0 ? [['main', {}]] : _a;\n\t            return widgets.map(function (widget) {\n\t                return d_1.w(widget[0], __assign({}, _this.state, widget[1], { id: widget[0] }));\n\t            });\n\t        },\n\t        classes: ['todoapp'],\n\t        tagName: 'section'\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createApp;\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar createProjectorMixin_1 = __webpack_require__(66);\n\t/**\n\t * Projector Factory\n\t */\n\tvar createProjector = createWidgetBase_1.default\n\t    .mixin(createProjectorMixin_1.default);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createProjector;\n\t__export(__webpack_require__(66));\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(7);\n\tvar createStateful_1 = __webpack_require__(61);\n\tvar lang_1 = __webpack_require__(15);\n\tvar WeakMap_1 = __webpack_require__(22);\n\tvar Map_1 = __webpack_require__(29);\n\tvar d_1 = __webpack_require__(62);\n\tvar FactoryRegistry_1 = __webpack_require__(64);\n\tvar shallowPropertyComparisonMixin_1 = __webpack_require__(65);\n\t/**\n\t * Internal state map for widget instances\n\t */\n\tvar widgetInternalStateMap = new WeakMap_1.default();\n\tfunction isWNode(child) {\n\t    return Boolean(child && child.factory !== undefined);\n\t}\n\tfunction getFromRegistry(instance, factoryLabel) {\n\t    if (instance.registry.has(factoryLabel)) {\n\t        return instance.registry.get(factoryLabel);\n\t    }\n\t    return d_1.registry.get(factoryLabel);\n\t}\n\tfunction dNodeToVNode(instance, dNode) {\n\t    var internalState = widgetInternalStateMap.get(instance);\n\t    if (typeof dNode === 'string' || dNode === null) {\n\t        return dNode;\n\t    }\n\t    if (isWNode(dNode)) {\n\t        var children = dNode.children, properties = dNode.properties;\n\t        var id = properties.id;\n\t        var factory = dNode.factory;\n\t        var child = void 0;\n\t        if (typeof factory === 'string') {\n\t            var item = getFromRegistry(instance, factory);\n\t            if (compose_1.isComposeFactory(item)) {\n\t                factory = item;\n\t            }\n\t            else {\n\t                if (item && !internalState.initializedFactoryMap.has(factory)) {\n\t                    var promise = item.then(function (factory) {\n\t                        instance.invalidate();\n\t                        return factory;\n\t                    });\n\t                    internalState.initializedFactoryMap.set(factory, promise);\n\t                }\n\t                return null;\n\t            }\n\t        }\n\t        var childrenMapKey = id || factory;\n\t        var cachedChild = internalState.historicChildrenMap.get(childrenMapKey);\n\t        if (cachedChild) {\n\t            child = cachedChild;\n\t            if (properties) {\n\t                child.setProperties(properties);\n\t            }\n\t        }\n\t        else {\n\t            child = factory({ properties: properties });\n\t            child.own(child.on('invalidated', function () {\n\t                instance.invalidate();\n\t            }));\n\t            internalState.historicChildrenMap.set(childrenMapKey, child);\n\t            instance.own(child);\n\t        }\n\t        if (!id && internalState.currentChildrenMap.has(factory)) {\n\t            var errorMsg = 'must provide unique keys when using the same widget factory multiple times';\n\t            console.error(errorMsg);\n\t            instance.emit({ type: 'error', target: instance, error: new Error(errorMsg) });\n\t        }\n\t        child.children = children;\n\t        internalState.currentChildrenMap.set(childrenMapKey, child);\n\t        return child.__render__();\n\t    }\n\t    dNode.children = dNode.children\n\t        .filter(function (child) { return child !== null; })\n\t        .map(function (child) {\n\t        return dNodeToVNode(instance, child);\n\t    });\n\t    return dNode.render({ bind: instance });\n\t}\n\tfunction manageDetachedChildren(instance) {\n\t    var internalState = widgetInternalStateMap.get(instance);\n\t    internalState.historicChildrenMap.forEach(function (child, key) {\n\t        if (!internalState.currentChildrenMap.has(key)) {\n\t            internalState.historicChildrenMap.delete(key);\n\t            child.destroy();\n\t        }\n\t    });\n\t    internalState.currentChildrenMap.clear();\n\t}\n\tfunction formatTagNameAndClasses(tagName, classes) {\n\t    if (classes.length) {\n\t        return tagName + \".\" + classes.join('.');\n\t    }\n\t    return tagName;\n\t}\n\tvar createWidget = createStateful_1.default\n\t    .mixin({\n\t    mixin: {\n\t        properties: {},\n\t        classes: [],\n\t        getNode: function () {\n\t            var tag = formatTagNameAndClasses(this.tagName, this.classes);\n\t            return d_1.v(tag, this.getNodeAttributes(), this.getChildrenNodes());\n\t        },\n\t        set children(children) {\n\t            var internalState = widgetInternalStateMap.get(this);\n\t            internalState.children = children;\n\t            this.emit({\n\t                type: 'widget:children',\n\t                target: this\n\t            });\n\t        },\n\t        get children() {\n\t            return widgetInternalStateMap.get(this).children;\n\t        },\n\t        getChildrenNodes: function () {\n\t            return this.children;\n\t        },\n\t        getNodeAttributes: function (overrides) {\n\t            var _this = this;\n\t            var props = {};\n\t            this.nodeAttributes.forEach(function (fn) {\n\t                var newProps = fn.call(_this);\n\t                if (newProps) {\n\t                    lang_1.assign(props, newProps);\n\t                }\n\t            });\n\t            return props;\n\t        },\n\t        invalidate: function () {\n\t            var internalState = widgetInternalStateMap.get(this);\n\t            internalState.dirty = true;\n\t            this.emit({\n\t                type: 'invalidated',\n\t                target: this\n\t            });\n\t        },\n\t        get id() {\n\t            return this.properties.id;\n\t        },\n\t        setProperties: function (properties) {\n\t            var internalState = widgetInternalStateMap.get(this);\n\t            var changedPropertyKeys = this.diffProperties(internalState.previousProperties, properties);\n\t            this.properties = this.assignProperties(internalState.previousProperties, properties, changedPropertyKeys);\n\t            if (changedPropertyKeys.length) {\n\t                this.emit({\n\t                    type: 'properties:changed',\n\t                    target: this,\n\t                    properties: this.properties,\n\t                    changedPropertyKeys: changedPropertyKeys\n\t                });\n\t            }\n\t            internalState.previousProperties = this.properties;\n\t        },\n\t        diffProperties: function (previousProperties, newProperties) {\n\t            return Object.keys(newProperties);\n\t        },\n\t        assignProperties: function (previousProperties, newProperties, changedPropertyKeys) {\n\t            return lang_1.assign({}, newProperties);\n\t        },\n\t        onPropertiesChanged: function (properties, changedPropertyKeys) {\n\t            var state = changedPropertyKeys.reduce(function (state, key) {\n\t                var property = properties[key];\n\t                if (!(typeof property === 'function')) {\n\t                    state[key] = property;\n\t                }\n\t                return state;\n\t            }, {});\n\t            this.setState(state);\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                var baseIdProp = this.state && this.state.id ? { 'data-widget-id': this.state.id } : {};\n\t                var _a = (this.state || {}).styles, styles = _a === void 0 ? {} : _a;\n\t                var classes = {};\n\t                var internalState = widgetInternalStateMap.get(this);\n\t                internalState.widgetClasses.forEach(function (c) { return classes[c] = false; });\n\t                if (this.state && this.state.classes) {\n\t                    this.state.classes.forEach(function (c) { return classes[c] = true; });\n\t                    internalState.widgetClasses = this.state.classes;\n\t                }\n\t                return lang_1.assign(baseIdProp, { key: this, classes: classes, styles: styles });\n\t            }\n\t        ],\n\t        __render__: function () {\n\t            var internalState = widgetInternalStateMap.get(this);\n\t            if (internalState.dirty || !internalState.cachedVNode) {\n\t                var widget = dNodeToVNode(this, this.getNode());\n\t                manageDetachedChildren(this);\n\t                if (widget) {\n\t                    internalState.cachedVNode = widget;\n\t                }\n\t                internalState.dirty = false;\n\t                return widget;\n\t            }\n\t            return internalState.cachedVNode;\n\t        },\n\t        get registry() {\n\t            return widgetInternalStateMap.get(this).factoryRegistry;\n\t        },\n\t        tagName: 'div'\n\t    },\n\t    initialize: function (instance, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var tagName = options.tagName, _a = options.properties, properties = _a === void 0 ? {} : _a;\n\t        instance.tagName = tagName || instance.tagName;\n\t        widgetInternalStateMap.set(instance, {\n\t            dirty: true,\n\t            widgetClasses: [],\n\t            previousProperties: {},\n\t            factoryRegistry: new FactoryRegistry_1.default(),\n\t            initializedFactoryMap: new Map_1.default(),\n\t            historicChildrenMap: new Map_1.default(),\n\t            currentChildrenMap: new Map_1.default(),\n\t            children: []\n\t        });\n\t        instance.own(instance.on('properties:changed', function (evt) {\n\t            instance.onPropertiesChanged(evt.properties, evt.changedPropertyKeys);\n\t        }));\n\t        instance.own(instance.on('state:changed', function () {\n\t            instance.invalidate();\n\t        }));\n\t        instance.setProperties(properties);\n\t    }\n\t})\n\t    .mixin(shallowPropertyComparisonMixin_1.default);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createWidget;\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(15);\n\tvar WeakMap_1 = __webpack_require__(22);\n\tvar createEvented_1 = __webpack_require__(27);\n\t/**\n\t * Private map of internal instance state.\n\t */\n\tvar instanceStateMap = new WeakMap_1.default();\n\t/**\n\t * State change event type\n\t */\n\tvar stateChangedEventType = 'state:changed';\n\t/**\n\t * Create an instance of a stateful object\n\t */\n\tvar createStateful = createEvented_1.default\n\t    .mixin({\n\t    className: 'Stateful',\n\t    mixin: {\n\t        get state() {\n\t            return instanceStateMap.get(this);\n\t        },\n\t        setState: function (value) {\n\t            var oldState = instanceStateMap.get(this);\n\t            var state = lang_1.deepAssign({}, oldState, value);\n\t            var eventObject = {\n\t                type: stateChangedEventType,\n\t                state: state,\n\t                target: this\n\t            };\n\t            instanceStateMap.set(this, state);\n\t            this.emit(eventObject);\n\t        }\n\t    },\n\t    initialize: function (instance) {\n\t        instanceStateMap.set(instance, Object.create(null));\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createStateful;\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(15);\n\tvar maquette_1 = __webpack_require__(63);\n\tvar FactoryRegistry_1 = __webpack_require__(64);\n\texports.registry = new FactoryRegistry_1.default();\n\tfunction w(factory, properties, children) {\n\t    if (children === void 0) { children = []; }\n\t    return {\n\t        children: children,\n\t        factory: factory,\n\t        properties: properties\n\t    };\n\t}\n\texports.w = w;\n\tfunction v(tag, propertiesOrChildren, children) {\n\t    if (propertiesOrChildren === void 0) { propertiesOrChildren = {}; }\n\t    if (children === void 0) { children = []; }\n\t    if (Array.isArray(propertiesOrChildren)) {\n\t        children = propertiesOrChildren;\n\t        propertiesOrChildren = {};\n\t    }\n\t    return {\n\t        children: children,\n\t        render: function (options) {\n\t            if (options === void 0) { options = {}; }\n\t            return maquette_1.h(tag, lang_1.assign(options, propertiesOrChildren), this.children);\n\t        }\n\t    };\n\t}\n\texports.v = v;\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n\t        // CommonJS\n\t        factory(exports);\n\t    } else {\n\t        // Browser globals\n\t        factory(root.maquette = {});\n\t    }\n\t}(this, function (exports) {\n\t    'use strict';\n\t    ;\n\t    ;\n\t    ;\n\t    ;\n\t    var NAMESPACE_W3 = 'http://www.w3.org/';\n\t    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\n\t    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n\t    // Utilities\n\t    var emptyArray = [];\n\t    var extend = function (base, overrides) {\n\t        var result = {};\n\t        Object.keys(base).forEach(function (key) {\n\t            result[key] = base[key];\n\t        });\n\t        if (overrides) {\n\t            Object.keys(overrides).forEach(function (key) {\n\t                result[key] = overrides[key];\n\t            });\n\t        }\n\t        return result;\n\t    };\n\t    // Hyperscript helper functions\n\t    var same = function (vnode1, vnode2) {\n\t        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n\t            return false;\n\t        }\n\t        if (vnode1.properties && vnode2.properties) {\n\t            if (vnode1.properties.key !== vnode2.properties.key) {\n\t                return false;\n\t            }\n\t            return vnode1.properties.bind === vnode2.properties.bind;\n\t        }\n\t        return !vnode1.properties && !vnode2.properties;\n\t    };\n\t    var toTextVNode = function (data) {\n\t        return {\n\t            vnodeSelector: '',\n\t            properties: undefined,\n\t            children: undefined,\n\t            text: data.toString(),\n\t            domNode: null\n\t        };\n\t    };\n\t    var appendChildren = function (parentSelector, insertions, main) {\n\t        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\n\t            var item = insertions[i];\n\t            if (Array.isArray(item)) {\n\t                appendChildren(parentSelector, item, main);\n\t            } else {\n\t                if (item !== null && item !== undefined) {\n\t                    if (!item.hasOwnProperty('vnodeSelector')) {\n\t                        item = toTextVNode(item);\n\t                    }\n\t                    main.push(item);\n\t                }\n\t            }\n\t        }\n\t    };\n\t    // Render helper functions\n\t    var missingTransition = function () {\n\t        throw new Error('Provide a transitions object to the projectionOptions to do animations');\n\t    };\n\t    var DEFAULT_PROJECTION_OPTIONS = {\n\t        namespace: undefined,\n\t        eventHandlerInterceptor: undefined,\n\t        styleApplyer: function (domNode, styleName, value) {\n\t            // Provides a hook to add vendor prefixes for browsers that still need it.\n\t            domNode.style[styleName] = value;\n\t        },\n\t        transitions: {\n\t            enter: missingTransition,\n\t            exit: missingTransition\n\t        }\n\t    };\n\t    var applyDefaultProjectionOptions = function (projectorOptions) {\n\t        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n\t    };\n\t    var checkStyleValue = function (styleValue) {\n\t        if (typeof styleValue !== 'string') {\n\t            throw new Error('Style values must be strings');\n\t        }\n\t    };\n\t    var setProperties = function (domNode, properties, projectionOptions) {\n\t        if (!properties) {\n\t            return;\n\t        }\n\t        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n\t        var propNames = Object.keys(properties);\n\t        var propCount = propNames.length;\n\t        for (var i = 0; i < propCount; i++) {\n\t            var propName = propNames[i];\n\t            /* tslint:disable:no-var-keyword: edge case */\n\t            var propValue = properties[propName];\n\t            /* tslint:enable:no-var-keyword */\n\t            if (propName === 'className') {\n\t                throw new Error('Property \"className\" is not supported, use \"class\".');\n\t            } else if (propName === 'class') {\n\t                propValue.split(/\\s+/).forEach(function (token) {\n\t                    return domNode.classList.add(token);\n\t                });\n\t            } else if (propName === 'classes') {\n\t                // object with string keys and boolean values\n\t                var classNames = Object.keys(propValue);\n\t                var classNameCount = classNames.length;\n\t                for (var j = 0; j < classNameCount; j++) {\n\t                    var className = classNames[j];\n\t                    if (propValue[className]) {\n\t                        domNode.classList.add(className);\n\t                    }\n\t                }\n\t            } else if (propName === 'styles') {\n\t                // object with string keys and string (!) values\n\t                var styleNames = Object.keys(propValue);\n\t                var styleCount = styleNames.length;\n\t                for (var j = 0; j < styleCount; j++) {\n\t                    var styleName = styleNames[j];\n\t                    var styleValue = propValue[styleName];\n\t                    if (styleValue) {\n\t                        checkStyleValue(styleValue);\n\t                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n\t                    }\n\t                }\n\t            } else if (propName === 'key') {\n\t                continue;\n\t            } else if (propValue === null || propValue === undefined) {\n\t                continue;\n\t            } else {\n\t                var type = typeof propValue;\n\t                if (type === 'function') {\n\t                    if (propName.lastIndexOf('on', 0) === 0) {\n\t                        if (eventHandlerInterceptor) {\n\t                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers\n\t                        }\n\t                        if (propName === 'oninput') {\n\t                            (function () {\n\t                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n\t                                var oldPropValue = propValue;\n\t                                propValue = function (evt) {\n\t                                    evt.target['oninput-value'] = evt.target.value;\n\t                                    // may be HTMLTextAreaElement as well\n\t                                    oldPropValue.apply(this, [evt]);\n\t                                };\n\t                            }());\n\t                        }\n\t                        domNode[propName] = propValue;\n\t                    }\n\t                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n\t                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n\t                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n\t                    } else {\n\t                        domNode.setAttribute(propName, propValue);\n\t                    }\n\t                } else {\n\t                    domNode[propName] = propValue;\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n\t        if (!properties) {\n\t            return;\n\t        }\n\t        var propertiesUpdated = false;\n\t        var propNames = Object.keys(properties);\n\t        var propCount = propNames.length;\n\t        for (var i = 0; i < propCount; i++) {\n\t            var propName = propNames[i];\n\t            // assuming that properties will be nullified instead of missing is by design\n\t            var propValue = properties[propName];\n\t            var previousValue = previousProperties[propName];\n\t            if (propName === 'class') {\n\t                if (previousValue !== propValue) {\n\t                    throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n\t                }\n\t            } else if (propName === 'classes') {\n\t                var classList = domNode.classList;\n\t                var classNames = Object.keys(propValue);\n\t                var classNameCount = classNames.length;\n\t                for (var j = 0; j < classNameCount; j++) {\n\t                    var className = classNames[j];\n\t                    var on = !!propValue[className];\n\t                    var previousOn = !!previousValue[className];\n\t                    if (on === previousOn) {\n\t                        continue;\n\t                    }\n\t                    propertiesUpdated = true;\n\t                    if (on) {\n\t                        classList.add(className);\n\t                    } else {\n\t                        classList.remove(className);\n\t                    }\n\t                }\n\t            } else if (propName === 'styles') {\n\t                var styleNames = Object.keys(propValue);\n\t                var styleCount = styleNames.length;\n\t                for (var j = 0; j < styleCount; j++) {\n\t                    var styleName = styleNames[j];\n\t                    var newStyleValue = propValue[styleName];\n\t                    var oldStyleValue = previousValue[styleName];\n\t                    if (newStyleValue === oldStyleValue) {\n\t                        continue;\n\t                    }\n\t                    propertiesUpdated = true;\n\t                    if (newStyleValue) {\n\t                        checkStyleValue(newStyleValue);\n\t                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n\t                    } else {\n\t                        projectionOptions.styleApplyer(domNode, styleName, '');\n\t                    }\n\t                }\n\t            } else {\n\t                if (!propValue && typeof previousValue === 'string') {\n\t                    propValue = '';\n\t                }\n\t                if (propName === 'value') {\n\t                    if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n\t                        domNode[propName] = propValue;\n\t                        // Reset the value, even if the virtual DOM did not change\n\t                        domNode['oninput-value'] = undefined;\n\t                    }\n\t                    // else do not update the domNode, otherwise the cursor position would be changed\n\t                    if (propValue !== previousValue) {\n\t                        propertiesUpdated = true;\n\t                    }\n\t                } else if (propValue !== previousValue) {\n\t                    var type = typeof propValue;\n\t                    if (type === 'function') {\n\t                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');\n\t                    }\n\t                    if (type === 'string' && propName !== 'innerHTML') {\n\t                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n\t                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n\t                        } else {\n\t                            domNode.setAttribute(propName, propValue);\n\t                        }\n\t                    } else {\n\t                        if (domNode[propName] !== propValue) {\n\t                            domNode[propName] = propValue;\n\t                        }\n\t                    }\n\t                    propertiesUpdated = true;\n\t                }\n\t            }\n\t        }\n\t        return propertiesUpdated;\n\t    };\n\t    var findIndexOfChild = function (children, sameAs, start) {\n\t        if (sameAs.vnodeSelector !== '') {\n\t            // Never scan for text-nodes\n\t            for (var i = start; i < children.length; i++) {\n\t                if (same(children[i], sameAs)) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    var nodeAdded = function (vNode, transitions) {\n\t        if (vNode.properties) {\n\t            var enterAnimation = vNode.properties.enterAnimation;\n\t            if (enterAnimation) {\n\t                if (typeof enterAnimation === 'function') {\n\t                    enterAnimation(vNode.domNode, vNode.properties);\n\t                } else {\n\t                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var nodeToRemove = function (vNode, transitions) {\n\t        var domNode = vNode.domNode;\n\t        if (vNode.properties) {\n\t            var exitAnimation = vNode.properties.exitAnimation;\n\t            if (exitAnimation) {\n\t                domNode.style.pointerEvents = 'none';\n\t                var removeDomNode = function () {\n\t                    if (domNode.parentNode) {\n\t                        domNode.parentNode.removeChild(domNode);\n\t                    }\n\t                };\n\t                if (typeof exitAnimation === 'function') {\n\t                    exitAnimation(domNode, removeDomNode, vNode.properties);\n\t                    return;\n\t                } else {\n\t                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n\t                    return;\n\t                }\n\t            }\n\t        }\n\t        if (domNode.parentNode) {\n\t            domNode.parentNode.removeChild(domNode);\n\t        }\n\t    };\n\t    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n\t        var childNode = childNodes[indexToCheck];\n\t        if (childNode.vnodeSelector === '') {\n\t            return;    // Text nodes need not be distinguishable\n\t        }\n\t        var properties = childNode.properties;\n\t        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;\n\t        if (!key) {\n\t            for (var i = 0; i < childNodes.length; i++) {\n\t                if (i !== indexToCheck) {\n\t                    var node = childNodes[i];\n\t                    if (same(node, childNode)) {\n\t                        if (operation === 'added') {\n\t                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n\t                        } else {\n\t                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var createDom;\n\t    var updateDom;\n\t    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n\t        if (oldChildren === newChildren) {\n\t            return false;\n\t        }\n\t        oldChildren = oldChildren || emptyArray;\n\t        newChildren = newChildren || emptyArray;\n\t        var oldChildrenLength = oldChildren.length;\n\t        var newChildrenLength = newChildren.length;\n\t        var transitions = projectionOptions.transitions;\n\t        var oldIndex = 0;\n\t        var newIndex = 0;\n\t        var i;\n\t        var textUpdated = false;\n\t        while (newIndex < newChildrenLength) {\n\t            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n\t            var newChild = newChildren[newIndex];\n\t            if (oldChild !== undefined && same(oldChild, newChild)) {\n\t                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n\t                oldIndex++;\n\t            } else {\n\t                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n\t                if (findOldIndex >= 0) {\n\t                    // Remove preceding missing children\n\t                    for (i = oldIndex; i < findOldIndex; i++) {\n\t                        nodeToRemove(oldChildren[i], transitions);\n\t                        checkDistinguishable(oldChildren, i, vnode, 'removed');\n\t                    }\n\t                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n\t                    oldIndex = findOldIndex + 1;\n\t                } else {\n\t                    // New child\n\t                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n\t                    nodeAdded(newChild, transitions);\n\t                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\n\t                }\n\t            }\n\t            newIndex++;\n\t        }\n\t        if (oldChildrenLength > oldIndex) {\n\t            // Remove child fragments\n\t            for (i = oldIndex; i < oldChildrenLength; i++) {\n\t                nodeToRemove(oldChildren[i], transitions);\n\t                checkDistinguishable(oldChildren, i, vnode, 'removed');\n\t            }\n\t        }\n\t        return textUpdated;\n\t    };\n\t    var addChildren = function (domNode, children, projectionOptions) {\n\t        if (!children) {\n\t            return;\n\t        }\n\t        for (var i = 0; i < children.length; i++) {\n\t            createDom(children[i], domNode, undefined, projectionOptions);\n\t        }\n\t    };\n\t    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n\t        addChildren(domNode, vnode.children, projectionOptions);\n\t        // children before properties, needed for value property of <select>.\n\t        if (vnode.text) {\n\t            domNode.textContent = vnode.text;\n\t        }\n\t        setProperties(domNode, vnode.properties, projectionOptions);\n\t        if (vnode.properties && vnode.properties.afterCreate) {\n\t            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [\n\t                domNode,\n\t                projectionOptions,\n\t                vnode.vnodeSelector,\n\t                vnode.properties,\n\t                vnode.children\n\t            ]);\n\t        }\n\t    };\n\t    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n\t        var domNode, i, c, start = 0, type, found;\n\t        var vnodeSelector = vnode.vnodeSelector;\n\t        if (vnodeSelector === '') {\n\t            domNode = vnode.domNode = document.createTextNode(vnode.text);\n\t            if (insertBefore !== undefined) {\n\t                parentNode.insertBefore(domNode, insertBefore);\n\t            } else {\n\t                parentNode.appendChild(domNode);\n\t            }\n\t        } else {\n\t            for (i = 0; i <= vnodeSelector.length; ++i) {\n\t                c = vnodeSelector.charAt(i);\n\t                if (i === vnodeSelector.length || c === '.' || c === '#') {\n\t                    type = vnodeSelector.charAt(start - 1);\n\t                    found = vnodeSelector.slice(start, i);\n\t                    if (type === '.') {\n\t                        domNode.classList.add(found);\n\t                    } else if (type === '#') {\n\t                        domNode.id = found;\n\t                    } else {\n\t                        if (found === 'svg') {\n\t                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n\t                        }\n\t                        if (projectionOptions.namespace !== undefined) {\n\t                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n\t                        } else {\n\t                            domNode = vnode.domNode = document.createElement(found);\n\t                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {\n\t                                // IE8 and older don't support setting input type after the DOM Node has been added to the document\n\t                                domNode.setAttribute('type', vnode.properties.type);\n\t                            }\n\t                        }\n\t                        if (insertBefore !== undefined) {\n\t                            parentNode.insertBefore(domNode, insertBefore);\n\t                        } else {\n\t                            parentNode.appendChild(domNode);\n\t                        }\n\t                    }\n\t                    start = i + 1;\n\t                }\n\t            }\n\t            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n\t        }\n\t    };\n\t    updateDom = function (previous, vnode, projectionOptions) {\n\t        var domNode = previous.domNode;\n\t        var textUpdated = false;\n\t        if (previous === vnode) {\n\t            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette\n\t        }\n\t        var updated = false;\n\t        if (vnode.vnodeSelector === '') {\n\t            if (vnode.text !== previous.text) {\n\t                var newVNode = document.createTextNode(vnode.text);\n\t                domNode.parentNode.replaceChild(newVNode, domNode);\n\t                vnode.domNode = newVNode;\n\t                textUpdated = true;\n\t                return textUpdated;\n\t            }\n\t        } else {\n\t            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n\t                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n\t            }\n\t            if (previous.text !== vnode.text) {\n\t                updated = true;\n\t                if (vnode.text === undefined) {\n\t                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably\n\t                } else {\n\t                    domNode.textContent = vnode.text;\n\t                }\n\t            }\n\t            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n\t            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n\t            if (vnode.properties && vnode.properties.afterUpdate) {\n\t                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [\n\t                    domNode,\n\t                    projectionOptions,\n\t                    vnode.vnodeSelector,\n\t                    vnode.properties,\n\t                    vnode.children\n\t                ]);\n\t            }\n\t        }\n\t        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n\t            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n\t        }\n\t        vnode.domNode = previous.domNode;\n\t        return textUpdated;\n\t    };\n\t    var createProjection = function (vnode, projectionOptions) {\n\t        return {\n\t            update: function (updatedVnode) {\n\t                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n\t                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n\t                }\n\t                updateDom(vnode, updatedVnode, projectionOptions);\n\t                vnode = updatedVnode;\n\t            },\n\t            domNode: vnode.domNode\n\t        };\n\t    };\n\t    ;\n\t    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.\n\t    exports.h = function (selector) {\n\t        var properties = arguments[1];\n\t        if (typeof selector !== 'string') {\n\t            throw new Error();\n\t        }\n\t        var childIndex = 1;\n\t        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n\t            childIndex = 2;\n\t        } else {\n\t            // Optional properties argument was omitted\n\t            properties = undefined;\n\t        }\n\t        var text = undefined;\n\t        var children = undefined;\n\t        var argsLength = arguments.length;\n\t        // Recognize a common special case where there is only a single text node\n\t        if (argsLength === childIndex + 1) {\n\t            var onlyChild = arguments[childIndex];\n\t            if (typeof onlyChild === 'string') {\n\t                text = onlyChild;\n\t            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n\t                text = onlyChild[0];\n\t            }\n\t        }\n\t        if (text === undefined) {\n\t            children = [];\n\t            for (; childIndex < argsLength; childIndex++) {\n\t                var child = arguments[childIndex];\n\t                if (child === null || child === undefined) {\n\t                    continue;\n\t                } else if (Array.isArray(child)) {\n\t                    appendChildren(selector, child, children);\n\t                } else if (child.hasOwnProperty('vnodeSelector')) {\n\t                    children.push(child);\n\t                } else {\n\t                    children.push(toTextVNode(child));\n\t                }\n\t            }\n\t        }\n\t        return {\n\t            vnodeSelector: selector,\n\t            properties: properties,\n\t            children: children,\n\t            text: text === '' ? undefined : text,\n\t            domNode: null\n\t        };\n\t    };\n\t    /**\n\t * Contains simple low-level utility functions to manipulate the real DOM.\n\t */\n\t    exports.dom = {\n\t        /**\n\t     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n\t     * its [[Projection.domNode|domNode]] property.\n\t     * This is a low-level method. Users will typically use a [[Projector]] instead.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n\t     * objects may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the projection.\n\t     * @returns The [[Projection]] which also contains the DOM Node that was created.\n\t     */\n\t        create: function (vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        },\n\t        /**\n\t     * Appends a new childnode to the DOM which is generated from a [[VNode]].\n\t     * This is a low-level method. Users will typically use a [[Projector]] instead.\n\t     * @param parentNode - The parent node for the new childNode.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n\t     * objects may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n\t     * @returns The [[Projection]] that was created.\n\t     */\n\t        append: function (parentNode, vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            createDom(vnode, parentNode, undefined, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        },\n\t        /**\n\t     * Inserts a new DOM node which is generated from a [[VNode]].\n\t     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n\t     * @param beforeNode - The node that the DOM Node is inserted before.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n\t     * NOTE: [[VNode]] objects may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n\t     * @returns The [[Projection]] that was created.\n\t     */\n\t        insertBefore: function (beforeNode, vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        },\n\t        /**\n\t     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n\t     * This means that the virtual DOM and the real DOM will have one overlapping element.\n\t     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n\t     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n\t     * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n\t     * may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n\t     * @returns The [[Projection]] that was created.\n\t     */\n\t        merge: function (element, vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            vnode.domNode = element;\n\t            initPropertiesAndChildren(element, vnode, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        }\n\t    };\n\t    /**\n\t * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n\t * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n\t * For more information, see [[CalculationCache]].\n\t *\n\t * @param <Result> The type of the value that is cached.\n\t */\n\t    exports.createCache = function () {\n\t        var cachedInputs = undefined;\n\t        var cachedOutcome = undefined;\n\t        var result = {\n\t            invalidate: function () {\n\t                cachedOutcome = undefined;\n\t                cachedInputs = undefined;\n\t            },\n\t            result: function (inputs, calculation) {\n\t                if (cachedInputs) {\n\t                    for (var i = 0; i < inputs.length; i++) {\n\t                        if (cachedInputs[i] !== inputs[i]) {\n\t                            cachedOutcome = undefined;\n\t                        }\n\t                    }\n\t                }\n\t                if (!cachedOutcome) {\n\t                    cachedOutcome = calculation();\n\t                    cachedInputs = inputs;\n\t                }\n\t                return cachedOutcome;\n\t            }\n\t        };\n\t        return result;\n\t    };\n\t    /**\n\t * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n\t * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n\t *\n\t * @param <Source>       The type of source items. A database-record for instance.\n\t * @param <Target>       The type of target items. A [[Component]] for instance.\n\t * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n\t * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n\t *                       to the `callback` argument in `Array.map(callback)`.\n\t * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n\t */\n\t    exports.createMapping = function (getSourceKey, createResult, updateResult) {\n\t        var keys = [];\n\t        var results = [];\n\t        return {\n\t            results: results,\n\t            map: function (newSources) {\n\t                var newKeys = newSources.map(getSourceKey);\n\t                var oldTargets = results.slice();\n\t                var oldIndex = 0;\n\t                for (var i = 0; i < newSources.length; i++) {\n\t                    var source = newSources[i];\n\t                    var sourceKey = newKeys[i];\n\t                    if (sourceKey === keys[oldIndex]) {\n\t                        results[i] = oldTargets[oldIndex];\n\t                        updateResult(source, oldTargets[oldIndex], i);\n\t                        oldIndex++;\n\t                    } else {\n\t                        var found = false;\n\t                        for (var j = 1; j < keys.length + 1; j++) {\n\t                            var searchIndex = (oldIndex + j) % keys.length;\n\t                            if (keys[searchIndex] === sourceKey) {\n\t                                results[i] = oldTargets[searchIndex];\n\t                                updateResult(newSources[i], oldTargets[searchIndex], i);\n\t                                oldIndex = searchIndex + 1;\n\t                                found = true;\n\t                                break;\n\t                            }\n\t                        }\n\t                        if (!found) {\n\t                            results[i] = createResult(source, i);\n\t                        }\n\t                    }\n\t                }\n\t                results.length = newSources.length;\n\t                keys = newKeys;\n\t            }\n\t        };\n\t    };\n\t    /**\n\t * Creates a [[Projector]] instance using the provided projectionOptions.\n\t *\n\t * For more information, see [[Projector]].\n\t *\n\t * @param projectionOptions   Options that influence how the DOM is rendered and updated.\n\t */\n\t    exports.createProjector = function (projectorOptions) {\n\t        var projector;\n\t        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n\t        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n\t            return function () {\n\t                // intercept function calls (event handlers) to do a render afterwards.\n\t                projector.scheduleRender();\n\t                return eventHandler.apply(properties.bind || this, arguments);\n\t            };\n\t        };\n\t        var renderCompleted = true;\n\t        var scheduled;\n\t        var stopped = false;\n\t        var projections = [];\n\t        var renderFunctions = [];\n\t        // matches the projections array\n\t        var doRender = function () {\n\t            scheduled = undefined;\n\t            if (!renderCompleted) {\n\t                return;    // The last render threw an error, it should be logged in the browser console.\n\t            }\n\t            renderCompleted = false;\n\t            for (var i = 0; i < projections.length; i++) {\n\t                var updatedVnode = renderFunctions[i]();\n\t                projections[i].update(updatedVnode);\n\t            }\n\t            renderCompleted = true;\n\t        };\n\t        projector = {\n\t            renderNow: doRender,\n\t            scheduleRender: function () {\n\t                if (!scheduled && !stopped) {\n\t                    scheduled = requestAnimationFrame(doRender);\n\t                }\n\t            },\n\t            stop: function () {\n\t                if (scheduled) {\n\t                    cancelAnimationFrame(scheduled);\n\t                    scheduled = undefined;\n\t                }\n\t                stopped = true;\n\t            },\n\t            resume: function () {\n\t                stopped = false;\n\t                renderCompleted = true;\n\t                projector.scheduleRender();\n\t            },\n\t            append: function (parentNode, renderMaquetteFunction) {\n\t                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            insertBefore: function (beforeNode, renderMaquetteFunction) {\n\t                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            merge: function (domNode, renderMaquetteFunction) {\n\t                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            replace: function (domNode, renderMaquetteFunction) {\n\t                var vnode = renderMaquetteFunction();\n\t                createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n\t                domNode.parentNode.removeChild(domNode);\n\t                projections.push(createProjection(vnode, projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            detach: function (renderMaquetteFunction) {\n\t                for (var i = 0; i < renderFunctions.length; i++) {\n\t                    if (renderFunctions[i] === renderMaquetteFunction) {\n\t                        renderFunctions.splice(i, 1);\n\t                        return projections.splice(i, 1)[0];\n\t                    }\n\t                }\n\t                throw new Error('renderMaquetteFunction was not found');\n\t            }\n\t        };\n\t        return projector;\n\t    };\n\t}));\n\t//# sourceMappingURL=maquette.js.map\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar compose_1 = __webpack_require__(7);\n\tvar Promise_1 = __webpack_require__(32);\n\tvar Map_1 = __webpack_require__(29);\n\tvar FactoryRegistry = (function () {\n\t    function FactoryRegistry() {\n\t        this.registry = new Map_1.default();\n\t    }\n\t    FactoryRegistry.prototype.has = function (factoryLabel) {\n\t        return this.registry.has(factoryLabel);\n\t    };\n\t    FactoryRegistry.prototype.define = function (factoryLabel, registryItem) {\n\t        if (this.registry.has(factoryLabel)) {\n\t            throw new Error(\"factory has already been registered for '\" + factoryLabel + \"'\");\n\t        }\n\t        this.registry.set(factoryLabel, registryItem);\n\t    };\n\t    FactoryRegistry.prototype.get = function (factoryLabel) {\n\t        var _this = this;\n\t        if (!this.has(factoryLabel)) {\n\t            return null;\n\t        }\n\t        var item = this.registry.get(factoryLabel);\n\t        if (compose_1.isComposeFactory(item) || item instanceof Promise_1.default) {\n\t            return item;\n\t        }\n\t        var promise = item();\n\t        this.registry.set(factoryLabel, promise);\n\t        return promise.then(function (factory) {\n\t            _this.registry.set(factoryLabel, factory);\n\t            return factory;\n\t        }, function (error) {\n\t            throw error;\n\t        });\n\t    };\n\t    return FactoryRegistry;\n\t}());\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = FactoryRegistry;\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar object_1 = __webpack_require__(30);\n\tvar lang_1 = __webpack_require__(15);\n\t/**\n\t * Determine if the value is an Object\n\t */\n\tfunction isObject(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\t/**\n\t * Shallow comparison of all keys on the objects\n\t */\n\tfunction shallowCompare(from, to) {\n\t    return Object.keys(from).every(function (key) { return from[key] === to[key]; });\n\t}\n\t/**\n\t * Mixin that overrides the `diffProperties` method providing a shallow comparison of attributes.\n\t *\n\t * For Objects, values for all `keys` are compared against the equivalent `key` on the `previousProperties`\n\t * attribute using `===`. If the `key` does not exists on the `previousProperties` attribute it is considered unequal.\n\t *\n\t * For Arrays, each `item` is compared with the `item` in the equivalent `index` of the `previousProperties` attribute.\n\t * If the `item` is an `object` then the object comparison described above is applied otherwise a simple `===` is used.\n\t */\n\tvar shallowPropertyComparisonMixin = {\n\t    mixin: {\n\t        diffProperties: function (previousProperties, newProperties) {\n\t            var changedPropertyKeys = [];\n\t            object_1.entries(newProperties).forEach(function (_a) {\n\t                var key = _a[0], value = _a[1];\n\t                var isEqual = true;\n\t                if (previousProperties.hasOwnProperty(key)) {\n\t                    var previousValue_1 = previousProperties[key];\n\t                    if (Array.isArray(value) && Array.isArray(previousValue_1)) {\n\t                        if (value.length !== previousValue_1.length) {\n\t                            isEqual = false;\n\t                        }\n\t                        else {\n\t                            isEqual = value.every(function (item, index) {\n\t                                if (isObject(item)) {\n\t                                    return shallowCompare(item, previousValue_1[index]);\n\t                                }\n\t                                else {\n\t                                    return item === previousValue_1[index];\n\t                                }\n\t                            });\n\t                        }\n\t                    }\n\t                    else if (isObject(value) && isObject(previousValue_1)) {\n\t                        isEqual = shallowCompare(value, previousValue_1);\n\t                    }\n\t                    else {\n\t                        isEqual = value === previousValue_1;\n\t                    }\n\t                }\n\t                else {\n\t                    isEqual = false;\n\t                }\n\t                if (!isEqual) {\n\t                    changedPropertyKeys.push(key);\n\t                }\n\t            });\n\t            return changedPropertyKeys;\n\t        },\n\t        assignProperties: function (previousProperties, newProperties, changedPropertyKeys) {\n\t            return lang_1.deepAssign({}, newProperties);\n\t        }\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = shallowPropertyComparisonMixin;\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar global_1 = __webpack_require__(10);\n\tvar compose_1 = __webpack_require__(7);\n\tvar Promise_1 = __webpack_require__(32);\n\tvar WeakMap_1 = __webpack_require__(22);\n\tvar maquette_1 = __webpack_require__(63);\n\t/**\n\t * Represents the state of the projector\n\t */\n\tvar ProjectorState;\n\t(function (ProjectorState) {\n\t    ProjectorState[ProjectorState[\"Attached\"] = 1] = \"Attached\";\n\t    ProjectorState[ProjectorState[\"Detached\"] = 2] = \"Detached\";\n\t})(ProjectorState = exports.ProjectorState || (exports.ProjectorState = {}));\n\t/**\n\t * Attach type for the projector\n\t */\n\tvar AttachType;\n\t(function (AttachType) {\n\t    AttachType[AttachType[\"Append\"] = 1] = \"Append\";\n\t    AttachType[AttachType[\"Merge\"] = 2] = \"Merge\";\n\t    AttachType[AttachType[\"Replace\"] = 3] = \"Replace\";\n\t})(AttachType = exports.AttachType || (exports.AttachType = {}));\n\t/**\n\t * Private state map keyed by instance.\n\t */\n\tvar projectorDataMap = new WeakMap_1.default();\n\t/**\n\t * Schedules a render.\n\t */\n\tfunction scheduleRender(event) {\n\t    var projector = event.target;\n\t    var projectorData = projectorDataMap.get(projector);\n\t    if (projectorData.state === ProjectorState.Attached) {\n\t        projector.emit({\n\t            type: 'render:scheduled',\n\t            target: projector\n\t        });\n\t        projectorData.projector.scheduleRender();\n\t    }\n\t}\n\tfunction attach(instance, _a) {\n\t    var type = _a.type;\n\t    var projectorData = projectorDataMap.get(instance);\n\t    var render = instance.__render__.bind(instance);\n\t    if (projectorData.state === ProjectorState.Attached) {\n\t        return projectorData.attachPromise || Promise_1.default.resolve({});\n\t    }\n\t    projectorData.state = ProjectorState.Attached;\n\t    projectorData.attachHandle = instance.own({\n\t        destroy: function () {\n\t            if (projectorData.state === ProjectorState.Attached) {\n\t                projectorData.projector.stop();\n\t                projectorData.projector.detach(render);\n\t                projectorData.state = ProjectorState.Detached;\n\t            }\n\t            projectorData.attachHandle = { destroy: function () { } };\n\t        }\n\t    });\n\t    projectorData.attachPromise = new Promise_1.default(function (resolve, reject) {\n\t        projectorData.afterCreate = function () {\n\t            instance.emit({\n\t                type: 'projector:attached',\n\t                target: instance\n\t            });\n\t            resolve(projectorData.attachHandle);\n\t        };\n\t    });\n\t    switch (type) {\n\t        case AttachType.Append:\n\t            projectorData.projector.append(projectorData.root, render);\n\t            break;\n\t        case AttachType.Merge:\n\t            projectorData.projector.merge(projectorData.root, render);\n\t            break;\n\t        case AttachType.Replace:\n\t            projectorData.projector.replace(projectorData.root, render);\n\t            break;\n\t    }\n\t    return projectorData.attachPromise;\n\t}\n\tvar createProjectorMixin = compose_1.default({\n\t    append: function () {\n\t        var options = {\n\t            type: AttachType.Append\n\t        };\n\t        return attach(this, options);\n\t    },\n\t    merge: function () {\n\t        var options = {\n\t            type: AttachType.Merge\n\t        };\n\t        return attach(this, options);\n\t    },\n\t    replace: function () {\n\t        var options = {\n\t            type: AttachType.Replace\n\t        };\n\t        return attach(this, options);\n\t    },\n\t    set root(root) {\n\t        var projectorData = projectorDataMap.get(this);\n\t        if (projectorData.state === ProjectorState.Attached) {\n\t            throw new Error('Projector already attached, cannot change root element');\n\t        }\n\t        projectorData.root = root;\n\t    },\n\t    get root() {\n\t        var projectorData = projectorDataMap.get(this);\n\t        return projectorData && projectorData.root;\n\t    },\n\t    get projector() {\n\t        return projectorDataMap.get(this).projector;\n\t    },\n\t    get projectorState() {\n\t        var projectorData = projectorDataMap.get(this);\n\t        return projectorData && projectorData.state;\n\t    }\n\t}).mixin({\n\t    mixin: {\n\t        nodeAttributes: [\n\t            function () {\n\t                var afterCreate = projectorDataMap.get(this).afterCreate;\n\t                return { afterCreate: afterCreate };\n\t            }\n\t        ]\n\t    },\n\t    aspectAdvice: {\n\t        after: {\n\t            __render__: function (result) {\n\t                if (typeof result === 'string' || result === null) {\n\t                    throw new Error('Must provide a VNode at the root of a projector');\n\t                }\n\t                return result;\n\t            }\n\t        }\n\t    }\n\t}).mixin({\n\t    initialize: function (instance, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var _a = options.root, root = _a === void 0 ? document.body : _a, _b = options.cssTransitions, cssTransitions = _b === void 0 ? false : _b;\n\t        var maquetteProjectorOptions = {};\n\t        if (cssTransitions) {\n\t            if (global_1.default.cssTransitions) {\n\t                maquetteProjectorOptions.transitions = global_1.default.cssTransitions;\n\t            }\n\t            else {\n\t                throw new Error('Unable to create projector with css transitions enabled. Is the \\'css-transition.js\\' script loaded in the page?');\n\t            }\n\t        }\n\t        instance.own(instance.on('widget:children', instance.invalidate));\n\t        instance.own(instance.on('invalidated', scheduleRender));\n\t        var projector = maquette_1.createProjector(maquetteProjectorOptions);\n\t        projectorDataMap.set(instance, {\n\t            projector: projector,\n\t            root: root,\n\t            state: ProjectorState.Detached\n\t        });\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createProjectorMixin;\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar WeakMap_1 = __webpack_require__(22);\n\tvar array_1 = __webpack_require__(16);\n\tvar lang_1 = __webpack_require__(15);\n\tvar createEvented_1 = __webpack_require__(27);\n\t/**\n\t * Private map for external state.\n\t */\n\tvar internalStateMap = new WeakMap_1.default();\n\t/**\n\t * state changed event type\n\t */\n\tvar stateChangedEventType = 'state:changed';\n\tfunction replaceState(instance, state) {\n\t    var internalState = internalStateMap.get(instance);\n\t    internalState.state = state;\n\t    var eventObject = {\n\t        type: stateChangedEventType,\n\t        state: state,\n\t        target: instance\n\t    };\n\t    instance.emit(eventObject);\n\t}\n\tfunction onPropertiesChanged(instance, properties, changedPropertyKeys) {\n\t    var internalState = internalStateMap.get(instance);\n\t    if (internalState) {\n\t        if (array_1.includes(changedPropertyKeys, 'externalState') || array_1.includes(changedPropertyKeys, 'id')) {\n\t            internalState.handle.destroy();\n\t        }\n\t    }\n\t    instance.observe();\n\t}\n\t/**\n\t * ExternalState Factory\n\t */\n\tvar externalStateFactory = createEvented_1.default.mixin({\n\t    className: 'ExternalStateMixin',\n\t    mixin: {\n\t        get state() {\n\t            return internalStateMap.get(this).state;\n\t        },\n\t        observe: function () {\n\t            var _this = this;\n\t            var internalState = internalStateMap.get(this);\n\t            var _a = this.properties, id = _a.id, externalState = _a.externalState;\n\t            if (!id || !externalState) {\n\t                throw new Error('id and externalState are required to observe state');\n\t            }\n\t            if (internalState) {\n\t                if (internalState.id === id) {\n\t                    return;\n\t                }\n\t                throw new Error('Unable to observe state for a different id');\n\t            }\n\t            var subscription = externalState\n\t                .observe(id)\n\t                .subscribe(function (state) {\n\t                replaceState(_this, state);\n\t            }, function (err) {\n\t                throw err;\n\t            });\n\t            var handle = {\n\t                destroy: function () {\n\t                    subscription.unsubscribe();\n\t                    internalStateMap.delete(_this);\n\t                }\n\t            };\n\t            internalStateMap.set(this, { id: id, handle: handle, state: Object.create(null) });\n\t            this.own(handle);\n\t        },\n\t        setState: function (newState) {\n\t            var _this = this;\n\t            var _a = this.properties, externalState = _a.externalState, id = _a.id;\n\t            externalState.patch(lang_1.assign({ id: id }, newState))\n\t                .then(function () { return externalState.get(id); })\n\t                .then(function (state) {\n\t                replaceState(_this, state);\n\t            });\n\t        }\n\t    },\n\t    initialize: function (instance) {\n\t        instance.own(instance.on('properties:changed', function (evt) {\n\t            onPropertiesChanged(instance, evt.properties, evt.changedPropertyKeys);\n\t        }));\n\t        instance.observe();\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = externalStateFactory;\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar d_1 = __webpack_require__(62);\n\tvar routes_1 = __webpack_require__(5);\n\tvar createFocusableTextInput_1 = __webpack_require__(69);\n\tvar createCheckboxInput_1 = __webpack_require__(72);\n\tvar todoStoreActions_1 = __webpack_require__(73);\n\tvar createFormattedDate_1 = __webpack_require__(75);\n\tvar externalState_1 = __webpack_require__(67);\n\tvar createFocusableTextArea = createFocusableTextInput_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'textarea'\n\t    }\n\t});\n\tvar completedHandlers = new WeakMap();\n\tvar textUpdateHandlers = new WeakMap();\n\tvar closeHandlers = new WeakMap();\n\tvar createTodoDetails = createWidgetBase_1.default\n\t    .mixin(externalState_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        tagName: 'div',\n\t        classes: ['todo-details'],\n\t        getChildrenNodes: function () {\n\t            var todoDetails = this.state.todoDetails;\n\t            var _a = todoDetails || {}, _b = _a.label, label = _b === void 0 ? '' : _b, _c = _a.completed, completed = _c === void 0 ? false : _c, _d = _a.createdOn, createdOn = _d === void 0 ? new Date() : _d;\n\t            return [\n\t                d_1.v('div.backdrop', {}),\n\t                d_1.v('div.modal', {}, [\n\t                    d_1.v('div.close', {\n\t                        onclick: closeHandlers.get(this)\n\t                    }),\n\t                    d_1.v('header', {}, [\n\t                        d_1.v('div.title', {}, [\n\t                            'Details'\n\t                        ])\n\t                    ]),\n\t                    d_1.v('section', {}, [\n\t                        d_1.w(createFocusableTextArea, {\n\t                            focused: true,\n\t                            value: label,\n\t                            onInput: textUpdateHandlers.get(this)\n\t                        }),\n\t                        d_1.v('div', {}, [\n\t                            d_1.v('div.last-updated', [\n\t                                'Created on ',\n\t                                d_1.w(createFormattedDate_1.default, {\n\t                                    date: createdOn\n\t                                })\n\t                            ]),\n\t                            d_1.w(createCheckboxInput_1.default, {\n\t                                classes: ['toggle'],\n\t                                checked: completed,\n\t                                onChange: completedHandlers.get(this)\n\t                            })\n\t                        ])\n\t                    ])\n\t                ])\n\t            ];\n\t        }\n\t    }\n\t}).mixin({\n\t    initialize: function (instance) {\n\t        var _a = instance.state, filter = _a.activeFilter, view = _a.activeView;\n\t        var closeLink = routes_1.default.link(routes_1.mainRoute, {\n\t            filter: filter,\n\t            view: view\n\t        });\n\t        completedHandlers.set(instance, function () {\n\t            instance.state.todoDetails.completed = !instance.state.todoDetails.completed;\n\t            instance.invalidate();\n\t        });\n\t        textUpdateHandlers.set(instance, function (event) {\n\t            // this.value = event.target.value;\n\t            instance.state.todoDetails.label = event.target.value;\n\t        });\n\t        closeHandlers.set(instance, function () {\n\t            todoStoreActions_1.updateTodo(instance.state.todoDetails).then(function () {\n\t                document.location.href = closeLink;\n\t            });\n\t        });\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createTodoDetails;\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createFormFieldMixin_1 = __webpack_require__(70);\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar createFocusableTextInput = createWidgetBase_1.default\n\t    .mixin(createFormFieldMixin_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        tagName: 'input',\n\t        type: 'text',\n\t        onBlur: function (event) {\n\t            this.properties.onBlur && this.properties.onBlur(event);\n\t        },\n\t        onInput: function (event) {\n\t            this.properties.onInput && this.properties.onInput(event);\n\t        },\n\t        onKeyUp: function (event) {\n\t            this.properties.onKeyUp && this.properties.onKeyUp(event);\n\t        },\n\t        afterCreate: function (element) {\n\t            var focused = this.properties.focused;\n\t            if (focused) {\n\t                setTimeout(function () { return element.focus(); }, 0);\n\t            }\n\t            else if (!focused && document.activeElement === element) {\n\t                element.blur();\n\t            }\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                var _a = this, onkeyup = _a.onKeyUp, onblur = _a.onBlur, afterCreate = _a.afterCreate, oninput = _a.onInput;\n\t                var _b = this.properties, placeholder = _b.placeholder, _c = _b.value, value = _c === void 0 ? '' : _c;\n\t                return { placeholder: placeholder, innerHTML: value, value: value, afterCreate: afterCreate, onkeyup: onkeyup, onblur: onblur, oninput: oninput };\n\t            }\n\t        ]\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createFocusableTextInput;\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createStateful_1 = __webpack_require__(61);\n\tvar createCancelableEvent_1 = __webpack_require__(71);\n\tvar lang_1 = __webpack_require__(15);\n\tfunction valueReplacer(key, value) {\n\t    if (value instanceof RegExp) {\n\t        return (\"__RegExp(\" + value.toString() + \")\");\n\t    }\n\t    return value;\n\t}\n\tfunction valueReviver(key, value) {\n\t    if (value.toString().indexOf('__RegExp(') === 0) {\n\t        var _a = value.match(/__RegExp\\(([^\\)]*)\\)/), regExpStr = _a[1];\n\t        var _b = regExpStr.match(/^\\/(.*?)\\/([gimy]*)$/), regExp = _b[1], flags = _b[2];\n\t        return new RegExp(regExp, flags);\n\t    }\n\t    return value;\n\t}\n\t/**\n\t * Internal function to convert a state value to a string\n\t * @param value The value to be converted\n\t */\n\tfunction valueToString(value) {\n\t    return value\n\t        ? Array.isArray(value) || typeof value === 'object'\n\t            ? JSON.stringify(value, valueReplacer) : String(value)\n\t        : value === 0\n\t            ? '0' : value === false\n\t            ? 'false' : '';\n\t}\n\texports.valueToString = valueToString;\n\t/**\n\t * Internal function to convert a string to the likely more complex value stored in\n\t * state\n\t * @param str The string to convert to a state value\n\t */\n\tfunction stringToValue(str) {\n\t    try {\n\t        var value = JSON.parse(str, valueReviver);\n\t        return value;\n\t    }\n\t    catch (e) {\n\t        if (/^(\\-|\\+)?([0-9]+(\\.[0-9]+)?|Infinity)$/.test(str)) {\n\t            return Number(str);\n\t        }\n\t        if (str) {\n\t            return str;\n\t        }\n\t        return undefined;\n\t    }\n\t}\n\texports.stringToValue = stringToValue;\n\tvar createFormMixin = createStateful_1.default\n\t    .mixin({\n\t    mixin: {\n\t        get value() {\n\t            return valueToString(this.state.value);\n\t        },\n\t        set value(value) {\n\t            if (value !== this.state.value) {\n\t                var event_1 = lang_1.assign(createCancelableEvent_1.default({\n\t                    type: 'valuechange',\n\t                    target: this\n\t                }), {\n\t                    oldValue: valueToString(this.state.value),\n\t                    value: value\n\t                });\n\t                this.emit(event_1);\n\t                if (!event_1.defaultPrevented) {\n\t                    this.setState({ value: stringToValue(event_1.value) });\n\t                }\n\t            }\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                var _a = this, type = _a.type, value = _a.value, state = _a.state;\n\t                var disabled = state.disabled, name = state.name;\n\t                return { type: type, value: value, name: name, disabled: Boolean(disabled) };\n\t            }\n\t        ]\n\t    },\n\t    initialize: function (instance, _a) {\n\t        var _b = _a === void 0 ? {} : _a, value = _b.value, type = _b.type;\n\t        if (value) {\n\t            instance.setState({ value: value });\n\t        }\n\t        if (type) {\n\t            instance.type = type;\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createFormMixin;\n\n/***/ },\n/* 71 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * A simple factory that creates an event object which can be cancelled\n\t *\n\t * @param options The options for the event\n\t */\n\tfunction createCancelableEvent(options) {\n\t    var type = options.type, target = options.target;\n\t    var event = Object.defineProperties({}, {\n\t        type: { value: type, enumerable: true },\n\t        target: { value: target, enumerable: true },\n\t        cancelable: { value: true, enumerable: true },\n\t        defaultPrevented: { value: false, enumerable: true, configurable: true },\n\t        preventDefault: { value: function () {\n\t                Object.defineProperty(event, 'defaultPrevented', { value: true, enumerable: true });\n\t            }, enumerable: true }\n\t    });\n\t    return event;\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createCancelableEvent;\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar createFormFieldMixin_1 = __webpack_require__(70);\n\tvar createCheckboxInput = createWidgetBase_1.default\n\t    .mixin(createFormFieldMixin_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        tagName: 'input',\n\t        type: 'checkbox',\n\t        onChange: function (event) {\n\t            this.properties.onChange && this.properties.onChange(event);\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                var onchange = this.onChange;\n\t                var checked = this.state.checked;\n\t                return checked !== undefined ? { checked: checked, onchange: onchange } : { onchange: onchange };\n\t            }\n\t        ]\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createCheckboxInput;\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar todoStore_1 = __webpack_require__(57);\n\tvar createFilter_1 = __webpack_require__(74);\n\tvar lang_1 = __webpack_require__(15);\n\tvar id = 0;\n\texports.addTodo = function (_a) {\n\t    var label = _a.label, completed = _a.completed;\n\t    return todoStore_1.default.add({ id: \"\" + id++, label: label, completed: completed, createdOn: new Date(), editing: false });\n\t};\n\texports.deleteTodo = function (_a) {\n\t    var id = _a.id;\n\t    return todoStore_1.default.delete(id);\n\t};\n\texports.deleteCompleted = function () {\n\t    return todoStore_1.default.fetch(createFilter_1.default().equalTo('completed', true))\n\t        .then(function (items) { return todoStore_1.default.identify(items); })\n\t        .then(function (ids) { return todoStore_1.default.delete(ids); });\n\t};\n\texports.toggleAll = function (_a) {\n\t    var completed = _a.checked;\n\t    return todoStore_1.default.fetch()\n\t        .then(function (items) {\n\t        return items.map(function (item) {\n\t            return lang_1.assign({}, item, { completed: completed });\n\t        });\n\t    })\n\t        .then(function (items) { return todoStore_1.default.patch(items); });\n\t};\n\texports.updateTodo = function (item) {\n\t    return todoStore_1.default.patch(item);\n\t};\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createJsonPointer_1 = __webpack_require__(50);\n\tvar utils_1 = __webpack_require__(48);\n\tfunction isBooleanOp(op) {\n\t    return op === 0 /* And */ || op === 1 /* Or */;\n\t}\n\tfunction isFilter(filterOrFunction) {\n\t    return typeof filterOrFunction !== 'function' && filterOrFunction.apply;\n\t}\n\tfunction createFilterOrReturnOp(descriptorOrOp) {\n\t    if (isBooleanOp(descriptorOrOp)) {\n\t        return descriptorOrOp;\n\t    }\n\t    else {\n\t        return createComparator(descriptorOrOp.filterType, descriptorOrOp.value, descriptorOrOp.path);\n\t    }\n\t}\n\tfunction createFilter(filterDescriptors, serializer) {\n\t    var filters = [];\n\t    if (filterDescriptors) {\n\t        if (Array.isArray(filterDescriptors)) {\n\t            filters = filterDescriptors.map(function (descriptorChainMember) {\n\t                if (Array.isArray(descriptorChainMember)) {\n\t                    return createFilter(descriptorChainMember);\n\t                }\n\t                else {\n\t                    return createFilterOrReturnOp(descriptorChainMember);\n\t                }\n\t            });\n\t        }\n\t        else {\n\t            filters.push(createComparator(filterDescriptors.filterType, filterDescriptors.value, filterDescriptors.path));\n\t        }\n\t    }\n\t    return createFilterHelper(filters, serializer || serializeFilter);\n\t}\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createFilter;\n\tfunction createFilterHelper(filters, serializer) {\n\t    // Small helpers to abstract common operations for building comparator filters\n\t    // The main helper delegates to the factory, adding and AND operation before the next filter,\n\t    // because by default each filter in a chain will be ANDed with the previous.\n\t    function comparatorFilterHelper(filterType, value, path) {\n\t        path = path || createJsonPointer_1.default();\n\t        var needsOperator = filters.length > 0 &&\n\t            ((filters[filters.length - 1] !== 0 /* And */ && filters[filters.length - 1] !== 1) /* Or */);\n\t        var newFilters = needsOperator ? filters.concat([0 /* And */, createComparator(filterType, value, path)]) : filters.concat([createComparator(filterType, value, path)]);\n\t        return createFilterHelper(newFilters, serializer);\n\t    }\n\t    var filter = {\n\t        test: function (item) {\n\t            return applyFilterChain(item, filters);\n\t        },\n\t        filterType: 12 /* Compound */,\n\t        apply: function (data) {\n\t            return data.filter(this.test);\n\t        },\n\t        filterChain: filters,\n\t        toString: function (filterSerializer) {\n\t            return (filterSerializer || serializer)(this);\n\t        },\n\t        and: function (newFilter) {\n\t            var newFilters = [];\n\t            if (newFilter) {\n\t                newFilters.push(this, 0 /* And */, newFilter);\n\t            }\n\t            else if (filters.length) {\n\t                newFilters.push.apply(newFilters, filters.concat([0 /* And */]));\n\t            }\n\t            return createFilterHelper(newFilters, serializer);\n\t        },\n\t        or: function (newFilter) {\n\t            var newFilters = [];\n\t            if (newFilter) {\n\t                newFilters.push(this, 1 /* Or */, newFilter);\n\t            }\n\t            else if (filters.length) {\n\t                newFilters.push.apply(newFilters, filters.concat([1 /* Or */]));\n\t            }\n\t            return createFilterHelper(newFilters, serializer);\n\t        },\n\t        lessThan: function (path, value) {\n\t            return comparatorFilterHelper(0 /* LessThan */, value, path);\n\t        },\n\t        lessThanOrEqualTo: function (path, value) {\n\t            return comparatorFilterHelper(8 /* LessThanOrEqualTo */, value, path);\n\t        },\n\t        greaterThan: function (path, value) {\n\t            return comparatorFilterHelper(1 /* GreaterThan */, value, path);\n\t        },\n\t        greaterThanOrEqualTo: function (path, value) {\n\t            return comparatorFilterHelper(9 /* GreaterThanOrEqualTo */, value, path);\n\t        },\n\t        matches: function (path, value) {\n\t            return comparatorFilterHelper(10 /* Matches */, value, path);\n\t        },\n\t        'in': function (path, value) {\n\t            return comparatorFilterHelper(4 /* In */, value, path);\n\t        },\n\t        contains: function (path, value) {\n\t            return comparatorFilterHelper(5 /* Contains */, value, path);\n\t        },\n\t        equalTo: function (path, value) {\n\t            return comparatorFilterHelper(2 /* EqualTo */, value, path);\n\t        },\n\t        deepEqualTo: function (path, value) {\n\t            return comparatorFilterHelper(3 /* DeepEqualTo */, value, path);\n\t        },\n\t        notEqualTo: function (path, value) {\n\t            return comparatorFilterHelper(6 /* NotEqualTo */, value, path);\n\t        },\n\t        notDeepEqualTo: function (path, value) {\n\t            return comparatorFilterHelper(7 /* NotDeepEqualTo */, value, path);\n\t        },\n\t        custom: function (test) {\n\t            return comparatorFilterHelper(11 /* Custom */, test);\n\t        },\n\t        queryType: 0 /* Filter */,\n\t        incremental: true\n\t    };\n\t    return filter;\n\t}\n\tfunction applyFilterChain(item, filterChain) {\n\t    var ordFilterSections = [];\n\t    var startOfSlice = 0;\n\t    // Ands have higher precedence, so split into chains of\n\t    // ands between ors.\n\t    filterChain.forEach(function (chainMember, i) {\n\t        if (chainMember === 1 /* Or */) {\n\t            ordFilterSections.push(filterChain.slice(startOfSlice, i));\n\t            startOfSlice = i + 1;\n\t        }\n\t    });\n\t    if (startOfSlice < filterChain.length) {\n\t        ordFilterSections.push(filterChain.slice(startOfSlice, filterChain.length));\n\t    }\n\t    // These sections are or'd together so only\n\t    // one has to pass\n\t    return ordFilterSections.some(function (filterChain) {\n\t        // The individual filters are and'd together, so if any\n\t        // fails the whole section fails\n\t        return filterChain.every(function (filterOrAnd) {\n\t            if (isFilter(filterOrAnd)) {\n\t                return filterOrAnd.test(item);\n\t            }\n\t            else {\n\t                return true;\n\t            }\n\t        });\n\t    });\n\t}\n\tfunction createComparator(operator, value, path) {\n\t    path = typeof path === 'string' ? createJsonPointer_1.default(path) : path;\n\t    var test;\n\t    var filterType = operator;\n\t    var operatorString;\n\t    switch (operator) {\n\t        case 0 /* LessThan */:\n\t            test = function (property) {\n\t                return property < value;\n\t            };\n\t            operatorString = 'lt';\n\t            break;\n\t        case 8 /* LessThanOrEqualTo */:\n\t            test = function (property) {\n\t                return property <= value;\n\t            };\n\t            operatorString = 'lte';\n\t            break;\n\t        case 1 /* GreaterThan */:\n\t            test = function (property) {\n\t                return property > value;\n\t            };\n\t            operatorString = 'gt';\n\t            break;\n\t        case 9 /* GreaterThanOrEqualTo */:\n\t            test = function (property) {\n\t                return property >= value;\n\t            };\n\t            operatorString = 'gte';\n\t            break;\n\t        case 2 /* EqualTo */:\n\t            test = function (property) {\n\t                return property === value;\n\t            };\n\t            operatorString = 'eq';\n\t            break;\n\t        case 6 /* NotEqualTo */:\n\t            test = function (property) {\n\t                return property !== value;\n\t            };\n\t            operatorString = 'ne';\n\t            break;\n\t        case 3 /* DeepEqualTo */:\n\t            test = function (property) {\n\t                return utils_1.isEqual(property, value);\n\t            };\n\t            operatorString = 'eq';\n\t            break;\n\t        case 7 /* NotDeepEqualTo */:\n\t            test = function (property) {\n\t                return !utils_1.isEqual(property, value);\n\t            };\n\t            operatorString = 'ne';\n\t            break;\n\t        case 5 /* Contains */:\n\t            test = function (propertyOrItem) {\n\t                if (Array.isArray(propertyOrItem)) {\n\t                    return propertyOrItem.indexOf(value) > -1;\n\t                }\n\t                else {\n\t                    return propertyOrItem && Boolean(propertyOrItem[value]);\n\t                }\n\t            };\n\t            operatorString = 'contains';\n\t            break;\n\t        case 4 /* In */:\n\t            test = function (propertyOrItem) {\n\t                return Array.isArray(value) && value.indexOf(propertyOrItem) > -1;\n\t            };\n\t            operatorString = 'in';\n\t            break;\n\t        case 10 /* Matches */:\n\t            test = function (property) {\n\t                return value.test(property);\n\t            };\n\t            break;\n\t        case 11 /* Custom */:\n\t            test = value;\n\t            break;\n\t    }\n\t    return {\n\t        test: function (item) {\n\t            var propertyValue = createJsonPointer_1.navigate(path, item);\n\t            return test(propertyValue);\n\t        },\n\t        apply: function (data) {\n\t            return data.filter(this.test);\n\t        },\n\t        toString: function () {\n\t            if (!operatorString) {\n\t                throw Error('Cannot parse this filter type to an RQL query string');\n\t            }\n\t            return operatorString + \"(\" + path.toString() + \", \" + JSON.stringify(value) + \")\";\n\t        },\n\t        path: path,\n\t        value: value,\n\t        filterType: filterType,\n\t        queryType: 0 /* Filter */\n\t    };\n\t}\n\t//// Default serialization function\n\tfunction serializeFilter(filter) {\n\t    var operator = '&';\n\t    if (filter.filterChain && filter.filterChain.length > 0) {\n\t        return filter.filterChain.reduce(function (prev, next) {\n\t            if (isFilter(next)) {\n\t                var start = next.filterChain ? '(' : '';\n\t                var end = next.filterChain ? ')' : '';\n\t                return prev + (prev ? operator : '') + (prev ? start : '') + next.toString() + (prev ? end : '');\n\t            }\n\t            else if (next === 0 /* And */) {\n\t                operator = '&';\n\t                return prev;\n\t            }\n\t            else {\n\t                operator = '|';\n\t                return prev;\n\t            }\n\t        }, '');\n\t    }\n\t    else {\n\t        return '';\n\t    }\n\t}\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar string_1 = __webpack_require__(19);\n\tvar createFormattedDate = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'span',\n\t        nodeAttributes: [\n\t            function () {\n\t                var _a = this.state.date, date = _a === void 0 ? new Date() : _a;\n\t                var hours = date.getHours();\n\t                var minutes = String(date.getMinutes());\n\t                var suffix = 'am';\n\t                if (hours >= 12) {\n\t                    suffix = 'pm';\n\t                    hours = hours % 12;\n\t                    if (!hours) {\n\t                        hours = 12;\n\t                    }\n\t                }\n\t                return {\n\t                    innerHTML: date.getMonth() + 1 + \"/\" + date.getDate() + \"/\" + date.getFullYear() + \" at \" + hours + \":\" + string_1.padStart(minutes, 2, '0') + suffix\n\t                };\n\t            }\n\t        ]\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createFormattedDate;\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __assign = (this && this.__assign) || Object.assign || function(t) {\n\t    for (var s, i = 1, n = arguments.length; i < n; i++) {\n\t        s = arguments[i];\n\t        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n\t            t[p] = s[p];\n\t    }\n\t    return t;\n\t};\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar userActions_1 = __webpack_require__(77);\n\tvar createTodoFooter_1 = __webpack_require__(78);\n\tvar d_1 = __webpack_require__(62);\n\tvar createTitle_1 = __webpack_require__(82);\n\tvar createFocusableTextInput_1 = __webpack_require__(69);\n\tvar createMainSection_1 = __webpack_require__(83);\n\tvar createHome = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        getChildrenNodes: function () {\n\t            var properties = this.properties;\n\t            var _a = properties, todo = _a.todo, _b = _a.todos, todos = _b === void 0 ? [] : _b;\n\t            var newTodoOptions = {\n\t                id: 'new-todo',\n\t                classes: ['new-todo'],\n\t                focused: true,\n\t                value: todo ? todo : '',\n\t                placeholder: 'What needs to be done?',\n\t                onKeyUp: userActions_1.todoInput.bind(this)\n\t            };\n\t            return [\n\t                d_1.v('header', {}, [\n\t                    d_1.w(createTitle_1.default, { id: 'title', label: 'todos' }),\n\t                    d_1.w(createFocusableTextInput_1.default, newTodoOptions)\n\t                ]),\n\t                d_1.w(createMainSection_1.default, __assign({}, properties, { id: 'main-section' })),\n\t                todos.length ? d_1.w(createTodoFooter_1.default, __assign({}, properties, { id: 'todo-footer' })) : null\n\t            ];\n\t        },\n\t        tagName: 'div'\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createHome;\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar lang_1 = __webpack_require__(15);\n\tvar widgetStore_1 = __webpack_require__(42);\n\tvar todoStoreActions_1 = __webpack_require__(73);\n\tvar routes_1 = __webpack_require__(5);\n\texports.todoInput = function (_a) {\n\t    var which = _a.which, label = _a.target.value;\n\t    if (which === 13 && label) {\n\t        todoStoreActions_1.addTodo({ label: label, completed: false });\n\t        widgetStore_1.default.patch({ id: 'todo-app', todo: '' });\n\t        this.invalidate();\n\t    }\n\t};\n\tfunction toggleEditing(todos, todoId, editing) {\n\t    return todos\n\t        .filter(function (todo) { return todo.id === todoId; })\n\t        .map(function (todo) {\n\t        todo.editing = editing;\n\t        return todo;\n\t    });\n\t}\n\texports.todoEdit = function (event) {\n\t    var id = this.state.id;\n\t    if (event.type === 'keypress' && event.which !== 13 && event.which !== 32) {\n\t        return;\n\t    }\n\t    widgetStore_1.default.get('todo-app').then(function (todoListState) {\n\t        var link = routes_1.default.link(routes_1.todoViewRoute, {\n\t            filter: todoListState.activeFilter,\n\t            view: todoListState.activeView,\n\t            todoId: id\n\t        });\n\t        document.location.href = link;\n\t    });\n\t};\n\texports.todoEditInput = function (event) {\n\t    var state = this.state;\n\t    if (event.which === 13) {\n\t        exports.todoSave.call(this, event);\n\t    }\n\t    else if (event.which === 27) {\n\t        widgetStore_1.default.get('todo-app').then(function (todoListState) {\n\t            var todos = todoListState.todos;\n\t            todoListState.todos = toggleEditing(todos, state.id, false);\n\t            widgetStore_1.default.patch({ id: 'todo-app', todoListState: todoListState });\n\t        });\n\t    }\n\t};\n\texports.todoSave = function (event) {\n\t    var state = this.state;\n\t    if (!event.target.value) {\n\t        todoStoreActions_1.deleteTodo(state);\n\t    }\n\t    else {\n\t        todoStoreActions_1.updateTodo(lang_1.assign(state, { label: event.target.value, editing: false }));\n\t    }\n\t};\n\texports.todoRemove = function () {\n\t    var state = this.state;\n\t    todoStoreActions_1.deleteTodo({ id: state.id });\n\t};\n\texports.todoToggleComplete = function () {\n\t    var properties = this.properties;\n\t    todoStoreActions_1.updateTodo({ id: properties.todoId, completed: !properties.completed, editing: false });\n\t};\n\texports.todoToggleAll = function (event) {\n\t    todoStoreActions_1.toggleAll({ checked: event.target.checked });\n\t};\n\texports.clearCompleted = function () {\n\t    todoStoreActions_1.deleteCompleted();\n\t};\n\texports.updateSearch = function (searchQuery) {\n\t    widgetStore_1.default.get('todo-app').then(function (todoListState) {\n\t        todoListState.search = searchQuery;\n\t        widgetStore_1.default.patch({ id: 'todo-app', todoListState: todoListState });\n\t    });\n\t};\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar d_1 = __webpack_require__(62);\n\tvar createButton_1 = __webpack_require__(79);\n\tvar userActions_1 = __webpack_require__(77);\n\tvar createTodoFilter_1 = __webpack_require__(80);\n\tvar createViewChooser_1 = __webpack_require__(81);\n\tvar createTodoFooter = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'footer',\n\t        classes: ['footer'],\n\t        getChildrenNodes: function () {\n\t            var _a = this.properties, activeCount = _a.activeCount, activeFilter = _a.activeFilter, completedCount = _a.completedCount, activeView = _a.activeView;\n\t            var countLabel = activeCount === 1 ? 'item' : 'items';\n\t            return [\n\t                d_1.v('span', { 'class': 'todo-count' }, [\n\t                    d_1.v('strong', [activeCount + ' ']),\n\t                    d_1.v('span', [countLabel + ' left'])\n\t                ]),\n\t                d_1.w(createTodoFilter_1.default, {\n\t                    classes: ['filters'],\n\t                    activeFilter: activeFilter,\n\t                    activeView: activeView\n\t                }),\n\t                d_1.w(createViewChooser_1.default, {\n\t                    activeView: activeView,\n\t                    activeFilter: activeFilter\n\t                }),\n\t                completedCount ? d_1.w(createButton_1.default, {\n\t                    label: 'Clear completed',\n\t                    classes: ['clear-completed'],\n\t                    onClick: userActions_1.clearCompleted.bind(this)\n\t                }) : null\n\t            ];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createTodoFooter;\n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar createFormFieldMixin_1 = __webpack_require__(70);\n\tvar createButton = createWidgetBase_1.default\n\t    .mixin(createFormFieldMixin_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        onClick: function (event) {\n\t            this.properties.onClick && this.properties.onClick(event);\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                return { innerHTML: this.properties.label, onclick: this.onClick };\n\t            }\n\t        ],\n\t        tagName: 'button',\n\t        type: 'button'\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createButton;\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar d_1 = __webpack_require__(62);\n\tvar routes_1 = __webpack_require__(5);\n\tfunction createFilterItems(activeFilter, activeView) {\n\t    var filters = ['all', 'active', 'completed'];\n\t    return filters.map(function (filterItem) {\n\t        var label = filterItem[0].toUpperCase() + filterItem.substring(1);\n\t        return d_1.v('li', {}, [\n\t            d_1.v('a', {\n\t                innerHTML: label,\n\t                href: routes_1.default.link(routes_1.mainRoute, {\n\t                    filter: filterItem,\n\t                    view: activeView\n\t                }),\n\t                classes: {\n\t                    selected: activeFilter === filterItem\n\t                }\n\t            })\n\t        ]);\n\t    });\n\t}\n\tvar createTodoFilter = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'ul',\n\t        classes: ['filters'],\n\t        getChildrenNodes: function () {\n\t            var activeFilter = this.properties.activeFilter || '';\n\t            var activeView = this.properties.activeView || '';\n\t            return createFilterItems(activeFilter, activeView);\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createTodoFilter;\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar d_1 = __webpack_require__(62);\n\tvar routes_1 = __webpack_require__(5);\n\tvar createViewChooser = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'ul',\n\t        classes: ['view-chooser'],\n\t        getChildrenNodes: function () {\n\t            var _a = this.state, _b = _a.activeView, activeView = _b === void 0 ? 'list' : _b, _c = _a.activeFilter, activeFilter = _c === void 0 ? 'all' : _c;\n\t            return [\n\t                d_1.v('li.view-mode', {}, [\n\t                    d_1.v('a', {\n\t                        href: routes_1.default.link(routes_1.mainRoute, {\n\t                            filter: activeFilter,\n\t                            view: 'list'\n\t                        }),\n\t                        classes: {\n\t                            list: true,\n\t                            active: activeView === 'list'\n\t                        }\n\t                    })\n\t                ]),\n\t                d_1.v('li.view-mode', {}, [\n\t                    d_1.v('a', {\n\t                        href: routes_1.default.link(routes_1.mainRoute, {\n\t                            filter: activeFilter,\n\t                            view: 'cards'\n\t                        }),\n\t                        classes: {\n\t                            cards: true,\n\t                            active: activeView === 'cards'\n\t                        }\n\t                    })\n\t                ])\n\t            ];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createViewChooser;\n\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar createTitle = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'h1',\n\t        nodeAttributes: [\n\t            function () {\n\t                return { innerHTML: this.properties.label };\n\t            }\n\t        ]\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createTitle;\n\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __assign = (this && this.__assign) || Object.assign || function(t) {\n\t    for (var s, i = 1, n = arguments.length; i < n; i++) {\n\t        s = arguments[i];\n\t        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n\t            t[p] = s[p];\n\t    }\n\t    return t;\n\t};\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar d_1 = __webpack_require__(62);\n\tvar userActions_1 = __webpack_require__(77);\n\tvar createCheckboxInput_1 = __webpack_require__(72);\n\tvar createTodoItemList_1 = __webpack_require__(84);\n\tvar createSearchInput_1 = __webpack_require__(87);\n\tfunction searchHandler(event) {\n\t    userActions_1.updateSearch(event.target.value);\n\t}\n\tvar createMainSection = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'section',\n\t        classes: ['main'],\n\t        getChildrenNodes: function () {\n\t            var properties = this.properties;\n\t            var _a = properties.todos, todos = _a === void 0 ? [] : _a;\n\t            var checkBoxOptions = {\n\t                id: 'todo-toggle',\n\t                checked: properties.allCompleted,\n\t                classes: ['toggle-all'],\n\t                onChange: userActions_1.todoToggleAll\n\t            };\n\t            var activeView = properties.activeView;\n\t            return [\n\t                d_1.w(createCheckboxInput_1.default, checkBoxOptions),\n\t                todos.length ? d_1.v('div.searchbar', {}, [\n\t                    d_1.v('span.icon', {}), d_1.w(createSearchInput_1.default, {\n\t                        placeholder: 'Quick Filter',\n\t                        value: properties.search,\n\t                        onKeyUp: searchHandler\n\t                    })\n\t                ]) : null,\n\t                d_1.w(createTodoItemList_1.default, __assign({}, properties, { id: \"todo-item-\" + (activeView === 'cards' ? 'cards' : 'list') }))\n\t            ];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createMainSection;\n\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __assign = (this && this.__assign) || Object.assign || function(t) {\n\t    for (var s, i = 1, n = arguments.length; i < n; i++) {\n\t        s = arguments[i];\n\t        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n\t            t[p] = s[p];\n\t    }\n\t    return t;\n\t};\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar d_1 = __webpack_require__(62);\n\tvar createTodoListItem_1 = __webpack_require__(85);\n\tvar createTodoCardItem_1 = __webpack_require__(86);\n\tfunction filter(filterName, todo) {\n\t    switch (filterName) {\n\t        case 'completed':\n\t            return !!todo.completed;\n\t        case 'active':\n\t            return !todo.completed;\n\t        default:\n\t            return true;\n\t    }\n\t}\n\tfunction applySearch(searchQuery, todo) {\n\t    return searchQuery === '' || (todo.label || '').toLowerCase().indexOf(searchQuery) >= 0;\n\t}\n\tvar createTodoItemList = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'ul',\n\t        classes: ['todo-list'],\n\t        nodeAttributes: [\n\t            function () {\n\t                var _a = this.state, _b = _a.activeView, activeView = _b === void 0 ? 'list' : _b, _c = _a.todos, todos = _c === void 0 ? [] : _c;\n\t                return {\n\t                    classes: {\n\t                        'card-list': activeView === 'cards',\n\t                        'empty': todos.length === 0\n\t                    }\n\t                };\n\t            }\n\t        ],\n\t        getChildrenNodes: function () {\n\t            var activeFilter = this.properties.activeFilter || '';\n\t            var todos = this.properties.todos || [];\n\t            var search = this.properties.search || '';\n\t            var activeView = this.properties.activeView || 'list';\n\t            return todos\n\t                .filter(function (todo) { return filter(activeFilter, todo); })\n\t                .filter(function (todo) { return applySearch(search.toLowerCase(), todo); })\n\t                .map(function (todo) { return d_1.w(activeView === 'cards' ? createTodoCardItem_1.default : createTodoListItem_1.default, __assign({}, todo, { todoId: todo.id, id: todo.id })); })\n\t                .concat((activeView === 'cards' && todos.length) ? [\n\t                d_1.v('li.empty-filler', {}),\n\t                d_1.v('li.empty-filler', {})\n\t            ] : null);\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createTodoItemList;\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar d_1 = __webpack_require__(62);\n\tvar createButton_1 = __webpack_require__(79);\n\tvar userActions_1 = __webpack_require__(77);\n\tvar createCheckboxInput_1 = __webpack_require__(72);\n\tvar createFocusableTextInput_1 = __webpack_require__(69);\n\tvar createLabel = createWidgetBase_1.default\n\t    .mixin({\n\t    mixin: {\n\t        tagName: 'label',\n\t        onDoubleClick: function (event) {\n\t            this.properties.onDoubleClick && this.properties.onDoubleClick(event);\n\t        },\n\t        onKeyPress: function (event) {\n\t            this.properties.onKeyPress && this.properties.onKeyPress(event);\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                var _a = this, ondblclick = _a.onDoubleClick, onkeypress = _a.onKeyPress;\n\t                return {\n\t                    innerHTML: this.properties.label,\n\t                    'aria-describedby': 'edit-instructions',\n\t                    tabindex: '0',\n\t                    ondblclick: ondblclick,\n\t                    onkeypress: onkeypress\n\t                };\n\t            }\n\t        ]\n\t    }\n\t});\n\tvar createTodoListItem = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'li',\n\t        nodeAttributes: [\n\t            function () {\n\t                var _a = this.properties, completed = _a.completed, editing = _a.editing;\n\t                return {\n\t                    classes: { completed: completed, editing: editing, card: false }\n\t                };\n\t            }\n\t        ],\n\t        getChildrenNodes: function () {\n\t            var state = this.properties;\n\t            var checked = state.completed;\n\t            var label = state.label;\n\t            var focused = state.editing;\n\t            var inputOptions = {\n\t                value: label,\n\t                onKeyPress: userActions_1.todoEditInput.bind(this),\n\t                onBlur: userActions_1.todoSave,\n\t                id: this.state.id,\n\t                focused: focused,\n\t                classes: ['edit']\n\t            };\n\t            return [\n\t                d_1.v('div.view', {}, [\n\t                    d_1.w(createCheckboxInput_1.default, {\n\t                        id: 'checkbox' + this.state.id,\n\t                        classes: ['toggle'],\n\t                        checked: checked,\n\t                        onChange: userActions_1.todoToggleComplete.bind(this)\n\t                    }),\n\t                    d_1.w(createLabel, {\n\t                        id: 'label' + this.state.id,\n\t                        label: label,\n\t                        onKeyPress: userActions_1.todoEdit.bind(this),\n\t                        onDoubleClick: userActions_1.todoEdit.bind(this)\n\t                    }),\n\t                    d_1.w(createButton_1.default, {\n\t                        id: 'button' + this.state.id,\n\t                        classes: ['destroy'],\n\t                        onClick: userActions_1.todoRemove.bind(this)\n\t                    })\n\t                ]),\n\t                state.editing ?\n\t                    d_1.w(createFocusableTextInput_1.default, inputOptions) : null\n\t            ];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createTodoListItem;\n\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar d_1 = __webpack_require__(62);\n\tvar createButton_1 = __webpack_require__(79);\n\tvar userActions_1 = __webpack_require__(77);\n\tvar createCheckboxInput_1 = __webpack_require__(72);\n\tvar createFocusableTextInput_1 = __webpack_require__(69);\n\tvar createLabel = createWidgetBase_1.default\n\t    .mixin({\n\t    mixin: {\n\t        tagName: 'label',\n\t        onDoubleClick: function (event) {\n\t            this.properties.onDoubleClick && this.properties.onDoubleClick(event);\n\t        },\n\t        onKeyPress: function (event) {\n\t            this.properties.onKeyPress && this.properties.onKeyPress(event);\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                var _a = this, ondblclick = _a.onDoubleClick, onkeypress = _a.onKeyPress;\n\t                return {\n\t                    innerHTML: this.properties.label,\n\t                    'aria-describedby': 'edit-instructions',\n\t                    tabindex: '0',\n\t                    ondblclick: ondblclick,\n\t                    onkeypress: onkeypress\n\t                };\n\t            }\n\t        ]\n\t    }\n\t});\n\tvar createTodoCardItem = createWidgetBase_1.default.mixin({\n\t    mixin: {\n\t        tagName: 'li',\n\t        nodeAttributes: [\n\t            function () {\n\t                var _a = this.state, completed = _a.completed, editing = _a.editing;\n\t                return {\n\t                    classes: { completed: completed, editing: editing, card: true }\n\t                };\n\t            }\n\t        ],\n\t        getChildrenNodes: function () {\n\t            var state = this.properties;\n\t            var checked = state.completed;\n\t            var label = state.label;\n\t            var focused = state.editing;\n\t            var inputOptions = {\n\t                value: label,\n\t                id: state.id,\n\t                focused: focused,\n\t                classes: ['edit'],\n\t                onBlur: userActions_1.todoSave.bind(this),\n\t                onKeyPress: userActions_1.todoEditInput.bind(this)\n\t            };\n\t            return [\n\t                d_1.v('div.view', {}, [\n\t                    d_1.v('div.header', {}, [\n\t                        d_1.w(createCheckboxInput_1.default, {\n\t                            id: 'check' + state.id,\n\t                            classes: ['toggle'],\n\t                            checked: checked,\n\t                            onChange: userActions_1.todoToggleComplete.bind(this)\n\t                        }),\n\t                        d_1.w(createButton_1.default, {\n\t                            id: 'button' + state.id,\n\t                            classes: ['destroy'],\n\t                            onClick: userActions_1.todoRemove.bind(this)\n\t                        })\n\t                    ]),\n\t                    d_1.w(createLabel, {\n\t                        id: 'label' + state.id,\n\t                        label: label,\n\t                        onDoubleClick: userActions_1.todoEdit.bind(this),\n\t                        onKeyPress: userActions_1.todoEdit.bind(this)\n\t                    })\n\t                ]),\n\t                state.editing ?\n\t                    d_1.w(createFocusableTextInput_1.default, inputOptions) : null\n\t            ];\n\t        }\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createTodoCardItem;\n\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar createWidgetBase_1 = __webpack_require__(60);\n\tvar createFormFieldMixin_1 = __webpack_require__(70);\n\tvar createSearchInput = createWidgetBase_1.default\n\t    .mixin(createFormFieldMixin_1.default)\n\t    .mixin({\n\t    mixin: {\n\t        classes: ['search'],\n\t        tagName: 'input',\n\t        type: 'text',\n\t        onKeyUp: function (event) {\n\t            this.properties.onKeyUp && this.properties.onKeyUp(event);\n\t        },\n\t        nodeAttributes: [\n\t            function () {\n\t                var onkeyup = this.onKeyUp;\n\t                var _a = this.properties.placeholder, placeholder = _a === void 0 ? '' : _a;\n\t                return {\n\t                    placeholder: placeholder,\n\t                    onkeyup: onkeyup\n\t                };\n\t            }\n\t        ]\n\t    }\n\t});\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = createSearchInput;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// src/main.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7c54a583eb7a06d05079","import router from './routes';\nimport { bindActions as bindTodoStoreActions } from './stores/todoStore';\nimport widgetStore from './stores/widgetStore';\nimport createApp from './createApp';\n\nconst root = document.getElementsByTagName('my-app')[ 0 ];\n\nconst app = createApp({\n\troot,\n\tproperties: {\n\t\tid: 'todo-app',\n\t\texternalState: widgetStore\n\t}\n});\n\napp.append()\n\t.then(() => bindTodoStoreActions())\n\t.then(() => router.start());\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.ts","import createRoute from '@dojo/routing/createRoute';\nimport createRouter from '@dojo/routing/createRouter';\nimport { Parameters } from '@dojo/routing/interfaces';\nimport createHashHistory from '@dojo/routing/history/createHashHistory';\nimport { filterAndView, setHierarchy, showTodoDetails } from './actions/widgetStoreActions';\n\ntype FilterValue = 'active' | 'all' | 'completed';\ntype ViewValue = 'list' | 'cards';\n\ninterface AppParameters extends Parameters {\n\tfilter: FilterValue;\n\tview: ViewValue;\n}\n\ninterface TodoIdParameter extends Parameters {\n\ttodoId: string;\n}\n\nexport const mainRoute = createRoute<AppParameters>({\n\tpath: '/{filter}?{view}',\n\n\tparams([ filter ], searchParams) {\n\t\tlet activeFilter: FilterValue;\n\t\tlet activeView: ViewValue;\n\t\tconst view = searchParams.get('view');\n\n\t\tswitch (filter) {\n\t\t\tcase 'active':\n\t\t\tcase 'all':\n\t\t\tcase 'completed':\n\t\t\t\tactiveFilter = filter;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tactiveFilter = 'all';\n\t\t}\n\n\t\tswitch (view) {\n\t\t\tcase 'cards':\n\t\t\tcase 'list':\n\t\t\t\tactiveView = view;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tactiveView = 'list';\n\t\t}\n\n\t\treturn {\n\t\t\tfilter: activeFilter,\n\t\t\tview: activeView\n\t\t};\n\t},\n\n\texec(request) {\n\t\tconst { filter, view = 'list' } = request.params as AppParameters;\n\t\tsetHierarchy([ [ 'main', {} ] ]);\n\t\treturn filterAndView(filter, view);\n\t}\n});\n\nexport const todoViewRoute = createRoute({\n\tpath: '/todos/{todoId}',\n\n\texec(request) {\n\t\tconst { todoId } = request.params as TodoIdParameter;\n\n\t\treturn showTodoDetails(todoId);\n\t}\n});\n\nconst router = createRouter({\n\thistory: createHashHistory(), fallback() {\n\t\tsetHierarchy([ [ 'main', {} ] ]);\n\t\treturn filterAndView('all', 'list');\n\t}\n});\nmainRoute.append(todoViewRoute);\nrouter.append(mainRoute);\n\nexport default router;\n\n\n\n// WEBPACK FOOTER //\n// ./src/routes.ts","\"use strict\";\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar UrlSearchParams_1 = require(\"@dojo/core/UrlSearchParams\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar createRouter_1 = require(\"./createRouter\");\nvar path_1 = require(\"./lib/path\");\nvar privateStateMap = new WeakMap_1.default();\n// Store parent relationships in a separate map, since it's the parent that adds entries to this map. Parents shouldn't\n// change the private state of their children.\nvar parentMap = new WeakMap_1.default();\nvar noop = function () { };\nfunction computeDefaultParams(parameters, searchParameters, fromPathname, searchParams) {\n    var params = {};\n    parameters.forEach(function (name, index) {\n        params[name] = fromPathname[index];\n    });\n    searchParameters.forEach(function (name) {\n        var value = searchParams.get(name);\n        if (value !== undefined) {\n            params[name] = value;\n        }\n    });\n    return params;\n}\nvar createRoute = compose_1.default({\n    get parent() {\n        return parentMap.get(this);\n    },\n    get path() {\n        return privateStateMap.get(this).path;\n    },\n    append: function (add) {\n        var _this = this;\n        var routes = privateStateMap.get(this).routes;\n        var append = function (route) {\n            if (createRouter_1.hasBeenAppended(route)) {\n                throw new Error('Cannot append route that has already been appended');\n            }\n            routes.push(route);\n            parentMap.set(route, _this);\n        };\n        if (Array.isArray(add)) {\n            for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {\n                var route = add_1[_i];\n                append(route);\n            }\n        }\n        else {\n            append(add);\n        }\n    },\n    link: function (params) {\n        return createRouter_1.findRouter(this).link(this, params);\n    },\n    match: function (segments, hasTrailingSlash, searchParams) {\n        var _a = privateStateMap.get(this), computeParams = _a.computeParams, path = _a.path, trailingSlashMustMatch = _a.trailingSlashMustMatch;\n        var result = path_1.match(path, segments);\n        if (result === null) {\n            return null;\n        }\n        if (!result.hasRemaining && trailingSlashMustMatch && path.trailingSlash !== hasTrailingSlash) {\n            return null;\n        }\n        // Only extract the search params defined in the route's path.\n        var knownSearchParams = path.searchParameters.reduce(function (list, name) {\n            var value = searchParams.getAll(name);\n            if (value !== undefined) {\n                list[name] = value;\n            }\n            return list;\n        }, {});\n        var params = computeParams(result.values, new UrlSearchParams_1.default(knownSearchParams));\n        if (params === null) {\n            return null;\n        }\n        return {\n            hasRemaining: result.hasRemaining,\n            offset: result.offset,\n            params: params,\n            rawPathValues: result.values,\n            rawSearchParams: knownSearchParams\n        };\n    },\n    select: function (context, segments, hasTrailingSlash, searchParams) {\n        var _a = privateStateMap.get(this), exec = _a.exec, index = _a.index, fallback = _a.fallback, guard = _a.guard, path = _a.path, routes = _a.routes;\n        var matchResult = this.match(segments, hasTrailingSlash, searchParams);\n        // Return early if possible.\n        if (!matchResult || matchResult.hasRemaining && routes.length === 0 && !fallback) {\n            return [];\n        }\n        var params = matchResult.params;\n        if (guard) {\n            var guardResult = guard({ context: context, params: params });\n            if (typeof guardResult === 'string') {\n                return guardResult;\n            }\n            if (!guardResult) {\n                return [];\n            }\n        }\n        var handler = exec;\n        var redirect;\n        var remainingSelection;\n        var selected = false;\n        if (matchResult.hasRemaining) {\n            // Match the remaining segments. Return a hierarchy if nested routes were selected.\n            var remainingSegments_1 = segments.slice(matchResult.offset);\n            selected = routes.some(function (nested) {\n                var nestedResult = nested.select(context, remainingSegments_1, hasTrailingSlash, searchParams);\n                if (typeof nestedResult === 'string') {\n                    redirect = nestedResult;\n                    return true;\n                }\n                if (nestedResult.length > 0) {\n                    remainingSelection = nestedResult;\n                    return true;\n                }\n                return false;\n            });\n            // No remaining segments matched, only select this route if a fallback handler was specified.\n            if (!selected && fallback) {\n                selected = true;\n                handler = fallback;\n            }\n        }\n        else {\n            selected = true;\n            if (index) {\n                handler = index;\n            }\n        }\n        if (!selected) {\n            return [];\n        }\n        if (redirect !== undefined) {\n            return redirect;\n        }\n        var rawPathValues = matchResult.rawPathValues, rawSearchParams = matchResult.rawSearchParams;\n        var selection = {\n            // Use a noop handler if exec was not provided. Something needs to be returned otherwise the router may\n            // think no routes were selected.\n            handler: handler || noop,\n            path: path,\n            params: params,\n            rawPathValues: rawPathValues,\n            rawSearchParams: rawSearchParams,\n            route: this\n        };\n        return remainingSelection ? [selection].concat(remainingSelection) : [selection];\n    }\n}, function (instance, _a) {\n    var _b = _a === void 0 ? {} : _a, exec = _b.exec, fallback = _b.fallback, guard = _b.guard, index = _b.index, computeParams = _b.params, path = _b.path, _c = _b.trailingSlashMustMatch, trailingSlashMustMatch = _c === void 0 ? true : _c;\n    if (path && /#/.test(path)) {\n        throw new TypeError('Path must not contain \\'#\\'');\n    }\n    var deconstructedPath = path_1.deconstruct(path || '/');\n    var parameters = deconstructedPath.parameters, searchParameters = deconstructedPath.searchParameters;\n    if (computeParams) {\n        if (parameters.length === 0 && searchParameters.length === 0) {\n            throw new TypeError('Can\\'t specify params() if path doesn\\'t contain any');\n        }\n    }\n    else {\n        computeParams = function (fromPathname, searchParams) {\n            return computeDefaultParams(parameters, searchParameters, fromPathname, searchParams);\n        };\n    }\n    privateStateMap.set(instance, {\n        computeParams: computeParams,\n        exec: exec,\n        fallback: fallback,\n        guard: guard,\n        index: index,\n        path: deconstructedPath,\n        routes: [],\n        trailingSlashMustMatch: trailingSlashMustMatch\n    });\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createRoute;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/routing/createRoute.js\n// module id = 6\n// module chunks = 0","\"use strict\";\nvar instrument_1 = require(\"@dojo/core/instrument\");\nvar lang_1 = require(\"@dojo/core/lang\");\nvar array_1 = require(\"@dojo/shim/array\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar Symbol_1 = require(\"@dojo/shim/Symbol\");\nvar aspect_1 = require(\"./aspect\");\n/**\n * The default factory label if no label can be derived during the factory creation process\n */\nvar DEFAULT_FACTORY_LABEL = 'Compose';\n/* References to support minification */\nvar defineProperty = Object.defineProperty;\nvar isArray = Array.isArray;\nvar objectCreate = Object.create;\nvar objectKeys = Object.keys;\n/**\n * A weakmap that stores all the private data for a factory\n */\nvar privateFactoryData = new WeakMap_1.default();\n/**\n * An internal function which stubs out a method which, when called at runtime, throws.\n *\n * @param method The name of \"abstract\" method being called\n */\nfunction missingMethod(method) {\n    return function throwOnMissingMethod() {\n        throw new TypeError(\"Advice being applied to missing method named: \" + method);\n    };\n}\n/**\n * Internal function which can label a factory with a name and also sets\n * the `toString()` method on the prototype to return the approriate\n * name for instances.\n *\n * @param fn The name of the factory to label\n * @param value The name to supply for the label\n */\nfunction assignFactoryName(factory, value) {\n    if (typeof factory === 'function' && factory.prototype) {\n        assignFunctionName(factory, value);\n        defineProperty(factory.prototype, Symbol_1.default.toStringTag, {\n            get: function () {\n                return value;\n            },\n            configurable: true\n        });\n    }\n}\n/**\n * Internal function which can label a function with a name\n */\nfunction assignFunctionName(fn, value) {\n    var nameDescriptor = Object.getOwnPropertyDescriptor(fn, 'name');\n    if (typeof nameDescriptor === 'undefined' || nameDescriptor.configurable) {\n        defineProperty(fn, 'name', {\n            value: value,\n            writable: true,\n            configurable: true\n        });\n    }\n}\n/**\n * A helper function that copies own properties and their descriptors\n * from one or more sources to a target object. Includes non-enumerable properties\n *\n * @param overwrite If `true` properties, like arrays, will not be merged, instead overwritten\n * @param target The target that properties should be copied onto\n * @param sources The rest of the parameters treated as sources to apply\n */\nfunction assignProperties(overwrite, target) {\n    var sources = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        sources[_i - 2] = arguments[_i];\n    }\n    sources.forEach(function (source) {\n        if (!source) {\n            return;\n        }\n        Object.defineProperties(target, Object.getOwnPropertyNames(source).reduce(function (descriptors, key) {\n            if (key !== 'constructor') {\n                var sourceDescriptor = Object.getOwnPropertyDescriptor(source, key);\n                var sourceValue = sourceDescriptor && sourceDescriptor.value;\n                var targetDescriptor = Object.getOwnPropertyDescriptor(target, key);\n                var targetValue = targetDescriptor && targetDescriptor.value;\n                /* Special handling to merge array proprties */\n                if (!overwrite && isArray(sourceValue) && isArray(targetValue)) {\n                    sourceDescriptor.value = sourceValue.reduce(function (value, current) {\n                        if (!array_1.includes(target[key], current)) {\n                            value.push(current);\n                        }\n                        return value;\n                    }, array_1.from(targetValue));\n                }\n                descriptors[key] = sourceDescriptor;\n            }\n            return descriptors;\n        }, objectCreate(null)));\n    });\n    return target;\n}\n/**\n * A helper funtion to return a function that is rebased to infer that the\n * first argument of the passed function will be the `this` when the function\n * is executed.\n *\n * @param  fn The function to be rebased\n * @return    The rebased function\n */\nfunction rebase(fn) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn.apply(this, [this].concat(args));\n    };\n}\n/**\n * For a given factory, return the names of the initialization functions that will be\n * invoked upon construction.\n *\n * @param factory The factory that the array of function names should be returned for\n */\nfunction getInitFunctionNames(factory) {\n    var initFns = privateFactoryData.get(factory).initFns;\n    if (initFns) {\n        return initFns.map(function (fn) { return fn.name; });\n    }\n}\nexports.getInitFunctionNames = getInitFunctionNames;\n/* The rebased functions we need to decorate compose constructors with */\n/**\n * Perform an extension of a class\n *\n * @deprecated\n */\nvar doExtend = rebase(extend);\n/**\n * Perform a mixin of a class\n */\nvar doMixin = rebase(mixin);\n/**\n * Perform a override of a class\n */\nvar doOverride = rebase(override);\n/**\n * Perform an overlay of a class\n */\nvar doOverlay = rebase(overlay);\n/**\n * Apply aspect advice to a class\n */\nvar doAspect = rebase(aspect);\n/**\n * Add static method/properties to a class\n */\nvar doStatic = rebase(_static);\n/**\n * Take a mixin and return a factory descriptor for the mixin\n *\n * @param mixin The factory to return the descriptor for\n * @template T The outer type of the descriptor\n * @template O The outer factory options of the descriptor\n * @template U The inner type of the descriptor\n * @template P The inner factory options of the descriptor\n */\nfunction factoryDescriptor(mixin) {\n    return {\n        mixin: mixin,\n        className: mixin.name\n    };\n}\n/**\n * Generate a factory descriptor for a class\n */\nvar doFactoryDescriptor = rebase(factoryDescriptor);\n/**\n * A set of functions that are used to decorate the compose factories\n */\nvar staticMethods = {\n    extend: doExtend,\n    mixin: doMixin,\n    override: doOverride,\n    overlay: doOverlay,\n    from: doFrom,\n    before: doBefore,\n    after: doAfter,\n    around: doAround,\n    aspect: doAspect,\n    factoryDescriptor: doFactoryDescriptor,\n    static: doStatic\n};\n/**\n * Internal function that merges (or creates) an advice map\n *\n * @param sources The advice maps to be merged into a single one\n */\nfunction assignAdviceMap() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    var result = {};\n    sources.forEach(function (source) {\n        if (source) {\n            for (var method in source) {\n                result[method] = result[method] ? result[method].concat(source[method]) : source[method].slice();\n            }\n        }\n    });\n    return result;\n}\n/**\n * An internal function that takes a set of create widget options and returns a set of private factory data\n *\n * @param options The set of factory options to use in creating the private factory data\n */\nfunction createPrivateFactoryData(_a) {\n    var optionsAdvice = _a.advice, factories = _a.factories, initFunction = _a.initFunction, overwrite = _a.overwrite, proto = _a.proto, staticProperties = _a.staticProperties;\n    var factoryData = (factories || []).reduce(function (factoryData, factory) {\n        var _a = privateFactoryData.get(factory), advice = _a.advice, base = _a.base, initFns = _a.initFns;\n        if (advice) {\n            factoryData.advice = assignAdviceMap(factoryData.advice, advice);\n        }\n        if (base) {\n            assignProperties(false, factoryData.base, base);\n        }\n        var optionsInitFns = factoryData.initFns;\n        initFns.forEach(function (initFn) {\n            if (!array_1.includes(optionsInitFns, initFn)) {\n                optionsInitFns.push(initFn);\n            }\n        });\n        return factoryData;\n    }, {\n        base: {},\n        initFns: [],\n        staticProperties: staticProperties ? lang_1.assign({}, staticProperties) : undefined\n    });\n    if (initFunction) {\n        factoryData.initFns.push(initFunction);\n    }\n    if (optionsAdvice) {\n        factoryData.advice = assignAdviceMap(factoryData.advice, optionsAdvice);\n    }\n    assignProperties(Boolean(overwrite), factoryData.base, proto);\n    return factoryData;\n}\nfunction createFactory(options) {\n    /**\n     * A compose factory\n     */\n    function factory() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (this && this.constructor === factory) {\n            throw new SyntaxError('Factories cannot be called with \"new\".');\n        }\n        var instance = objectCreate(factory.prototype);\n        /* clone any arrays in the instance */\n        for (var key in instance) {\n            if (isArray(Object.getOwnPropertyDescriptor(factory.prototype, key).value)) {\n                instance[key] = array_1.from(instance[key]);\n            }\n        }\n        args.unshift(instance);\n        privateFactoryData.get(factory).initFns.forEach(function (fn) {\n            fn.apply(null, args);\n        });\n        return instance;\n    }\n    var factoryData = createPrivateFactoryData(options);\n    privateFactoryData.set(factory, factoryData);\n    var factoryPrototype = factory.prototype;\n    /* mixin base properties into the prototype */\n    assignProperties(false, factoryPrototype, factoryData.base);\n    /* apply any advice to the prototype */\n    if (factoryData.advice) {\n        var _loop_1 = function (method) {\n            factoryData.advice[method].forEach(function (_a) {\n                var aspect = _a[0], advice = _a[1];\n                var sourceMethod = factoryPrototype[method] || missingMethod(method);\n                switch (aspect) {\n                    case 'before':\n                        factoryPrototype[method] = aspect_1.before(sourceMethod, advice);\n                        break;\n                    case 'after':\n                        factoryPrototype[method] = aspect_1.after(sourceMethod, advice);\n                        break;\n                    case 'around':\n                        factoryPrototype[method] = aspect_1.around(sourceMethod, advice);\n                }\n            });\n        };\n        for (var method in factoryData.advice) {\n            _loop_1(method);\n        }\n    }\n    /* assign a constructor to the prototype */\n    factoryPrototype.constructor = factory;\n    /* assign static methods/properties */\n    lang_1.assign(factory, staticMethods, factoryData.staticProperties);\n    /* assign factory name */\n    var className = options.className ||\n        (options.factories && options.factories[0] && options.factories[0].name) ||\n        DEFAULT_FACTORY_LABEL;\n    assignFactoryName(factory, className);\n    /* freeze the factory, so it cannot be accidently modified */\n    Object.freeze(factory);\n    return factory;\n}\n/**\n * A custom type guard that determines if the value is a ComposeFactory\n *\n * @param   value The target to check\n * @returns       Return true if it is a ComposeFactory, otherwise false\n */\nfunction isComposeFactory(value) {\n    return Boolean(value && privateFactoryData.get(value));\n}\nexports.isComposeFactory = isComposeFactory;\nfunction extend(base, className, extension) {\n    instrument_1.deprecated({ message: 'This function will be removed, use \"override\" instead.', name: 'extend' });\n    if (typeof className !== 'string') {\n        extension = className;\n        className = undefined;\n    }\n    return createFactory({\n        className: className,\n        proto: typeof extension === 'function' ? extension.prototype : extension,\n        factories: [base]\n    });\n}\nfunction override(baseFactory, className, properties) {\n    if (typeof className !== 'string') {\n        properties = className;\n        className = undefined;\n    }\n    if (typeof properties !== 'object') {\n        throw new TypeError('Argument \"properties\" must be an object.');\n    }\n    var base = privateFactoryData.get(baseFactory).base;\n    /* TODO: In TypeScript 2.1 we have merge types which can then be used to provide type checking at design time\n     * similiar to this */\n    Object.keys(properties).forEach(function (key) {\n        if (!(key in base)) {\n            throw new TypeError(\"Attempting to override missing property \\\"\" + key + \"\\\"\");\n        }\n    });\n    return createFactory({\n        className: className,\n        overwrite: true,\n        proto: properties,\n        factories: [baseFactory]\n    });\n}\n/**\n * Internal implementation of the overlay functionality, to allow a function to modify a\n * compose factory prototype\n *\n * @param base The target compose factory\n * @param overlayFunction The callback function that will modify the prototype of the factory\n */\nfunction overlay(base, overlayFunction) {\n    var factory = createFactory({\n        factories: [base]\n    });\n    overlayFunction(factory.prototype);\n    return factory;\n}\n/**\n * Internal function that converts `AspectAdvice` into `AdviceMap` which can then be used for\n * creating a factory\n *\n * @param aspectAdvice The aspect advice to convert into an advice map\n */\nfunction aspectAdviceToAdviceMap(aspectAdvice) {\n    if (!aspectAdvice) {\n        return;\n    }\n    var adviceMap = {};\n    var beforeAdvice = aspectAdvice.before;\n    var afterAdvice = aspectAdvice.after;\n    var aroundAdvice = aspectAdvice.around;\n    function mapAdvice(type, key, advice) {\n        var adviceTuple = [type, advice[key]];\n        if (adviceMap[key]) {\n            adviceMap[key].push(adviceTuple);\n        }\n        else {\n            adviceMap[key] = [adviceTuple];\n        }\n    }\n    if (beforeAdvice) {\n        objectKeys(beforeAdvice).forEach(function (key) {\n            /* TODO: Remove ! in 2.1 */\n            mapAdvice('before', key, beforeAdvice);\n        });\n    }\n    if (afterAdvice) {\n        objectKeys(afterAdvice).forEach(function (key) {\n            /* TODO: Remove ! in 2.1 */\n            mapAdvice('after', key, afterAdvice);\n        });\n    }\n    if (aroundAdvice) {\n        objectKeys(aroundAdvice).forEach(function (key) {\n            /* TODO: Remove ! in 2.1 */\n            mapAdvice('around', key, aroundAdvice);\n        });\n    }\n    return adviceMap;\n}\n/**\n * A custom type guard that determines if a value is ComposeMixinable\n *\n * @param value The value to guard for\n */\nfunction isComposeMixinable(value) {\n    return Boolean(value && 'factoryDescriptor' in value && typeof value.factoryDescriptor === 'function');\n}\n/**\n * The internal implementation of mixin in values into a compose factory\n *\n * @param base The base compose factory that is the target for being mixed in\n * @param toMixin The value to be mixed in\n */\nfunction mixin(base, toMixin) {\n    /* ensure we are dealing with a mixinDescriptor */\n    var mixinDescriptor = isComposeMixinable(toMixin) ? toMixin.factoryDescriptor() : toMixin;\n    /* destructure out most of the factory creation options */\n    var mixin = mixinDescriptor.mixin, initFunction = mixinDescriptor.initialize, aspectAdvice = mixinDescriptor.aspectAdvice, className = mixinDescriptor.className;\n    /* we will at least be using the base factory to create the new one */\n    var factories = [base];\n    var proto;\n    /* if mixin is a compose factory, we will pass it as a factory used to create the new factory */\n    if (isComposeFactory(mixin)) {\n        factories.push(mixin);\n    }\n    else {\n        /* of which, we can have a constructor function/class, or an object literal (or undefined) */\n        proto = typeof mixin === 'function' ? mixin.prototype : mixin;\n    }\n    /* convert the advice, if any, to the format used by createFactory */\n    var advice = aspectAdviceToAdviceMap(aspectAdvice);\n    /* label the initFn */\n    if (initFunction) {\n        assignFunctionName(initFunction, \"mixin\" + (className || (isComposeFactory(mixin) && mixin.name) || base.name));\n    }\n    /* return the newly created factory */\n    return createFactory({\n        advice: advice,\n        factories: factories,\n        initFunction: initFunction,\n        className: className,\n        proto: proto\n    });\n}\n/**\n * Internal implementation of extracting methods from another object\n *\n * @param base The target that the method should be extracted from\n * @param method The name of the method\n */\nfunction from(base, method) {\n    return base.prototype[method];\n}\n/**\n * Internal implementation to apply from when `this` represents the base\n *\n * @param base The target that the method should be extracted from\n * @param method The name of the method\n */\nfunction doFrom(base, method) {\n    return createFactory({\n        factories: [this],\n        proto: (_a = {},\n            _a[method] = base.prototype[method],\n            _a)\n    });\n    var _a;\n}\nfunction before() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var base;\n    var method;\n    var advice;\n    if (args.length >= 3) {\n        base = args[0], method = args[1], advice = args[2];\n        method = base.prototype[method];\n    }\n    else {\n        method = args[0], advice = args[1];\n    }\n    return aspect_1.before(method, advice);\n}\n/**\n * The internal implementation to apply before advice when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction doBefore(method, advice) {\n    return createFactory({\n        factories: [this],\n        advice: (_a = {},\n            _a[method] = [['before', advice]],\n            _a)\n    });\n    var _a;\n}\nfunction after() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var base;\n    var method;\n    var advice;\n    if (args.length >= 3) {\n        base = args[0], method = args[1], advice = args[2];\n        method = base.prototype[method];\n    }\n    else {\n        method = args[0], advice = args[1];\n    }\n    return aspect_1.after(method, advice);\n}\n/**\n * The internal implementation to apply after advice when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction doAfter(method, advice) {\n    return createFactory({\n        factories: [this],\n        advice: (_a = {},\n            _a[method] = [['after', advice]],\n            _a)\n    });\n    var _a;\n}\nfunction around() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var base;\n    var method;\n    var advice;\n    if (args.length >= 3) {\n        base = args[0], method = args[1], advice = args[2];\n        method = base.prototype[method];\n    }\n    else {\n        method = args[0], advice = args[1];\n    }\n    return aspect_1.around(method, advice);\n}\n/**\n * The internal implementation to apply around advice when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction doAround(method, advice) {\n    return createFactory({\n        factories: [this],\n        advice: (_a = {},\n            _a[method] = [['around', advice]],\n            _a)\n    });\n    var _a;\n}\n/**\n * The internal implementation of applying aspect advice to a factory\n *\n * @param base The base factory the advice should be applied to\n * @param advice The advice map to apply to the factory\n */\nfunction aspect(base, advice) {\n    return createFactory({\n        factories: [base],\n        advice: aspectAdviceToAdviceMap(advice)\n    });\n}\nfunction create(className, base, initFunction) {\n    /* disambugate arguments */\n    if (typeof className !== 'string') {\n        initFunction = base;\n        base = className;\n        className = undefined;\n    }\n    /* Label the initFunction */\n    if (initFunction && className) {\n        assignFunctionName(initFunction, \"init\" + className);\n    }\n    var factories;\n    var proto;\n    /* If base is a compose factory, set it as the factory array */\n    if (base && isComposeFactory(base)) {\n        factories = [base];\n    }\n    else {\n        proto = typeof base === 'function' ? base.prototype : base;\n    }\n    return createFactory({\n        className: className,\n        factories: factories,\n        initFunction: initFunction,\n        proto: proto\n    });\n}\n/**\n * Internal implementation of applying static properties to a compose factory\n *\n * @param factory The factory that the static properties should be applied to\n * @param staticProperties The properties to be applied to the factory\n */\nfunction _static(base, staticProperties) {\n    return createFactory({\n        factories: [base],\n        staticProperties: staticProperties\n    });\n}\n/**\n * A factory construction utility\n *\n * @param base An ES6 Class, ComposeFactory or Object literal to use as the base for the new factory\n * @param initFunction An optional initialization function for the factory\n */\nvar compose = create;\n/* Add static methods to compose */\nlang_1.assign(compose, {\n    create: create,\n    static: _static,\n    extend: extend,\n    mixin: mixin,\n    override: override,\n    overlay: overlay,\n    from: from,\n    before: before,\n    after: after,\n    around: around,\n    aspect: aspect\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = compose;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/compose/compose.js\n// module id = 7\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./has\");\n/**\n * The default message to warn when no other is provided\n */\nvar DEFAULT_DEPRECATED_MESSAGE = 'This function will be removed in future versions.';\n/**\n * When set, globalWarn will be used instead of `console.warn`\n */\nvar globalWarn;\n/**\n * A function that will console warn that a function has been deprecated\n *\n * @param options Provide options which change the display of the message\n */\nfunction deprecated(_a) {\n    var _b = _a === void 0 ? {} : _a, message = _b.message, name = _b.name, warn = _b.warn, url = _b.url;\n    /* istanbul ignore else: testing with debug off is difficult */\n    if (has_1.default('debug')) {\n        message = message || DEFAULT_DEPRECATED_MESSAGE;\n        var warning = \"DEPRECATED: \" + (name ? name + ': ' : '') + message;\n        if (url) {\n            warning += \"\\n\\n    See \" + url + \" for more details.\\n\\n\";\n        }\n        if (warn) {\n            warn(warning);\n        }\n        else if (globalWarn) {\n            globalWarn(warning);\n        }\n        else {\n            console.warn(warning);\n        }\n    }\n}\nexports.deprecated = deprecated;\n/**\n * A function that generates before advice that can be used to warn when an API has been deprecated\n *\n * @param options Provide options which change the display of the message\n */\nfunction deprecatedAdvice(options) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        deprecated(options);\n        return args;\n    };\n}\nexports.deprecatedAdvice = deprecatedAdvice;\n/**\n * A method decorator that will console warn when a method if invoked that is deprecated\n *\n * @param options Provide options which change the display of the message\n */\nfunction deprecatedDecorator(options) {\n    return function (target, propertyKey, descriptor) {\n        if (has_1.default('debug')) {\n            var originalFn_1 = descriptor.value;\n            options = options || {};\n            /* IE 10/11 don't have the name property on functions */\n            options.name = target.constructor.name ? target.constructor.name + \"#\" + propertyKey : propertyKey;\n            descriptor.value = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                deprecated(options);\n                return originalFn_1.apply(target, args);\n            };\n        }\n        return descriptor;\n    };\n}\nexports.deprecatedDecorator = deprecatedDecorator;\n/**\n * A function that will set the warn function that will be used instead of `console.warn` when\n * logging warning messages\n *\n * @param warn The function (or `undefined`) to use instead of `console.warn`\n */\nfunction setWarn(warn) {\n    globalWarn = warn;\n}\nexports.setWarn = setWarn;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/instrument.js\n// module id = 8\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar global_1 = require(\"./global\");\nvar has_1 = require(\"@dojo/shim/support/has\");\n__export(require(\"@dojo/shim/support/has\"));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = has_1.default;\nhas_1.add('object-assign', typeof global_1.default.Object.assign === 'function');\nhas_1.add('raf', typeof requestAnimationFrame === 'function');\nhas_1.add('arraybuffer', typeof global_1.default.ArrayBuffer !== 'undefined');\nhas_1.add('formdata', typeof global_1.default.FormData !== 'undefined');\nhas_1.add('xhr', typeof global_1.default.XMLHttpRequest !== 'undefined');\nhas_1.add('xhr2', has_1.default('xhr') && 'responseType' in global_1.default.XMLHttpRequest.prototype);\nhas_1.add('xhr2-blob', function () {\n    if (!has_1.default('xhr2')) {\n        return false;\n    }\n    var request = new XMLHttpRequest();\n    request.open('GET', '/', true);\n    request.responseType = 'blob';\n    request.abort();\n    return request.responseType === 'blob';\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/has.js\n// module id = 9\n// module chunks = 0","\"use strict\";\nvar globalObject = (function () {\n    if (typeof window !== 'undefined') {\n        // Browsers\n        return window;\n    }\n    else if (typeof global !== 'undefined') {\n        // Node\n        return global;\n    }\n    else if (typeof self !== 'undefined') {\n        // Web workers\n        return self;\n    }\n    return {};\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = globalObject;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/global.js\n// module id = 10\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar global_1 = require(\"./global\");\nvar has_1 = require(\"@dojo/has/has\");\nvar has_2 = require(\"@dojo/has/has\");\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = has_1.default;\n__export(require(\"@dojo/has/has\"));\n/* ECMAScript 6 and 7 Features */\n/*\n * Determine whether or not native Symbol exists. If it doesn't, we don't want to use\n * a few other native implementations like Map, WeakMap, Set.  Consider a polyfill that provides Symbol,\n * Map, etc in the global namespace. If the polyfill's Symbol is not compatible with our Symbol, neither\n * will be anything that uses their iterator symbol, like Map, Set, etc.\n */\n/* Symbol */\nhas_2.add('es6-symbol', typeof global_1.default.Symbol !== 'undefined' && typeof Symbol() === 'symbol');\n/* Object */\nhas_2.add('es6-object-assign', typeof Object.assign === 'function');\n/* Array */\nhas_2.add('es6-array-from', 'from' in global_1.default.Array);\nhas_2.add('es6-array-of', 'of' in global_1.default.Array);\nhas_2.add('es6-array-fill', function () {\n    if ('fill' in global_1.default.Array.prototype) {\n        /* Some versions of Safari do not properly implement this */\n        return [1].fill(9, Number.POSITIVE_INFINITY)[0] === 1;\n    }\n    return false;\n});\nhas_2.add('es6-array-findindex', 'findIndex' in global_1.default.Array.prototype);\nhas_2.add('es6-array-find', 'find' in global_1.default.Array.prototype);\nhas_2.add('es6-array-copywithin', 'copyWithin' in global_1.default.Array.prototype);\nhas_2.add('es7-array-includes', 'includes' in global_1.default.Array.prototype);\n/* String */\nhas_2.add('es6-string-raw', function () {\n    function getCallSite(callSite) {\n        var substitutions = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            substitutions[_i - 1] = arguments[_i];\n        }\n        return callSite;\n    }\n    if ('raw' in global_1.default.String) {\n        var b = 1;\n        var callSite = (_a = [\"a\\n\", \"\"], _a.raw = [\"a\\\\n\", \"\"], getCallSite(_a, b));\n        callSite.raw = ['a\\\\n'];\n        var supportsTrunc = global_1.default.String.raw(callSite, 42) === 'a:\\\\n';\n        return supportsTrunc;\n    }\n    return false;\n    var _a;\n});\nhas_2.add('es6-string-fromcodepoint', 'fromCodePoint' in global_1.default.String);\nhas_2.add('es6-string-codepointat', 'codePointAt' in global_1.default.String.prototype);\nhas_2.add('es6-string-normalize', 'normalize' in global_1.default.String.prototype);\nhas_2.add('es6-string-repeat', 'repeat' in global_1.default.String.prototype);\nhas_2.add('es6-string-startswith', 'startsWith' in global_1.default.String.prototype);\nhas_2.add('es6-string-endswith', 'endsWith' in global_1.default.String.prototype);\nhas_2.add('es6-string-includes', 'includes' in global_1.default.String.prototype);\nhas_2.add('es6-string-padstart', 'padStart' in global_1.default.String.prototype);\nhas_2.add('es6-string-padend', 'padEnd' in global_1.default.String.prototype);\n/* Math */\nhas_2.add('es6-math-acosh', typeof global_1.default.Math.acosh === 'function');\nhas_2.add('es6-math-clz32', typeof global_1.default.Math.clz32 === 'function');\nhas_2.add('es6-math-imul', function () {\n    if ('imul' in global_1.default.Math) {\n        /* Some versions of Safari on ios do not properly implement this */\n        return Math.imul(0xffffffff, 5) === -5;\n    }\n    return false;\n});\n/* Promise */\nhas_2.add('es6-promise', typeof global_1.default.Promise !== 'undefined' && has_1.default('es6-symbol'));\n/* Observable */\nhas_2.add('es-observable', typeof global_1.default.Observable !== 'undefined');\n/* Set */\nhas_2.add('es6-set', function () {\n    if (typeof global_1.default.Set === 'function') {\n        /* IE11 and older versions of Safari are missing critical ES6 Set functionality */\n        var set = new global_1.default.Set([1]);\n        return set.has(1) && 'keys' in set && typeof set.keys === 'function' && has_1.default('es6-symbol');\n    }\n    return false;\n});\n/* Map */\nhas_2.add('es6-map', function () {\n    if (typeof global_1.default.Map === 'function') {\n        /*\n        IE11 and older versions of Safari are missing critical ES6 Map functionality\n        We wrap this in a try/catch because sometimes the Map constructor exists, but does not\n        take arguments (iOS 8.4)\n         */\n        try {\n            var map = new global_1.default.Map([[0, 1]]);\n            return map.has(0) &&\n                typeof map.keys === 'function' && has_1.default('es6-symbol') &&\n                typeof map.values === 'function' &&\n                typeof map.entries === 'function';\n        }\n        catch (e) {\n            /* istanbul ignore next: not testing on iOS at the moment */\n            return false;\n        }\n    }\n    return false;\n});\n/* WeakMap */\nhas_2.add('es6-weakmap', function () {\n    if (typeof global_1.default.WeakMap !== 'undefined') {\n        /* IE11 and older versions of Safari are missing critical ES6 Map functionality */\n        var key1 = {};\n        var key2 = {};\n        var map = new global_1.default.WeakMap([[key1, 1]]);\n        Object.freeze(key1);\n        return map.get(key1) === 1 && map.set(key2, 2) === map && has_1.default('es6-symbol');\n    }\n    return false;\n});\n/* Miscellaneous features */\nhas_2.add('float32array', 'Float32Array' in global_1.default);\nhas_2.add('setimmediate', typeof global_1.default.setImmediate !== 'undefined');\nhas_2.add('postmessage', typeof postMessage === 'function');\nhas_2.add('microtasks', function () { return has_1.default('es6-promise') || has_1.default('host-node') || has_1.default('dom-mutationobserver'); });\n/* DOM Features */\nhas_2.add('dom-mutationobserver', function () { return has_1.default('host-browser') && Boolean(global_1.default.MutationObserver || global_1.default.WebKitMutationObserver); });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/support/has.js\n// module id = 11\n// module chunks = 0","\"use strict\";\nvar globalObject = (typeof global === 'undefined') ? Function('return this')() : global;\n// global spec defines a reference to the global object called 'global'\n// https://github.com/tc39/proposal-global\nif (!('global' in globalObject)) {\n    globalObject.global = globalObject;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = globalObject;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/support/global.js\n// module id = 12\n// module chunks = 0","\"use strict\";\nfunction isFeatureTestThenable(value) {\n    return value && value.then;\n}\n/**\n * A cache of results of feature tests\n */\nexports.testCache = {};\n/**\n * A cache of the un-resolved feature tests\n */\nexports.testFunctions = {};\n/**\n * A cache of unresolved thenables (probably promises)\n * @type {{}}\n */\nvar testThenables = {};\n/**\n * A reference to the global scope (`window` in a browser, `global` in NodeJS)\n */\nvar globalScope = (function () {\n    /* istanbul ignore else */\n    if (typeof window !== 'undefined') {\n        // Browsers\n        return window;\n    }\n    else if (typeof global !== 'undefined') {\n        // Node\n        return global;\n    }\n    else if (typeof self !== 'undefined') {\n        // Web workers\n        return self;\n    }\n    /* istanbul ignore next */\n    return {};\n})();\n/* Grab the staticFeatures if there are available */\nvar staticFeatures = (globalScope.DojoHasEnvironment || {}).staticFeatures;\n/* Cleaning up the DojoHasEnviornment */\nif ('DojoHasEnvironment' in globalScope) {\n    delete globalScope.DojoHasEnvironment;\n}\n/**\n * Custom type guard to narrow the `staticFeatures` to either a map or a function that\n * returns a map.\n *\n * @param value The value to guard for\n */\nfunction isStaticFeatureFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * The cache of asserted features that were available in the global scope when the\n * module loaded\n */\nvar staticCache = staticFeatures\n    ? isStaticFeatureFunction(staticFeatures)\n        ? staticFeatures.apply(globalScope)\n        : staticFeatures\n    : {};/* Providing an empty cache, if none was in the environment\n\n/**\n* AMD plugin function.\n*\n* Conditional loads modules based on a has feature test value.\n*\n* @param resourceId Gives the resolved module id to load.\n* @param require The loader require function with respect to the module that contained the plugin resource in its\n*                dependency list.\n* @param load Callback to loader that consumes result of plugin demand.\n*/\nfunction load(resourceId, require, load, config) {\n    resourceId ? require([resourceId], load) : load();\n}\nexports.load = load;\n/**\n * AMD plugin function.\n *\n * Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test\n * value(s).\n *\n * @param resourceId The id of the module\n * @param normalize Resolves a relative module id into an absolute module id\n */\nfunction normalize(resourceId, normalize) {\n    var tokens = resourceId.match(/[\\?:]|[^:\\?]*/g) || [];\n    var i = 0;\n    function get(skip) {\n        var term = tokens[i++];\n        if (term === ':') {\n            // empty string module name, resolves to null\n            return null;\n        }\n        else {\n            // postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n            if (tokens[i++] === '?') {\n                if (!skip && has(term)) {\n                    // matched the feature, get the first value from the options\n                    return get();\n                }\n                else {\n                    // did not match, get the second value, passing over the first\n                    get(true);\n                    return get(skip);\n                }\n            }\n            // a module\n            return term;\n        }\n    }\n    var id = get();\n    return id && normalize(id);\n}\nexports.normalize = normalize;\n/**\n * Check if a feature has already been registered\n *\n * @param feature the name of the feature\n */\nfunction exists(feature) {\n    var normalizedFeature = feature.toLowerCase();\n    return Boolean(normalizedFeature in staticCache || normalizedFeature in exports.testCache || exports.testFunctions[normalizedFeature]);\n}\nexports.exists = exists;\n/**\n * Register a new test for a named feature.\n *\n * @example\n * has.add('dom-addeventlistener', !!document.addEventListener);\n *\n * @example\n * has.add('touch-events', function () {\n *    return 'ontouchstart' in document\n * });\n *\n * @param feature the name of the feature\n * @param value the value reported of the feature, or a function that will be executed once on first test\n * @param overwrite if an existing value should be overwritten. Defaults to false.\n */\nfunction add(feature, value, overwrite) {\n    if (overwrite === void 0) { overwrite = false; }\n    var normalizedFeature = feature.toLowerCase();\n    if (exists(normalizedFeature) && !overwrite && !(normalizedFeature in staticCache)) {\n        throw new TypeError(\"Feature \\\"\" + feature + \"\\\" exists and overwrite not true.\");\n    }\n    if (typeof value === 'function') {\n        exports.testFunctions[normalizedFeature] = value;\n    }\n    else if (isFeatureTestThenable(value)) {\n        testThenables[feature] = value.then(function (resolvedValue) {\n            exports.testCache[feature] = resolvedValue;\n            delete testThenables[feature];\n        }, function () {\n            delete testThenables[feature];\n        });\n    }\n    else {\n        exports.testCache[normalizedFeature] = value;\n        delete exports.testFunctions[normalizedFeature];\n    }\n}\nexports.add = add;\n/**\n * Return the current value of a named feature.\n *\n * @param feature The name (if a string) or identifier (if an integer) of the feature to test.\n */\nfunction has(feature) {\n    var result;\n    var normalizedFeature = feature.toLowerCase();\n    if (normalizedFeature in staticCache) {\n        result = staticCache[normalizedFeature];\n    }\n    else if (exports.testFunctions[normalizedFeature]) {\n        result = exports.testCache[normalizedFeature] = exports.testFunctions[normalizedFeature].call(null);\n        delete exports.testFunctions[normalizedFeature];\n    }\n    else if (normalizedFeature in exports.testCache) {\n        result = exports.testCache[normalizedFeature];\n    }\n    else if (feature in testThenables) {\n        return false;\n    }\n    else {\n        throw new TypeError(\"Attempt to detect unregistered has feature \\\"\" + feature + \"\\\"\");\n    }\n    return result;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = has;\n/*\n * Out of the box feature tests\n */\n/* Environments */\n/* Used as a value to provide a debug only code path */\nadd('debug', true);\n/* Detects if the environment is \"browser like\" */\nadd('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');\n/* Detects if the environment appears to be NodeJS */\nadd('host-node', function () {\n    if (typeof process === 'object' && process.versions && process.versions.node) {\n        return process.versions.node;\n    }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/has/has.js\n// module id = 13\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 14\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./has\");\nvar slice = Array.prototype.slice;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Type guard that ensures that the value can be coerced to Object\n * to weed out host objects that do not derive from Object.\n * This function is used to check if we want to deep copy an object or not.\n * Note: In ES6 it is possible to modify an object's Symbol.toStringTag property, which will\n * change the value returned by `toString`. This is a rare edge case that is difficult to handle,\n * so it is not handled here.\n * @param  value The value to check\n * @return       If the value is coercible into an Object\n */\nfunction shouldDeepCopyObject(value) {\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\nfunction copyArray(array, inherited) {\n    return array.map(function (item) {\n        if (Array.isArray(item)) {\n            return copyArray(item, inherited);\n        }\n        return !shouldDeepCopyObject(item) ?\n            item :\n            _mixin({\n                deep: true,\n                inherited: inherited,\n                sources: [item],\n                target: {}\n            });\n    });\n}\nfunction _mixin(kwArgs) {\n    var deep = kwArgs.deep;\n    var inherited = kwArgs.inherited;\n    var target = kwArgs.target;\n    for (var _i = 0, _a = kwArgs.sources; _i < _a.length; _i++) {\n        var source = _a[_i];\n        if (source === null || source === undefined) {\n            continue;\n        }\n        for (var key in source) {\n            if (inherited || hasOwnProperty.call(source, key)) {\n                var value = source[key];\n                if (deep) {\n                    if (Array.isArray(value)) {\n                        value = copyArray(value, inherited);\n                    }\n                    else if (shouldDeepCopyObject(value)) {\n                        value = _mixin({\n                            deep: true,\n                            inherited: inherited,\n                            sources: [value],\n                            target: {}\n                        });\n                    }\n                }\n                target[key] = value;\n            }\n        }\n    }\n    return target;\n}\n/**\n * Copies the values of all enumerable own properties of one or more source objects to the target object.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable own properties will be copied to the target object\n * @return The modified target object\n */\nexports.assign = has_1.default('object-assign') ?\n    Object.assign :\n    function (target) {\n        var sources = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            sources[_i - 1] = arguments[_i];\n        }\n        return _mixin({\n            deep: false,\n            inherited: false,\n            sources: sources,\n            target: target\n        });\n    };\nfunction create(prototype) {\n    var mixins = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        mixins[_i - 1] = arguments[_i];\n    }\n    if (!mixins.length) {\n        throw new RangeError('lang.create requires at least one mixin object.');\n    }\n    var args = mixins.slice();\n    args.unshift(Object.create(prototype));\n    return exports.assign.apply(null, args);\n}\nexports.create = create;\nfunction deepAssign(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    return _mixin({\n        deep: true,\n        inherited: false,\n        sources: sources,\n        target: target\n    });\n}\nexports.deepAssign = deepAssign;\nfunction deepMixin(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    return _mixin({\n        deep: true,\n        inherited: true,\n        sources: sources,\n        target: target\n    });\n}\nexports.deepMixin = deepMixin;\n/**\n * Creates a new object using the provided source's prototype as the prototype for the new object, and then\n * deep copies the provided source's values into the new target.\n *\n * @param source The object to duplicate\n * @return The new object\n */\nfunction duplicate(source) {\n    var target = Object.create(Object.getPrototypeOf(source));\n    return deepMixin(target, source);\n}\nexports.duplicate = duplicate;\n/**\n * Determines whether two values are the same value.\n *\n * @param a First value to compare\n * @param b Second value to compare\n * @return true if the values are the same; false otherwise\n */\nfunction isIdentical(a, b) {\n    return a === b ||\n        /* both values are NaN */\n        (a !== a && b !== b);\n}\nexports.isIdentical = isIdentical;\n/**\n * Returns a function that binds a method to the specified object at runtime. This is similar to\n * `Function.prototype.bind`, but instead of a function it takes the name of a method on an object.\n * As a result, the function returned by `lateBind` will always call the function currently assigned to\n * the specified property on the object as of the moment the function it returns is called.\n *\n * @param instance The context object\n * @param method The name of the method on the context object to bind to itself\n * @param suppliedArgs An optional array of values to prepend to the `instance[method]` arguments list\n * @return The bound function\n */\nfunction lateBind(instance, method) {\n    var suppliedArgs = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        suppliedArgs[_i - 2] = arguments[_i];\n    }\n    return suppliedArgs.length ?\n        function () {\n            var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n            // TS7017\n            return instance[method].apply(instance, args);\n        } :\n        function () {\n            // TS7017\n            return instance[method].apply(instance, arguments);\n        };\n}\nexports.lateBind = lateBind;\nfunction mixin(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    return _mixin({\n        deep: false,\n        inherited: true,\n        sources: sources,\n        target: target\n    });\n}\nexports.mixin = mixin;\n/**\n * Returns a function which invokes the given function with the given arguments prepended to its argument list.\n * Like `Function.prototype.bind`, but does not alter execution context.\n *\n * @param targetFunction The function that needs to be bound\n * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list\n * @return The bound function\n */\nfunction partial(targetFunction) {\n    var suppliedArgs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        suppliedArgs[_i - 1] = arguments[_i];\n    }\n    return function () {\n        var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n        return targetFunction.apply(this, args);\n    };\n}\nexports.partial = partial;\n/**\n * Returns an object with a destroy method that, when called, calls the passed-in destructor.\n * This is intended to provide a unified interface for creating \"remove\" / \"destroy\" handlers for\n * event listeners, timers, etc.\n *\n * @param destructor A function that will be called when the handle's `destroy` method is invoked\n * @return The handle object\n */\nfunction createHandle(destructor) {\n    return {\n        destroy: function () {\n            this.destroy = function () { };\n            destructor.call(this);\n        }\n    };\n}\nexports.createHandle = createHandle;\n/**\n * Returns a single handle that can be used to destroy multiple handles simultaneously.\n *\n * @param handles An array of handles with `destroy` methods\n * @return The handle object\n */\nfunction createCompositeHandle() {\n    var handles = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        handles[_i] = arguments[_i];\n    }\n    return createHandle(function () {\n        for (var _i = 0, handles_1 = handles; _i < handles_1.length; _i++) {\n            var handle = handles_1[_i];\n            handle.destroy();\n        }\n    });\n}\nexports.createCompositeHandle = createCompositeHandle;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/lang.js\n// module id = 15\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./support/has\");\nvar util_1 = require(\"./support/util\");\nvar iterator_1 = require(\"./iterator\");\nvar number_1 = require(\"./number\");\n/**\n * Ensures a non-negative, non-infinite, safe integer.\n *\n * @param length The number to validate\n * @return A proper length\n */\nfunction toLength(length) {\n    length = Number(length);\n    if (isNaN(length)) {\n        return 0;\n    }\n    if (isFinite(length)) {\n        length = Math.floor(length);\n    }\n    // Ensure a non-negative, real, safe integer\n    return Math.min(Math.max(length, 0), number_1.MAX_SAFE_INTEGER);\n}\n/**\n * From ES6 7.1.4 ToInteger()\n *\n * @param value A value to convert\n * @return An integer\n */\nfunction toInteger(value) {\n    value = Number(value);\n    if (isNaN(value)) {\n        return 0;\n    }\n    if (value === 0 || !isFinite(value)) {\n        return value;\n    }\n    return (value > 0 ? 1 : -1) * Math.floor(Math.abs(value));\n}\n/**\n * Normalizes an offset against a given length, wrapping it if negative.\n *\n * @param value The original offset\n * @param length The total length to normalize against\n * @return If negative, provide a distance from the end (length); otherwise provide a distance from 0\n */\nfunction normalizeOffset(value, length) {\n    return value < 0 ? Math.max(length + value, 0) : Math.min(value, length);\n}\n/**\n * A namespace that contains the polyfilled functionality that is then exported below, depending on if\n * the functionality is required or not.\n */\nvar Shim;\n(function (Shim) {\n    function from(arrayLike, mapFunction, thisArg) {\n        if (arrayLike == null) {\n            throw new TypeError('from: requires an array-like object');\n        }\n        if (mapFunction && thisArg) {\n            mapFunction = mapFunction.bind(thisArg);\n        }\n        /* tslint:disable-next-line:variable-name */\n        var Constructor = this;\n        var length = toLength(arrayLike.length);\n        // Support extension\n        var array = (typeof Constructor === 'function') ? Object(new Constructor(length)) : new Array(length);\n        if (!iterator_1.isArrayLike(arrayLike) && !iterator_1.isIterable(arrayLike)) {\n            return array;\n        }\n        var i = 0;\n        iterator_1.forOf(arrayLike, function (value) {\n            array[i] = mapFunction ? mapFunction(value, i) : value;\n            i++;\n        });\n        if (arrayLike.length !== undefined) {\n            array.length = length;\n        }\n        return array;\n    }\n    Shim.from = from;\n    function of() {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        return Array.prototype.slice.call(items);\n    }\n    Shim.of = of;\n    function copyWithin(target, offset, start, end) {\n        if (target == null) {\n            throw new TypeError('copyWithin: target must be an array-like object');\n        }\n        var length = toLength(target.length);\n        offset = normalizeOffset(toInteger(offset), length);\n        start = normalizeOffset(toInteger(start), length);\n        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n        var count = Math.min(end - start, length - offset);\n        var direction = 1;\n        if (offset > start && offset < (start + count)) {\n            direction = -1;\n            start += count - 1;\n            offset += count - 1;\n        }\n        while (count > 0) {\n            if (start in target) {\n                target[offset] = target[start];\n            }\n            else {\n                delete target[offset];\n            }\n            offset += direction;\n            start += direction;\n            count--;\n        }\n        return target;\n    }\n    Shim.copyWithin = copyWithin;\n    function fill(target, value, start, end) {\n        var length = toLength(target.length);\n        var i = normalizeOffset(toInteger(start), length);\n        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n        while (i < end) {\n            target[i++] = value;\n        }\n        return target;\n    }\n    Shim.fill = fill;\n    function find(target, callback, thisArg) {\n        var index = findIndex(target, callback, thisArg);\n        return index !== -1 ? target[index] : undefined;\n    }\n    Shim.find = find;\n    function findIndex(target, callback, thisArg) {\n        var length = toLength(target.length);\n        if (!callback) {\n            throw new TypeError('find: second argument must be a function');\n        }\n        if (thisArg) {\n            callback = callback.bind(thisArg);\n        }\n        for (var i = 0; i < length; i++) {\n            if (callback(target[i], i, target)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    Shim.findIndex = findIndex;\n    function includes(target, searchElement, fromIndex) {\n        if (fromIndex === void 0) { fromIndex = 0; }\n        var len = toLength(target.length);\n        for (var i = fromIndex; i < len; ++i) {\n            var currentElement = target[i];\n            if (searchElement === currentElement ||\n                (searchElement !== searchElement && currentElement !== currentElement)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Shim.includes = includes;\n})(Shim = exports.Shim || (exports.Shim = {}));\nexports.from = has_1.default('es6-array-from')\n    ? Array.from\n    : Shim.from;\n/**\n * Creates a new array from the function parameters.\n *\n * @param arguments Any number of arguments for the array\n * @return An array from the given arguments\n */\nexports.of = has_1.default('es6-array-of')\n    ? Array.of\n    : Shim.of;\n/* ES6 Array instance methods */\n/**\n * Copies data internally within an array or array-like object.\n *\n * @param target The target array-like object\n * @param offset The index to start copying values to; if negative, it counts backwards from length\n * @param start The first (inclusive) index to copy; if negative, it counts backwards from length\n * @param end The last (exclusive) index to copy; if negative, it counts backwards from length\n * @return The target\n */\nexports.copyWithin = has_1.default('es6-array-copywithin')\n    ? util_1.wrapNative(Array.prototype.copyWithin)\n    : Shim.copyWithin;\n/**\n * Fills elements of an array-like object with the specified value.\n *\n * @param target The target to fill\n * @param value The value to fill each element of the target with\n * @param start The first index to fill\n * @param end The (exclusive) index at which to stop filling\n * @return The filled target\n */\nexports.fill = has_1.default('es6-array-fill')\n    ? util_1.wrapNative(Array.prototype.fill)\n    : Shim.fill;\n/**\n * Finds and returns the first instance matching the callback or undefined if one is not found.\n *\n * @param target An array-like object\n * @param callback A function returning if the current value matches a criteria\n * @param [thisArg] The execution context for the find function\n * @return The first element matching the callback, or undefined if one does not exist\n */\nexports.find = has_1.default('es6-array-find')\n    ? util_1.wrapNative(Array.prototype.find)\n    : Shim.find;\n/**\n * Performs a linear search and returns the first index whose value satisfies the passed callback,\n * or -1 if no values satisfy it.\n *\n * @param target An array-like object\n * @param callback A function returning true if the current value satisfies its criteria\n * @param [thisArg] The execution context for the find function\n * @return The first index whose value satisfies the passed callback, or -1 if no values satisfy it\n */\nexports.findIndex = has_1.default('es6-array-findindex')\n    ? util_1.wrapNative(Array.prototype.findIndex)\n    : Shim.findIndex;\n/* ES7 Array instance methods */\n/**\n * Determines whether an array includes a given value\n *\n * @param target the target array-like object\n * @param searchElement the item to search for\n * @param fromIndex the starting index to search from\n * @return `true` if the array includes the element, otherwise `false`\n */\nexports.includes = has_1.default('es7-array-includes')\n    ? util_1.wrapNative(Array.prototype.includes)\n    : Shim.includes;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/array.js\n// module id = 16\n// module chunks = 0","\"use strict\";\n/**\n * Helper function to generate a value property descriptor\n *\n * @param value        The value the property descriptor should be set to\n * @param enumerable   If the property should be enumberable, defaults to false\n * @param writable     If the property should be writable, defaults to true\n * @param configurable If the property should be configurable, defaults to true\n * @return             The property descriptor object\n */\nfunction getValueDescriptor(value, enumerable, writable, configurable) {\n    if (enumerable === void 0) { enumerable = false; }\n    if (writable === void 0) { writable = true; }\n    if (configurable === void 0) { configurable = true; }\n    return {\n        value: value,\n        enumerable: enumerable,\n        writable: writable,\n        configurable: configurable\n    };\n}\nexports.getValueDescriptor = getValueDescriptor;\n/**\n * A helper function which wraps a function where the first argument becomes the scope\n * of the call\n *\n * @param nativeFunction The source function to be wrapped\n */\nfunction wrapNative(nativeFunction) {\n    return function (target) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        return nativeFunction.apply(target, args);\n    };\n}\nexports.wrapNative = wrapNative;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/support/util.js\n// module id = 17\n// module chunks = 0","\"use strict\";\nvar string_1 = require(\"./string\");\nrequire(\"./Symbol\");\nvar staticDone = { done: true, value: undefined };\n/**\n * A class that provides \"shims\" an iterator interface on array like\n * objects.\n */\nvar ShimIterator = (function () {\n    function ShimIterator(list) {\n        this._nextIndex = -1;\n        if (isIterable(list)) {\n            this._nativeIterator = list[Symbol.iterator]();\n        }\n        else {\n            this._list = list;\n        }\n    }\n    ;\n    /**\n     * Return the next iteration result for the Iterator\n     */\n    ShimIterator.prototype.next = function () {\n        if (this._nativeIterator) {\n            return this._nativeIterator.next();\n        }\n        if (!this._list) {\n            return staticDone;\n        }\n        if (++this._nextIndex < this._list.length) {\n            return {\n                done: false,\n                value: this._list[this._nextIndex]\n            };\n        }\n        return staticDone;\n    };\n    ;\n    ShimIterator.prototype[Symbol.iterator] = function () {\n        return this;\n    };\n    return ShimIterator;\n}());\nexports.ShimIterator = ShimIterator;\n/**\n * A type guard for checking if something has an Iterable interface\n *\n * @param value The value to type guard against\n */\nfunction isIterable(value) {\n    return value && typeof value[Symbol.iterator] === 'function';\n}\nexports.isIterable = isIterable;\n/**\n * A type guard for checking if something is ArrayLike\n *\n * @param value The value to type guard against\n */\nfunction isArrayLike(value) {\n    return value && typeof value.length === 'number';\n}\nexports.isArrayLike = isArrayLike;\n/**\n * Returns the iterator for an object\n *\n * @param iterable The iterable object to return the iterator for\n */\nfunction get(iterable) {\n    if (isIterable(iterable)) {\n        return iterable[Symbol.iterator]();\n    }\n    else if (isArrayLike(iterable)) {\n        return new ShimIterator(iterable);\n    }\n}\nexports.get = get;\n/**\n * Shims the functionality of `for ... of` blocks\n *\n * @param iterable The object the provides an interator interface\n * @param callback The callback which will be called for each item of the iterable\n * @param thisArg Optional scope to pass the callback\n */\nfunction forOf(iterable, callback, thisArg) {\n    var broken = false;\n    function doBreak() {\n        broken = true;\n    }\n    /* We need to handle iteration of double byte strings properly */\n    if (!isIterable(iterable) && typeof iterable === 'string') {\n        var l = iterable.length;\n        for (var i = 0; i < l; ++i) {\n            var char = iterable[i];\n            if ((i + 1) < l) {\n                var code = char.charCodeAt(0);\n                if ((code >= string_1.HIGH_SURROGATE_MIN) && (code <= string_1.HIGH_SURROGATE_MAX)) {\n                    char += iterable[++i];\n                }\n            }\n            callback.call(thisArg, char, iterable, doBreak);\n            if (broken) {\n                return;\n            }\n        }\n    }\n    else {\n        var iterator = get(iterable);\n        if (iterator) {\n            var result = iterator.next();\n            while (!result.done) {\n                callback.call(thisArg, result.value, iterable, doBreak);\n                if (broken) {\n                    return;\n                }\n                result = iterator.next();\n            }\n        }\n    }\n}\nexports.forOf = forOf;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/iterator.js\n// module id = 18\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./support/has\");\nvar util_1 = require(\"./support/util\");\n/**\n * The minimum location of high surrogates\n */\nexports.HIGH_SURROGATE_MIN = 0xD800;\n/**\n * The maximum location of high surrogates\n */\nexports.HIGH_SURROGATE_MAX = 0xDBFF;\n/**\n * The minimum location of low surrogates\n */\nexports.LOW_SURROGATE_MIN = 0xDC00;\n/**\n * The maximum location of low surrogates\n */\nexports.LOW_SURROGATE_MAX = 0xDFFF;\nvar Shim;\n(function (Shim) {\n    /**\n     * Validates that text is defined, and normalizes position (based on the given default if the input is NaN).\n     * Used by startsWith, includes, and endsWith.\n     *\n     * @return Normalized position.\n     */\n    function normalizeSubstringArgs(name, text, search, position, isEnd) {\n        if (isEnd === void 0) { isEnd = false; }\n        if (text == null) {\n            throw new TypeError('string.' + name + ' requires a valid string to search against.');\n        }\n        var length = text.length;\n        position = position !== position ? (isEnd ? length : 0) : position;\n        return [text, String(search), Math.min(Math.max(position, 0), length)];\n    }\n    function raw(callSite) {\n        var substitutions = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            substitutions[_i - 1] = arguments[_i];\n        }\n        var rawStrings = callSite.raw;\n        var result = '';\n        var numSubstitutions = substitutions.length;\n        if (callSite == null || callSite.raw == null) {\n            throw new TypeError('string.raw requires a valid callSite object with a raw value');\n        }\n        for (var i = 0, length_1 = rawStrings.length; i < length_1; i++) {\n            result += rawStrings[i] + (i < numSubstitutions && i < length_1 - 1 ? substitutions[i] : '');\n        }\n        return result;\n    }\n    Shim.raw = raw;\n    function fromCodePoint() {\n        var codePoints = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            codePoints[_i] = arguments[_i];\n        }\n        // Adapted from https://github.com/mathiasbynens/String.fromCodePoint\n        var length = arguments.length;\n        if (!length) {\n            return '';\n        }\n        var fromCharCode = String.fromCharCode;\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var index = -1;\n        var result = '';\n        while (++index < length) {\n            var codePoint = Number(arguments[index]);\n            // Code points must be finite integers within the valid range\n            var isValid = isFinite(codePoint) && Math.floor(codePoint) === codePoint &&\n                codePoint >= 0 && codePoint <= 0x10FFFF;\n            if (!isValid) {\n                throw RangeError('string.fromCodePoint: Invalid code point ' + codePoint);\n            }\n            if (codePoint <= 0xFFFF) {\n                // BMP code point\n                codeUnits.push(codePoint);\n            }\n            else {\n                // Astral code point; split in surrogate halves\n                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                codePoint -= 0x10000;\n                var highSurrogate = (codePoint >> 10) + exports.HIGH_SURROGATE_MIN;\n                var lowSurrogate = (codePoint % 0x400) + exports.LOW_SURROGATE_MIN;\n                codeUnits.push(highSurrogate, lowSurrogate);\n            }\n            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                result += fromCharCode.apply(null, codeUnits);\n                codeUnits.length = 0;\n            }\n        }\n        return result;\n    }\n    Shim.fromCodePoint = fromCodePoint;\n    function codePointAt(text, position) {\n        if (position === void 0) { position = 0; }\n        // Adapted from https://github.com/mathiasbynens/String.prototype.codePointAt\n        if (text == null) {\n            throw new TypeError('string.codePointAt requries a valid string.');\n        }\n        var length = text.length;\n        if (position !== position) {\n            position = 0;\n        }\n        if (position < 0 || position >= length) {\n            return undefined;\n        }\n        // Get the first code unit\n        var first = text.charCodeAt(position);\n        if (first >= exports.HIGH_SURROGATE_MIN && first <= exports.HIGH_SURROGATE_MAX && length > position + 1) {\n            // Start of a surrogate pair (high surrogate and there is a next code unit); check for low surrogate\n            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            var second = text.charCodeAt(position + 1);\n            if (second >= exports.LOW_SURROGATE_MIN && second <= exports.LOW_SURROGATE_MAX) {\n                return (first - exports.HIGH_SURROGATE_MIN) * 0x400 + second - exports.LOW_SURROGATE_MIN + 0x10000;\n            }\n        }\n        return first;\n    }\n    Shim.codePointAt = codePointAt;\n    /* TODO: Missing normalize */\n    function repeat(text, count) {\n        if (count === void 0) { count = 0; }\n        // Adapted from https://github.com/mathiasbynens/String.prototype.repeat\n        if (text == null) {\n            throw new TypeError('string.repeat requires a valid string.');\n        }\n        if (count !== count) {\n            count = 0;\n        }\n        if (count < 0 || count === Infinity) {\n            throw new RangeError('string.repeat requires a non-negative finite count.');\n        }\n        var result = '';\n        while (count) {\n            if (count % 2) {\n                result += text;\n            }\n            if (count > 1) {\n                text += text;\n            }\n            count >>= 1;\n        }\n        return result;\n    }\n    Shim.repeat = repeat;\n    function startsWith(text, search, position) {\n        if (position === void 0) { position = 0; }\n        search = String(search);\n        _a = normalizeSubstringArgs('startsWith', text, search, position), text = _a[0], search = _a[1], position = _a[2];\n        var end = position + search.length;\n        if (end > text.length) {\n            return false;\n        }\n        return text.slice(position, end) === search;\n        var _a;\n    }\n    Shim.startsWith = startsWith;\n    function endsWith(text, search, endPosition) {\n        if (endPosition == null) {\n            endPosition = text.length;\n        }\n        _a = normalizeSubstringArgs('endsWith', text, search, endPosition, true), text = _a[0], search = _a[1], endPosition = _a[2];\n        var start = endPosition - search.length;\n        if (start < 0) {\n            return false;\n        }\n        return text.slice(start, endPosition) === search;\n        var _a;\n    }\n    Shim.endsWith = endsWith;\n    function includes(text, search, position) {\n        if (position === void 0) { position = 0; }\n        _a = normalizeSubstringArgs('includes', text, search, position), text = _a[0], search = _a[1], position = _a[2];\n        return text.indexOf(search, position) !== -1;\n        var _a;\n    }\n    Shim.includes = includes;\n    function padEnd(text, maxLength, fillString) {\n        if (fillString === void 0) { fillString = ' '; }\n        if (text === null || text === undefined) {\n            throw new TypeError('string.repeat requires a valid string.');\n        }\n        if (maxLength === Infinity) {\n            throw new RangeError('string.padEnd requires a non-negative finite count.');\n        }\n        if (maxLength === null || maxLength === undefined || maxLength < 0) {\n            maxLength = 0;\n        }\n        var strText = String(text);\n        var padding = maxLength - strText.length;\n        if (padding > 0) {\n            strText += repeat(fillString, Math.floor(padding / fillString.length)) + fillString.slice(0, padding % fillString.length);\n        }\n        return strText;\n    }\n    Shim.padEnd = padEnd;\n    function padStart(text, maxLength, fillString) {\n        if (fillString === void 0) { fillString = ' '; }\n        if (text === null || text === undefined) {\n            throw new TypeError('string.repeat requires a valid string.');\n        }\n        if (maxLength === Infinity) {\n            throw new RangeError('string.padStart requires a non-negative finite count.');\n        }\n        if (maxLength === null || maxLength === undefined || maxLength < 0) {\n            maxLength = 0;\n        }\n        var strText = String(text);\n        var padding = maxLength - strText.length;\n        if (padding > 0) {\n            strText = repeat(fillString, Math.floor(padding / fillString.length)) + fillString.slice(0, padding % fillString.length) + strText;\n        }\n        return strText;\n    }\n    Shim.padStart = padStart;\n    /* TODO: Provide an iterator for a string to mimic [Symbol.iterator]? */\n})(Shim = exports.Shim || (exports.Shim = {}));\n/**\n * A tag function for template strings to get the template string's raw string form.\n *\n * @param callSite Call site object (or a template string in TypeScript, which will transpile to one)\n * @param substitutions Values to substitute within the template string (TypeScript will generate these automatically)\n * @return String containing the raw template string with variables substituted\n *\n * @example\n * // Within TypeScript; logs 'The answer is:\\\\n42'\n * let answer = 42;\n * console.log(string.raw`The answer is:\\n${answer}`);\n *\n * @example\n * // The same example as above, but directly specifying a JavaScript object and substitution\n * console.log(string.raw({ raw: [ 'The answer is:\\\\n', '' ] }, 42));\n */\nexports.raw = has_1.default('es6-string-raw')\n    ? String.raw\n    : Shim.raw;\n/**\n * Returns the UTF-16 encoded code point value of a given position in a string.\n *\n * @param text The string containing the element whose code point is to be determined\n * @param position Position of an element within the string to retrieve the code point value from\n * @return A non-negative integer representing the UTF-16 encoded code point value\n */\nexports.fromCodePoint = has_1.default('es6-string-fromcodepoint')\n    ? String.fromCodePoint\n    : Shim.fromCodePoint;\n/**\n * Returns the UTF-16 encoded code point value of a given position in a string.\n *\n * @param text The string containing the element whose code point is to be determined\n * @param position Position of an element within the string to retrieve the code point value from\n * @return A non-negative integer representing the UTF-16 encoded code point value\n */\nexports.codePointAt = has_1.default('es6-string-codepointat')\n    ? util_1.wrapNative(String.prototype.codePointAt)\n    : Shim.codePointAt;\n/**\n * Returns a string containing the given string repeated the specified number of times.\n *\n * @param text The string to repeat\n * @param count The number of times to repeat the string\n * @return A string containing the input string repeated count times\n */\nexports.repeat = has_1.default('es6-string-repeat')\n    ? util_1.wrapNative(String.prototype.repeat)\n    : Shim.repeat;\n/**\n * Determines whether a string begins with the given substring (optionally starting from a given index).\n *\n * @param text The string to look for the search string within\n * @param search The string to search for\n * @param position The index to begin searching at\n * @return Boolean indicating if the search string was found at the beginning of the given string\n */\nexports.startsWith = has_1.default('es6-string-startswith')\n    ? util_1.wrapNative(String.prototype.startsWith)\n    : Shim.startsWith;\n/**\n * Determines whether a string ends with the given substring.\n *\n * @param text The string to look for the search string within\n * @param search The string to search for\n * @param endPosition The index searching should stop before (defaults to text.length)\n * @return Boolean indicating if the search string was found at the end of the given string\n */\nexports.endsWith = has_1.default('es6-string-endswith')\n    ? util_1.wrapNative(String.prototype.endsWith)\n    : Shim.endsWith;\n/**\n * Determines whether a string includes the given substring (optionally starting from a given index).\n *\n * @param text The string to look for the search string within\n * @param search The string to search for\n * @param position The index to begin searching at\n * @return Boolean indicating if the search string was found within the given string\n */\nexports.includes = has_1.default('es6-string-includes')\n    ? util_1.wrapNative(String.prototype.includes)\n    : Shim.includes;\n/**\n * Pads the beginning of a string with a fill string until the string is a certain length.\n *\n * @param text          The string to pad\n * @param maxLength     The desired length of the string\n * @param fillString    The string to be repeated (fully or partially) until text is the maximum length\n *\n * @return A string that is at least the maximum length specified, padded in the front if necessary.\n */\nexports.padStart = has_1.default('es6-string-padstart')\n    ? util_1.wrapNative(String.prototype.padStart)\n    : Shim.padStart;\n/**\n * Pads the end of a string with a fill string until the string is a certain length.\n *\n * @param text          The string to pad\n * @param maxLength     The desired length of the string\n * @param fillString    The string to be repeated (fully or partially) until text is the maximum length\n *\n * @return A string that is at least the maximum length specified, padded at the end if necessary.\n */\nexports.padEnd = has_1.default('es6-string-padend')\n    ? util_1.wrapNative(String.prototype.padEnd)\n    : Shim.padEnd;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/string.js\n// module id = 19\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./support/has\");\nvar global_1 = require(\"./support/global\");\nvar util_1 = require(\"./support/util\");\nvar Shim;\n(function (Shim) {\n    /* tslint:disable-next-line:variable-name */\n    var Symbol;\n    /* tslint:disable-next-line:variable-name */\n    var InternalSymbol;\n    var defineProperties = Object.defineProperties;\n    var defineProperty = Object.defineProperty;\n    var create = Object.create;\n    var objPrototype = Object.prototype;\n    var globalSymbols = {};\n    var getSymbolName = (function () {\n        var created = create(null);\n        return function (desc) {\n            var postfix = 0;\n            var name;\n            while (created[String(desc) + (postfix || '')]) {\n                ++postfix;\n            }\n            desc += String(postfix || '');\n            created[desc] = true;\n            name = '@@' + desc;\n            // FIXME: Temporary guard until the duplicate execution when testing can be\n            // pinned down.\n            if (!Object.getOwnPropertyDescriptor(objPrototype, name)) {\n                defineProperty(objPrototype, name, {\n                    set: function (value) {\n                        defineProperty(this, name, util_1.getValueDescriptor(value));\n                    }\n                });\n            }\n            return name;\n        };\n    }());\n    InternalSymbol = function Symbol(description) {\n        if (this instanceof InternalSymbol) {\n            throw new TypeError('TypeError: Symbol is not a constructor');\n        }\n        return Symbol(description);\n    };\n    Symbol = function Symbol(description) {\n        if (this instanceof Symbol) {\n            throw new TypeError('TypeError: Symbol is not a constructor');\n        }\n        var sym = Object.create(InternalSymbol.prototype);\n        description = (description === undefined ? '' : String(description));\n        return defineProperties(sym, {\n            __description__: util_1.getValueDescriptor(description),\n            __name__: util_1.getValueDescriptor(getSymbolName(description))\n        });\n    };\n    /**\n     * A custom guard function that determines if an object is a symbol or not\n     * @param  {any}       value The value to check to see if it is a symbol or not\n     * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)\n     */\n    function isSymbol(value) {\n        return (value && ((typeof value === 'symbol') || (value['@@toStringTag'] === 'Symbol'))) || false;\n    }\n    Shim.isSymbol = isSymbol;\n    /**\n     * Throws if the value is not a symbol, used internally within the Shim\n     * @param  {any}    value The value to check\n     * @return {symbol}       Returns the symbol or throws\n     */\n    function validateSymbol(value) {\n        if (!isSymbol(value)) {\n            throw new TypeError(value + ' is not a symbol');\n        }\n        return value;\n    }\n    /* Decorate the Symbol function with the appropriate properties */\n    defineProperty(Symbol, 'for', util_1.getValueDescriptor(function (key) {\n        if (globalSymbols[key]) {\n            return globalSymbols[key];\n        }\n        return (globalSymbols[key] = Symbol(String(key)));\n    }));\n    defineProperties(Symbol, {\n        keyFor: util_1.getValueDescriptor(function (sym) {\n            var key;\n            validateSymbol(sym);\n            for (key in globalSymbols) {\n                if (globalSymbols[key] === sym) {\n                    return key;\n                }\n            }\n        }),\n        hasInstance: util_1.getValueDescriptor(Symbol.for('hasInstance'), false, false),\n        isConcatSpreadable: util_1.getValueDescriptor(Symbol.for('isConcatSpreadable'), false, false),\n        iterator: util_1.getValueDescriptor(Symbol.for('iterator'), false, false),\n        match: util_1.getValueDescriptor(Symbol.for('match'), false, false),\n        observable: util_1.getValueDescriptor(Symbol.for('observable'), false, false),\n        replace: util_1.getValueDescriptor(Symbol.for('replace'), false, false),\n        search: util_1.getValueDescriptor(Symbol.for('search'), false, false),\n        species: util_1.getValueDescriptor(Symbol.for('species'), false, false),\n        split: util_1.getValueDescriptor(Symbol.for('split'), false, false),\n        toPrimitive: util_1.getValueDescriptor(Symbol.for('toPrimitive'), false, false),\n        toStringTag: util_1.getValueDescriptor(Symbol.for('toStringTag'), false, false),\n        unscopables: util_1.getValueDescriptor(Symbol.for('unscopables'), false, false)\n    });\n    /* Decorate the InternalSymbol object */\n    defineProperties(InternalSymbol.prototype, {\n        constructor: util_1.getValueDescriptor(Symbol),\n        toString: util_1.getValueDescriptor(function () { return this.__name__; }, false, false)\n    });\n    /* Decorate the Symbol.prototype */\n    defineProperties(Symbol.prototype, {\n        toString: util_1.getValueDescriptor(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),\n        valueOf: util_1.getValueDescriptor(function () { return validateSymbol(this); })\n    });\n    defineProperty(Symbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(function () { return validateSymbol(this); }));\n    defineProperty(Symbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor('Symbol', false, false, true));\n    defineProperty(InternalSymbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(Symbol.prototype[Symbol.toPrimitive], false, false, true));\n    defineProperty(InternalSymbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor(Symbol.prototype[Symbol.toStringTag], false, false, true));\n    /* tslint:disable-next-line:variable-name */\n    Shim.Exposed = Symbol;\n})(Shim = exports.Shim || (exports.Shim = {}));\n/* tslint:disable-next-line:variable-name */\nvar SymbolShim = has_1.default('es6-symbol') ? global_1.default.Symbol : global_1.default.Symbol = Shim.Exposed;\n/**\n * Fill any missing well known symbols if the native Symbol is missing them\n */\n['hasInstance', 'isConcatSpreadable', 'iterator', 'species', 'replace', 'search', 'split', 'match', 'toPrimitive',\n    'toStringTag', 'unscopables', 'observable'].forEach(function (wellKnown) {\n    if (!Symbol[wellKnown]) {\n        Object.defineProperty(Symbol, wellKnown, util_1.getValueDescriptor(Symbol.for(wellKnown), false, false));\n    }\n});\nexports.isSymbol = Shim.isSymbol;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SymbolShim;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/Symbol.js\n// module id = 20\n// module chunks = 0","\"use strict\";\nvar global_1 = require(\"./support/global\");\n/**\n * The smallest interval between two representable numbers.\n */\nexports.EPSILON = 1;\n/**\n * The maximum safe integer in JavaScript\n */\nexports.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n/**\n * The minimum safe integer in JavaScript\n */\nexports.MIN_SAFE_INTEGER = -exports.MAX_SAFE_INTEGER;\n/**\n * Determines whether the passed value is NaN without coersion.\n *\n * @param value The value to test\n * @return true if the value is NaN, false if it is not\n */\nfunction isNaN(value) {\n    return typeof value === 'number' && global_1.default.isNaN(value);\n}\nexports.isNaN = isNaN;\n/**\n * Determines whether the passed value is a finite number without coersion.\n *\n * @param value The value to test\n * @return true if the value is finite, false if it is not\n */\nfunction isFinite(value) {\n    return typeof value === 'number' && global_1.default.isFinite(value);\n}\nexports.isFinite = isFinite;\n/**\n * Determines whether the passed value is an integer.\n *\n * @param value The value to test\n * @return true if the value is an integer, false if it is not\n */\nfunction isInteger(value) {\n    return isFinite(value) && Math.floor(value) === value;\n}\nexports.isInteger = isInteger;\n/**\n * Determines whether the passed value is an integer that is 'safe,' meaning:\n *   1. it can be expressed as an IEEE-754 double precision number\n *   2. it has a one-to-one mapping to a mathematical integer, meaning its\n *      IEEE-754 representation cannot be the result of rounding any other\n *      integer to fit the IEEE-754 representation\n *\n * @param value The value to test\n * @return true if the value is an integer, false if it is not\n */\nfunction isSafeInteger(value) {\n    return isInteger(value) && Math.abs(value) <= exports.MAX_SAFE_INTEGER;\n}\nexports.isSafeInteger = isSafeInteger;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/number.js\n// module id = 21\n// module chunks = 0","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\"use strict\";\nvar decorators_1 = require(\"./support/decorators\");\nvar global_1 = require(\"./support/global\");\nvar iterator_1 = require(\"./iterator\");\nrequire(\"./Symbol\");\nvar Shim;\n(function (Shim) {\n    var DELETED = {};\n    function getUID() {\n        return Math.floor(Math.random() * 100000000);\n    }\n    var generateName = (function () {\n        var startId = Math.floor(Date.now() % 100000000);\n        return function generateName() {\n            return '__wm' + getUID() + (startId++ + '__');\n        };\n    })();\n    var WeakMap = (function () {\n        function WeakMap(iterable) {\n            var _this = this;\n            this[Symbol.toStringTag] = 'WeakMap';\n            Object.defineProperty(this, '_name', {\n                value: generateName()\n            });\n            this._frozenEntries = [];\n            if (iterable) {\n                iterator_1.forOf(iterable, function (_a) {\n                    var key = _a[0], value = _a[1];\n                    return _this.set(key, value);\n                });\n            }\n        }\n        WeakMap.prototype._getFrozenEntryIndex = function (key) {\n            for (var i = 0; i < this._frozenEntries.length; i++) {\n                if (this._frozenEntries[i].key === key) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n        WeakMap.prototype.delete = function (key) {\n            if (key === undefined || key === null) {\n                return false;\n            }\n            var entry = key[this._name];\n            if (entry && entry.key === key && entry.value !== DELETED) {\n                entry.value = DELETED;\n                return true;\n            }\n            var frozenIndex = this._getFrozenEntryIndex(key);\n            if (frozenIndex >= 0) {\n                this._frozenEntries.splice(frozenIndex, 1);\n                return true;\n            }\n            return false;\n        };\n        WeakMap.prototype.get = function (key) {\n            if (key === undefined || key === null) {\n                return undefined;\n            }\n            var entry = key[this._name];\n            if (entry && entry.key === key && entry.value !== DELETED) {\n                return entry.value;\n            }\n            var frozenIndex = this._getFrozenEntryIndex(key);\n            if (frozenIndex >= 0) {\n                return this._frozenEntries[frozenIndex].value;\n            }\n        };\n        WeakMap.prototype.has = function (key) {\n            if (key === undefined || key === null) {\n                return false;\n            }\n            var entry = key[this._name];\n            if (Boolean(entry && entry.key === key && entry.value !== DELETED)) {\n                return true;\n            }\n            var frozenIndex = this._getFrozenEntryIndex(key);\n            if (frozenIndex >= 0) {\n                return true;\n            }\n            return false;\n        };\n        WeakMap.prototype.set = function (key, value) {\n            if (!key || (typeof key !== 'object' && typeof key !== 'function')) {\n                throw new TypeError('Invalid value used as weak map key');\n            }\n            var entry = key[this._name];\n            if (!entry || entry.key !== key) {\n                entry = Object.create(null, {\n                    key: { value: key }\n                });\n                if (Object.isFrozen(key)) {\n                    this._frozenEntries.push(entry);\n                }\n                else {\n                    Object.defineProperty(key, this._name, {\n                        value: entry\n                    });\n                }\n            }\n            entry.value = value;\n            return this;\n        };\n        return WeakMap;\n    }());\n    Shim.WeakMap = WeakMap;\n})(Shim || (Shim = {}));\nvar WeakMap = (function () {\n    /* istanbul ignore next */\n    function WeakMap(iterable) {\n        /* istanbul ignore next */\n        this[Symbol.toStringTag] = 'WeakMap';\n    }\n    /* istanbul ignore next */\n    WeakMap.prototype.delete = function (key) { throw new Error(); };\n    /* istanbul ignore next */\n    WeakMap.prototype.get = function (key) { throw new Error(); };\n    /* istanbul ignore next */\n    WeakMap.prototype.has = function (key) { throw new Error(); };\n    /* istanbul ignore next */\n    WeakMap.prototype.set = function (key, value) { throw new Error(); };\n    return WeakMap;\n}());\nWeakMap = __decorate([\n    decorators_1.hasClass('es6-weakmap', global_1.default.WeakMap, Shim.WeakMap)\n], WeakMap);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = WeakMap;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/WeakMap.js\n// module id = 22\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./has\");\n/**\n * A class decorator that provides either a native class or a shimmed class based on a feature\n * test\n * @param feature The has feature to check\n * @param trueClass The class to use if feature test returns `true`\n * @param falseClass The class to use if the feature test returns `false` or is not defined\n */\nfunction hasClass(feature, trueClass, falseClass) {\n    return function (target) {\n        return has_1.default(feature) ? trueClass : falseClass;\n    };\n}\nexports.hasClass = hasClass;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/support/decorators.js\n// module id = 23\n// module chunks = 0","\"use strict\";\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\n/**\n * Types of advice\n */\nvar AdviceType;\n(function (AdviceType) {\n    AdviceType[AdviceType[\"Before\"] = 0] = \"Before\";\n    AdviceType[AdviceType[\"After\"] = 1] = \"After\";\n    AdviceType[AdviceType[\"Around\"] = 2] = \"Around\";\n})(AdviceType = exports.AdviceType || (exports.AdviceType = {}));\n/**\n * A weak map of dispatchers used to apply the advice\n */\nvar dispatchAdviceMap = new WeakMap_1.default();\n/**\n * Returns the dispatcher function for a given joinPoint (method/function)\n *\n * @param joinPoint The function that is to be advised\n */\nfunction getDispatcher(joinPoint) {\n    function dispatcher() {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var _a = dispatchAdviceMap.get(dispatcher), before = _a.before, after = _a.after, joinPoint = _a.joinPoint;\n        if (before) {\n            args = before.reduce(function (previousArgs, advice) {\n                var currentArgs = advice.apply(_this, previousArgs);\n                return currentArgs || previousArgs;\n            }, args);\n        }\n        var result = joinPoint.apply(this, args);\n        if (after) {\n            result = after.reduce(function (previousResult, advice) {\n                return advice.apply(_this, [previousResult].concat(args));\n            }, result);\n        }\n        return result;\n    }\n    /* We want to \"clone\" the advice that has been applied already, if this\n     * joinPoint is already advised */\n    if (dispatchAdviceMap.has(joinPoint)) {\n        var adviceMap = dispatchAdviceMap.get(joinPoint);\n        var before_1 = adviceMap.before, after_1 = adviceMap.after;\n        if (before_1) {\n            before_1 = before_1.slice(0);\n        }\n        if (after_1) {\n            after_1 = after_1.slice(0);\n        }\n        dispatchAdviceMap.set(dispatcher, {\n            joinPoint: adviceMap.joinPoint,\n            before: before_1,\n            after: after_1\n        });\n    }\n    else {\n        dispatchAdviceMap.set(dispatcher, { joinPoint: joinPoint });\n    }\n    return dispatcher;\n}\n/**\n * Advise a join point (function) with supplied advice\n *\n * @param joinPoint The function to be advised\n * @param type The type of advice to be applied\n * @param advice The advice to apply\n */\nfunction advise(joinPoint, type, advice) {\n    var dispatcher;\n    if (type === AdviceType.Around) {\n        dispatcher = getDispatcher(advice.apply(this, [joinPoint]));\n    }\n    else {\n        dispatcher = getDispatcher(joinPoint);\n        var adviceMap = dispatchAdviceMap.get(dispatcher);\n        if (type === AdviceType.Before) {\n            (adviceMap.before || (adviceMap.before = [])).unshift(advice);\n        }\n        else {\n            (adviceMap.after || (adviceMap.after = [])).push(advice);\n        }\n    }\n    return dispatcher;\n}\n/**\n * Apply advice *before* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The before advice\n */\nfunction before(joinPoint, advice) {\n    return advise(joinPoint, AdviceType.Before, advice);\n}\nexports.before = before;\n/**\n * Apply advice *after* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The after advice\n */\nfunction after(joinPoint, advice) {\n    return advise(joinPoint, AdviceType.After, advice);\n}\nexports.after = after;\n/**\n * Apply advice *around* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The around advice\n */\nfunction around(joinPoint, advice) {\n    return advise(joinPoint, AdviceType.Around, advice);\n}\nexports.around = around;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/compose/aspect.js\n// module id = 24\n// module chunks = 0","\"use strict\";\nvar lang_1 = require(\"./lang\");\n/**\n * Parses a query string, returning a ParamList object.\n */\nfunction parseQueryString(input) {\n    var query = {};\n    for (var _i = 0, _a = input.split('&'); _i < _a.length; _i++) {\n        var entry = _a[_i];\n        var indexOfFirstEquals = entry.indexOf('=');\n        var key = void 0;\n        var value = '';\n        if (indexOfFirstEquals >= 0) {\n            key = entry.slice(0, indexOfFirstEquals);\n            value = entry.slice(indexOfFirstEquals + 1);\n        }\n        else {\n            key = entry;\n        }\n        key = key ? decodeURIComponent(key) : '';\n        value = value ? decodeURIComponent(value) : '';\n        if (key in query) {\n            query[key].push(value);\n        }\n        else {\n            query[key] = [value];\n        }\n    }\n    return query;\n}\n/**\n * Represents a set of URL query search parameters.\n */\nvar UrlSearchParams = (function () {\n    /**\n     * Constructs a new UrlSearchParams from a query string, an object of parameters and values, or another\n     * UrlSearchParams.\n     */\n    function UrlSearchParams(input) {\n        var list;\n        if (input instanceof UrlSearchParams) {\n            // Copy the incoming UrlSearchParam's internal list\n            list = lang_1.duplicate(input._list);\n        }\n        else if (typeof input === 'object') {\n            // Copy the incoming object, assuming its property values are either arrays or strings\n            list = {};\n            for (var key in input) {\n                var value = input[key];\n                if (Array.isArray(value)) {\n                    list[key] = value.length ? value.slice() : [''];\n                }\n                else if (value == null) {\n                    list[key] = [''];\n                }\n                else {\n                    list[key] = [value];\n                }\n            }\n        }\n        else if (typeof input === 'string') {\n            // Parse the incoming string as a query string\n            list = parseQueryString(input);\n        }\n        else {\n            list = {};\n        }\n        Object.defineProperty(this, '_list', { value: list });\n    }\n    /**\n     * Appends a new value to the set of values for a key.\n     * @param key The key to add a value for\n     * @param value The value to add\n     */\n    UrlSearchParams.prototype.append = function (key, value) {\n        if (!this.has(key)) {\n            this.set(key, value);\n        }\n        else {\n            var values = this._list[key];\n            if (values) {\n                values.push(value);\n            }\n        }\n    };\n    /**\n     * Deletes all values for a key.\n     * @param key The key whose values are to be removed\n     */\n    UrlSearchParams.prototype.delete = function (key) {\n        // Set to undefined rather than deleting the key, for better consistency across browsers.\n        // If a deleted key is re-added, most browsers put it at the end of iteration order, but IE maintains\n        // its original position.  This approach maintains the original position everywhere.\n        this._list[key] = undefined;\n    };\n    /**\n     * Returns the first value associated with a key.\n     * @param key The key to return the first value for\n     * @return The first string value for the key\n     */\n    UrlSearchParams.prototype.get = function (key) {\n        if (!this.has(key)) {\n            return undefined;\n        }\n        var value = this._list[key];\n        return value ? value[0] : undefined;\n    };\n    /**\n     * Returns all the values associated with a key.\n     * @param key The key to return all values for\n     * @return An array of strings containing all values for the key\n     */\n    UrlSearchParams.prototype.getAll = function (key) {\n        if (!this.has(key)) {\n            return undefined;\n        }\n        return this._list[key];\n    };\n    /**\n     * Returns true if a key has been set to any value, false otherwise.\n     * @param key The key to test for existence\n     * @return A boolean indicating if the key has been set\n     */\n    UrlSearchParams.prototype.has = function (key) {\n        return Array.isArray(this._list[key]);\n    };\n    /**\n     * Returns an array of all keys which have been set.\n     * @return An array of strings containing all keys set in the UrlSearchParams instance\n     */\n    UrlSearchParams.prototype.keys = function () {\n        var keys = [];\n        for (var key in this._list) {\n            if (this.has(key)) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    };\n    /**\n     * Sets the value associated with a key.\n     * @param key The key to set the value of\n     */\n    UrlSearchParams.prototype.set = function (key, value) {\n        this._list[key] = [value];\n    };\n    /**\n     * Returns this object's data as an encoded query string.\n     * @return A string in application/x-www-form-urlencoded format containing all of the set keys/values\n     */\n    UrlSearchParams.prototype.toString = function () {\n        var query = [];\n        for (var key in this._list) {\n            if (!this.has(key)) {\n                continue;\n            }\n            var values = this._list[key];\n            if (values) {\n                var encodedKey = encodeURIComponent(key);\n                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n                    var value = values_1[_i];\n                    query.push(encodedKey + (value ? ('=' + encodeURIComponent(value)) : ''));\n                }\n            }\n        }\n        return query.join('&');\n    };\n    return UrlSearchParams;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = UrlSearchParams;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/UrlSearchParams.js\n// module id = 25\n// module chunks = 0","\"use strict\";\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar createEvented_1 = require(\"@dojo/compose/bases/createEvented\");\nvar Task_1 = require(\"@dojo/core/async/Task\");\nvar on_1 = require(\"@dojo/core/on\");\nvar UrlSearchParams_1 = require(\"@dojo/core/UrlSearchParams\");\nvar array_1 = require(\"@dojo/shim/array\");\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar path_1 = require(\"./lib/path\");\nvar parentMap = new WeakMap_1.default();\n/**\n * Whether the route has been appended to another route or router.\n */\nfunction hasBeenAppended(route) {\n    return parentMap.has(route) || route.parent !== undefined;\n}\nexports.hasBeenAppended = hasBeenAppended;\n/**\n * Finds the router whose route hierarchy the route has been appended to.\n *\n * Throws if the route was not appended to any router.\n */\nfunction findRouter(route) {\n    while (route.parent) {\n        route = route.parent;\n    }\n    var router = parentMap.get(route);\n    if (!router) {\n        throw new Error('Cannot generate link for route that is not in the hierarchy');\n    }\n    else {\n        return router;\n    }\n}\nexports.findRouter = findRouter;\nvar privateStateMap = new WeakMap_1.default();\n// istanbul ignore next\nvar noop = function () { };\nfunction createDeferral() {\n    // Use noop since TypeScript doesn't know we're assigning cancel and resume in the promise executor.\n    var cancel = noop;\n    var resume = noop;\n    var promise = new Promise_1.default(function (resolve, reject) {\n        cancel = reject;\n        // Wrap resolve to avoid resume being called with a thenable if type checking is not used.\n        resume = function () { return resolve(); };\n    });\n    return { cancel: cancel, promise: promise, resume: resume };\n}\nfunction reportError(router, context, path, error) {\n    router.emit({\n        context: context,\n        error: error,\n        path: path,\n        target: router,\n        type: 'error'\n    });\n}\nfunction catchRejection(router, context, path, thenable) {\n    if (thenable) {\n        Promise_1.default.resolve(thenable).catch(function (error) {\n            reportError(router, context, path, error);\n        });\n    }\n}\nvar createRouter = compose_1.default.mixin(createEvented_1.default, {\n    mixin: {\n        append: function (add) {\n            var _this = this;\n            var routes = privateStateMap.get(this).routes;\n            var append = function (route) {\n                if (hasBeenAppended(route)) {\n                    throw new Error('Cannot append route that has already been appended');\n                }\n                routes.push(route);\n                parentMap.set(route, _this);\n            };\n            if (Array.isArray(add)) {\n                for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {\n                    var route = add_1[_i];\n                    append(route);\n                }\n            }\n            else {\n                append(add);\n            }\n        },\n        dispatch: function (context, path) {\n            var _this = this;\n            var state = privateStateMap.get(this);\n            var dispatchFromStart = state.dispatchFromStart;\n            // Reset, any further calls can't have come from start(). This is necessary since the navstart listeners\n            // may call dispatch() themselves.\n            state.dispatchFromStart = false;\n            var canceled = false;\n            var cancel = function () {\n                canceled = true;\n            };\n            var deferrals = [];\n            this.emit({\n                cancel: cancel,\n                defer: function () {\n                    var _a = createDeferral(), cancel = _a.cancel, promise = _a.promise, resume = _a.resume;\n                    deferrals.push(promise);\n                    return { cancel: cancel, resume: resume };\n                },\n                path: path,\n                target: this,\n                type: 'navstart'\n            });\n            // Synchronous cancelation.\n            if (canceled) {\n                return Task_1.default.resolve({ success: false });\n            }\n            var _a = path_1.parse(path), searchParams = _a.searchParams, segments = _a.segments, trailingSlash = _a.trailingSlash;\n            return new Task_1.default(function (resolve, reject) {\n                // *Always* start dispatching in a future turn, even if there were no deferrals.\n                Promise_1.default.all(deferrals).then(function () {\n                    // The cancel() function used in the NavigationStartEvent is reused as the Task canceler.\n                    // Strictly speaking any navstart listener can cancel the dispatch asynchronously, as long as it\n                    // manages to do so before this turn.\n                    if (canceled) {\n                        return { success: false };\n                    }\n                    var fallback = state.fallback, routes = state.routes;\n                    var redirect;\n                    var dispatched = routes.some(function (route) {\n                        var result = route.select(context, segments, trailingSlash, searchParams);\n                        if (typeof result === 'string') {\n                            redirect = result;\n                            return true;\n                        }\n                        if (result.length === 0) {\n                            return false;\n                        }\n                        // Update the selected routes after selecting new routes, but before invoking the handlers.\n                        // This means the original value is available to guard() and params() functions, and the\n                        // new value when the newly selected routes are executed.\n                        //\n                        // Reset selected routes if not dispatched from start().\n                        state.currentSelection = dispatchFromStart ? result : [];\n                        for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {\n                            var _a = result_1[_i], handler = _a.handler, params = _a.params;\n                            catchRejection(_this, context, path, handler({ context: context, params: params }));\n                        }\n                        return true;\n                    });\n                    // Reset the selected routes if the dispatch was unsuccessful, or if a redirect was requested.\n                    if (!dispatched || redirect !== undefined) {\n                        state.currentSelection = [];\n                    }\n                    if (!dispatched && fallback) {\n                        catchRejection(_this, context, path, fallback({ context: context, params: {} }));\n                        return { success: false };\n                    }\n                    var result = { success: dispatched };\n                    if (redirect !== undefined) {\n                        result.redirect = redirect;\n                    }\n                    return result;\n                }, \n                // When deferrals are canceled their corresponding promise is rejected. Ensure the task resolves\n                // with `false` instead of being rejected too.\n                function () {\n                    return { success: false };\n                }).then(resolve, function (error) {\n                    reportError(_this, context, path, error);\n                    reject(error);\n                });\n            }, cancel);\n        },\n        link: function (route, params) {\n            if (params === void 0) { params = {}; }\n            var _a = privateStateMap.get(this), history = _a.history, roots = _a.routes, currentSelection = _a.currentSelection;\n            var hierarchy = [route];\n            for (var parent_1 = route.parent; parent_1 !== undefined; parent_1 = parent_1.parent) {\n                hierarchy.unshift(parent_1);\n            }\n            if (!array_1.includes(roots, hierarchy[0])) {\n                throw new Error('Cannot generate link for route that is not in the hierarchy');\n            }\n            var addLeadingSlash = hierarchy[0].path.leadingSlash;\n            var addTrailingSlash = false;\n            var segments = [];\n            var searchParams = new UrlSearchParams_1.default();\n            hierarchy\n                .map(function (route, index) {\n                var path = route.path;\n                var currentPathValues;\n                var currentSearchParams;\n                var selection = currentSelection[index];\n                if (selection && selection.route === route) {\n                    currentPathValues = selection.rawPathValues;\n                    currentSearchParams = selection.rawSearchParams;\n                }\n                return { currentPathValues: currentPathValues, currentSearchParams: currentSearchParams, path: path };\n            })\n                .forEach(function (_a) {\n                var currentPathValues = _a.currentPathValues, currentSearchParams = _a.currentSearchParams, path = _a.path;\n                var expectedSegments = path.expectedSegments, searchParameters = path.searchParameters, trailingSlash = path.trailingSlash;\n                addTrailingSlash = trailingSlash;\n                var namedOffset = 0;\n                for (var _i = 0, expectedSegments_1 = expectedSegments; _i < expectedSegments_1.length; _i++) {\n                    var segment = expectedSegments_1[_i];\n                    if (path_1.isNamedSegment(segment)) {\n                        var value = params[segment.name];\n                        if (typeof value === 'string') {\n                            segments.push(value);\n                        }\n                        else if (Array.isArray(value)) {\n                            if (value.length === 1) {\n                                segments.push(value[0]);\n                            }\n                            else {\n                                throw new TypeError(\"Cannot generate link, multiple values for parameter '\" + segment.name + \"'\");\n                            }\n                        }\n                        else if (currentPathValues) {\n                            segments.push(currentPathValues[namedOffset]);\n                        }\n                        else {\n                            throw new Error(\"Cannot generate link, missing parameter '\" + segment.name + \"'\");\n                        }\n                        namedOffset++;\n                    }\n                    else {\n                        segments.push(segment.literal);\n                    }\n                }\n                for (var _b = 0, searchParameters_1 = searchParameters; _b < searchParameters_1.length; _b++) {\n                    var key = searchParameters_1[_b];\n                    // Don't repeat the search parameter if a previous route in the hierarchy has already appended\n                    // it.\n                    if (searchParams.has(key)) {\n                        continue;\n                    }\n                    var value = params[key];\n                    if (typeof value === 'string') {\n                        searchParams.append(key, value);\n                    }\n                    else if (Array.isArray(value)) {\n                        for (var _c = 0, value_1 = value; _c < value_1.length; _c++) {\n                            var item = value_1[_c];\n                            searchParams.append(key, item);\n                        }\n                    }\n                    else if (currentSearchParams) {\n                        for (var _d = 0, _e = currentSearchParams[key]; _d < _e.length; _d++) {\n                            var item = _e[_d];\n                            searchParams.append(key, item);\n                        }\n                    }\n                    else {\n                        throw new Error(\"Cannot generate link, missing search parameter '\" + key + \"'\");\n                    }\n                }\n            });\n            var pathname = segments.join('/');\n            if (addLeadingSlash) {\n                pathname = '/' + pathname;\n            }\n            if (addTrailingSlash) {\n                pathname += '/';\n            }\n            if (history) {\n                pathname = history.prefix(pathname);\n            }\n            var search = searchParams.toString();\n            var path = search ? pathname + \"?\" + search : pathname;\n            return path;\n        },\n        replacePath: function (path) {\n            var history = privateStateMap.get(this).history;\n            if (!history) {\n                throw new Error('Cannot replace path, router was created without a history manager');\n            }\n            history.replace(path);\n        },\n        setPath: function (path) {\n            var history = privateStateMap.get(this).history;\n            if (!history) {\n                throw new Error('Cannot set path, router was created without a history manager');\n            }\n            history.set(path);\n        },\n        start: function (_a) {\n            var _this = this;\n            var dispatchCurrent = (_a === void 0 ? { dispatchCurrent: true } : _a).dispatchCurrent;\n            var state = privateStateMap.get(this);\n            if (state.started) {\n                throw new Error('start can only be called once');\n            }\n            state.started = true;\n            var contextFactory = state.contextFactory, history = state.history;\n            if (!history) {\n                return {\n                    pause: function () { },\n                    resume: function () { },\n                    destroy: function () { }\n                };\n            }\n            var lastDispatch;\n            var redirectCount = 0;\n            var redirecting = false;\n            var dispatch = function (path) {\n                if (lastDispatch) {\n                    lastDispatch.cancel();\n                }\n                // Reset redirect count if the dispatch was triggered by a non-redirect history change. This allows\n                // a route's exec / fallback / index handler to change the history, setting off a new flurry of\n                // redirects, without being encumbered by the number of redirects that led to that route being selected.\n                if (!redirecting) {\n                    redirectCount = 0;\n                }\n                // Signal to dispatch() that it was called from here.\n                state.dispatchFromStart = true;\n                var context = contextFactory();\n                lastDispatch = _this.dispatch(context, path).then(function (dispatchResult) {\n                    var _a = dispatchResult || { success: false }, success = _a.success, _b = _a.redirect, redirect = _b === void 0 ? undefined : _b;\n                    if (success && redirect !== undefined) {\n                        redirectCount++;\n                        if (redirectCount > 20) {\n                            var error = new Error('More than 20 redirects, giving up');\n                            reportError(_this, context, path, error);\n                            throw error;\n                        }\n                        redirecting = true;\n                        // The history manager MUST emit the change event synchronously.\n                        history.replace(redirect);\n                        redirecting = false;\n                    }\n                    return dispatchResult;\n                });\n            };\n            var listener = on_1.pausable(history, 'change', function (event) {\n                dispatch(event.value);\n            });\n            this.own(listener);\n            if (dispatchCurrent) {\n                dispatch(history.current);\n            }\n            return listener;\n        }\n    },\n    initialize: function (instance, _a) {\n        var _b = _a === void 0 ? {} : _a, context = _b.context, fallback = _b.fallback, history = _b.history;\n        var contextFactory;\n        if (typeof context === 'function') {\n            contextFactory = context;\n        }\n        else if (typeof context === 'undefined') {\n            contextFactory = function () {\n                return {};\n            };\n        }\n        else {\n            // Assign to a constant since the context variable may be changed after the function is defined,\n            // which would violate its typing.\n            var sharedContext_1 = context;\n            contextFactory = function () { return sharedContext_1; };\n        }\n        if (history) {\n            instance.own(history);\n        }\n        privateStateMap.set(instance, {\n            contextFactory: contextFactory,\n            currentSelection: [],\n            dispatchFromStart: false,\n            fallback: fallback,\n            history: history,\n            routes: []\n        });\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createRouter;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/routing/createRouter.js\n// module id = 26\n// module chunks = 0","\"use strict\";\nvar aspect_1 = require(\"@dojo/core/aspect\");\nvar Map_1 = require(\"@dojo/shim/Map\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar createDestroyable_1 = require(\"./createDestroyable\");\n/**\n * A weak map that contains a map of the listeners for an `Evented`\n */\nvar listenersMap = new WeakMap_1.default();\n/**\n * A guard which determines if the value is `Actionable`\n *\n * @param value The value to guard against\n */\nfunction isActionable(value) {\n    return Boolean(value && typeof value.do === 'function');\n}\n/**\n * An internal function that always returns an EventedCallback\n *\n * @param listener Either a `EventedCallback` or an `Actionable`\n */\nfunction resolveListener(listener) {\n    return isActionable(listener) ? function (event) { return listener.do({ event: event }); } : listener;\n}\nexports.resolveListener = resolveListener;\n/**\n * Internal function to convert an array of handles to a single handle\n *\n * @param handles The array of handles to convert into a signle handle\n * @return The single handle\n */\nfunction handlesArraytoHandle(handles) {\n    return {\n        destroy: function () {\n            handles.forEach(function (handle) { return handle.destroy(); });\n        }\n    };\n}\n/**\n * Creates a new instance of an `Evented`\n */\nvar createEvented = createDestroyable_1.default\n    .mixin({\n    className: 'Evented',\n    mixin: {\n        emit: function (event) {\n            var method = listenersMap.get(this).get(event.type);\n            if (method) {\n                method.call(this, event);\n            }\n        },\n        on: function () {\n            var _this = this;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var listenerMap = listenersMap.get(this);\n            if (args.length === 2) {\n                var _a = args, type_1 = _a[0], listeners = _a[1];\n                if (Array.isArray(listeners)) {\n                    var handles = listeners.map(function (listener) { return aspect_1.on(listenerMap, type_1, resolveListener(listener)); });\n                    return handlesArraytoHandle(handles);\n                }\n                else {\n                    return aspect_1.on(listenerMap, type_1, resolveListener(listeners));\n                }\n            }\n            else if (args.length === 1) {\n                var listenerMapArg_1 = args[0];\n                var handles = Object.keys(listenerMapArg_1).map(function (type) { return _this.on(type, listenerMapArg_1[type]); });\n                return handlesArraytoHandle(handles);\n            }\n            else {\n                throw new TypeError('Invalid arguments');\n            }\n        }\n    },\n    initialize: function (instance, options) {\n        listenersMap.set(instance, new Map_1.default());\n        if (options && options.listeners) {\n            instance.own(instance.on(options.listeners));\n        }\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createEvented;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/compose/bases/createEvented.js\n// module id = 27\n// module chunks = 0","\"use strict\";\nvar lang_1 = require(\"./lang\");\n/**\n * An internal type guard that determines if an value is MapLike or not\n *\n * @param value The value to guard against\n */\nfunction isMapLike(value) {\n    return value && typeof value.get === 'function' && typeof value.set === 'function';\n}\n/**\n * A UID for tracking advice ordering\n */\nvar nextId = 0;\n/**\n * Internal function that advises a join point\n *\n * @param dispatcher The current advice dispatcher\n * @param type The type of before or after advice to apply\n * @param advice The advice to apply\n * @param receiveArguments If true, the advice will receive the arguments passed to the join point\n * @return The handle that will remove the advice\n */\nfunction advise(dispatcher, type, advice, receiveArguments) {\n    var previous = dispatcher && dispatcher[type];\n    var advised = {\n        id: nextId++,\n        advice: advice,\n        receiveArguments: receiveArguments\n    };\n    if (previous) {\n        if (type === 'after') {\n            // add the listener to the end of the list\n            // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n            while (previous.next && (previous = previous.next)) { }\n            previous.next = advised;\n            advised.previous = previous;\n        }\n        else {\n            // add to the beginning\n            if (dispatcher) {\n                dispatcher.before = advised;\n            }\n            advised.next = previous;\n            previous.previous = advised;\n        }\n    }\n    else {\n        dispatcher && (dispatcher[type] = advised);\n    }\n    advice = previous = undefined;\n    return lang_1.createHandle(function () {\n        var _a = (advised || {}), _b = _a.previous, previous = _b === void 0 ? undefined : _b, _c = _a.next, next = _c === void 0 ? undefined : _c;\n        if (dispatcher && !previous && !next) {\n            dispatcher[type] = undefined;\n        }\n        else {\n            if (previous) {\n                previous.next = next;\n            }\n            else {\n                dispatcher && (dispatcher[type] = next);\n            }\n            if (next) {\n                next.previous = previous;\n            }\n        }\n        if (advised) {\n            delete advised.advice;\n        }\n        dispatcher = advised = undefined;\n    });\n}\n/**\n * An internal function that resolves or creates the dispatcher for a given join point\n *\n * @param target The target object or map\n * @param methodName The name of the method that the dispatcher should be resolved for\n * @return The dispatcher\n */\nfunction getDispatcher(target, methodName) {\n    var existing = isMapLike(target) ? target.get(methodName) : target && target[methodName];\n    var dispatcher;\n    if (!existing || existing.target !== target) {\n        /* There is no existing dispatcher, therefore we will create one */\n        dispatcher = function () {\n            var executionId = nextId;\n            var args = arguments;\n            var results;\n            var before = dispatcher.before;\n            while (before) {\n                if (before.advice) {\n                    args = before.advice.apply(this, args) || args;\n                }\n                before = before.next;\n            }\n            if (dispatcher.around && dispatcher.around.advice) {\n                results = dispatcher.around.advice(this, args);\n            }\n            var after = dispatcher.after;\n            while (after && after.id < executionId) {\n                if (after.advice) {\n                    if (after.receiveArguments) {\n                        var newResults = after.advice.apply(this, args);\n                        results = newResults === undefined ? results : newResults;\n                    }\n                    else {\n                        results = after.advice.call(this, results, args);\n                    }\n                }\n                after = after.next;\n            }\n            return results;\n        };\n        if (isMapLike(target)) {\n            target.set(methodName, dispatcher);\n        }\n        else {\n            target && (target[methodName] = dispatcher);\n        }\n        if (existing) {\n            dispatcher.around = {\n                advice: function (target, args) {\n                    return existing.apply(target, args);\n                }\n            };\n        }\n        dispatcher.target = target;\n    }\n    else {\n        dispatcher = existing;\n    }\n    return dispatcher;\n}\n/**\n * Attaches \"after\" advice to be executed after the original method.\n * The advising function will receive the original method's return value and arguments object.\n * The value it returns will be returned from the method when it is called (even if the return value is undefined).\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original method's return value and arguments object\n * @return A handle which will remove the aspect when destroy is called\n */\nfunction after(target, methodName, advice) {\n    return advise(getDispatcher(target, methodName), 'after', advice);\n}\nexports.after = after;\n/**\n * Attaches \"around\" advice around the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original function\n * @return A handle which will remove the aspect when destroy is called\n */\nfunction around(target, methodName, advice) {\n    var dispatcher = getDispatcher(target, methodName);\n    var previous = dispatcher.around;\n    var advised;\n    if (advice) {\n        advised = advice(function () {\n            if (previous && previous.advice) {\n                return previous.advice(this, arguments);\n            }\n        });\n    }\n    dispatcher.around = {\n        advice: function (target, args) {\n            return advised ? advised.apply(target, args) : previous && previous.advice && previous.advice(target, args);\n        }\n    };\n    return lang_1.createHandle(function () {\n        advised = dispatcher = undefined;\n    });\n}\nexports.around = around;\n/**\n * Attaches \"before\" advice to be executed before the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n * @return A handle which will remove the aspect when destroy is called\n */\nfunction before(target, methodName, advice) {\n    return advise(getDispatcher(target, methodName), 'before', advice);\n}\nexports.before = before;\n/**\n * Attaches advice to be executed after the original method.\n * The advising function will receive the same arguments as the original method.\n * The value it returns will be returned from the method when it is called *unless* its return value is undefined.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original method\n * @return A handle which will remove the aspect when destroy is called\n */\nfunction on(target, methodName, advice) {\n    return advise(getDispatcher(target, methodName), 'after', advice, true);\n}\nexports.on = on;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/aspect.js\n// module id = 28\n// module chunks = 0","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\"use strict\";\nvar decorators_1 = require(\"./support/decorators\");\nvar global_1 = require(\"./support/global\");\nvar iterator_1 = require(\"./iterator\");\nvar object_1 = require(\"./object\");\nrequire(\"./Symbol\");\nvar Shim;\n(function (Shim) {\n    /**\n     * An implementation analogous to the Map specification in ES2015.\n     */\n    var Map = (function () {\n        /**\n         * Creates a new Map\n         *\n         * @constructor\n         *\n         * @param iterator\n         * Array or iterator containing two-item tuples used to initially populate the map.\n         * The first item in each tuple corresponds to the key of the map entry.\n         * The second item corresponds to the value of the map entry.\n         */\n        function Map(iterable) {\n            var _this = this;\n            this._keys = [];\n            this._values = [];\n            this[Symbol.toStringTag] = 'Map';\n            if (iterable) {\n                iterator_1.forOf(iterable, function (value) {\n                    _this.set(value[0], value[1]);\n                });\n            }\n        }\n        /**\n         * An alternative to Array.prototype.indexOf using Object.is\n         * to check for equality. See http://mzl.la/1zuKO2V\n         */\n        Map.prototype._indexOfKey = function (keys, key) {\n            for (var i = 0, length_1 = keys.length; i < length_1; i++) {\n                if (object_1.is(keys[i], key)) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n        Object.defineProperty(Map.prototype, \"size\", {\n            /**\n             * Returns the number of key / value pairs in the Map.\n             *\n             * @return the number of key / value pairs in the Map\n             */\n            get: function () {\n                return this._keys.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Deletes all keys and their associated values.\n         */\n        Map.prototype.clear = function () {\n            this._keys.length = this._values.length = 0;\n        };\n        /**\n         * Deletes a given key and its associated value.\n         *\n         * @param key The key to delete\n         * @return true if the key exists, false if it does not\n         */\n        Map.prototype.delete = function (key) {\n            var index = this._indexOfKey(this._keys, key);\n            if (index < 0) {\n                return false;\n            }\n            this._keys.splice(index, 1);\n            this._values.splice(index, 1);\n            return true;\n        };\n        /**\n         * Returns an iterator that yields each key/value pair as an array.\n         *\n         * @return An iterator for each key/value pair in the instance.\n         */\n        Map.prototype.entries = function () {\n            var _this = this;\n            var values = this._keys.map(function (key, i) {\n                return [key, _this._values[i]];\n            });\n            return new iterator_1.ShimIterator(values);\n        };\n        /**\n         * Executes a given function for each map entry. The function\n         * is invoked with three arguments: the element value, the\n         * element key, and the associated Map instance.\n         *\n         * @param callback The function to execute for each map entry,\n         * @param context The value to use for `this` for each execution of the calback\n         */\n        Map.prototype.forEach = function (callback, context) {\n            var keys = this._keys;\n            var values = this._values;\n            for (var i = 0, length_2 = keys.length; i < length_2; i++) {\n                callback.call(context, values[i], keys[i], this);\n            }\n        };\n        /**\n         * Returns the value associated with a given key.\n         *\n         * @param key The key to look up\n         * @return The value if one exists or undefined\n         */\n        Map.prototype.get = function (key) {\n            var index = this._indexOfKey(this._keys, key);\n            return index < 0 ? undefined : this._values[index];\n        };\n        /**\n         * Checks for the presence of a given key.\n         *\n         * @param key The key to check for\n         * @return true if the key exists, false if it does not\n         */\n        Map.prototype.has = function (key) {\n            return this._indexOfKey(this._keys, key) > -1;\n        };\n        /**\n         * Returns an iterator that yields each key in the map.\n         *\n         * @return An iterator containing the instance's keys.\n         */\n        Map.prototype.keys = function () {\n            return new iterator_1.ShimIterator(this._keys);\n        };\n        /**\n         * Sets the value associated with a given key.\n         *\n         * @param key The key to define a value to\n         * @param value The value to assign\n         * @return The Map instance\n         */\n        Map.prototype.set = function (key, value) {\n            var index = this._indexOfKey(this._keys, key);\n            index = index < 0 ? this._keys.length : index;\n            this._keys[index] = key;\n            this._values[index] = value;\n            return this;\n        };\n        /**\n         * Returns an iterator that yields each value in the map.\n         *\n         * @return An iterator containing the instance's values.\n         */\n        Map.prototype.values = function () {\n            return new iterator_1.ShimIterator(this._values);\n        };\n        Map.prototype[Symbol.iterator] = function () {\n            return this.entries();\n        };\n        return Map;\n    }());\n    Shim.Map = Map;\n})(Shim = exports.Shim || (exports.Shim = {}));\nvar Map = (function () {\n    /* istanbul ignore next */\n    function Map(iterable) {\n        /* istanbul ignore next */\n        this[Symbol.toStringTag] = 'Map';\n    }\n    ;\n    Object.defineProperty(Map.prototype, \"size\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error('Abstract method'); },\n        enumerable: true,\n        configurable: true\n    });\n    ;\n    /* istanbul ignore next */\n    Map.prototype.clear = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.delete = function (key) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.entries = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.forEach = function (callback, context) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.get = function (key) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.has = function (key) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.keys = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.set = function (key, value) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype.values = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Map.prototype[Symbol.iterator] = function () { throw new Error('Abstract method'); };\n    ;\n    return Map;\n}());\nMap = __decorate([\n    decorators_1.hasClass('es6-map', global_1.default.Map, Shim.Map)\n], Map);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Map;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/Map.js\n// module id = 29\n// module chunks = 0","\"use strict\";\nvar has_1 = require(\"./support/has\");\nvar Symbol_1 = require(\"./Symbol\");\nvar Shim;\n(function (Shim) {\n    function is(value1, value2) {\n        if (value1 === value2) {\n            return value1 !== 0 || 1 / value1 === 1 / value2; // -0\n        }\n        return value1 !== value1 && value2 !== value2; // NaN\n    }\n    Shim.is = is;\n    function getOwnPropertySymbols(o) {\n        return Object.getOwnPropertyNames(o).filter(function (key) { return Boolean(key.match(/^@@.+/)); })\n            .map(function (key) { return Symbol.for(key.substring(2)); });\n    }\n    Shim.getOwnPropertySymbols = getOwnPropertySymbols;\n    function getOwnPropertyNames(o) {\n        return Object.getOwnPropertyNames(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });\n    }\n    Shim.getOwnPropertyNames = getOwnPropertyNames;\n    function symbolAwareKeys(o) {\n        return Object.keys(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });\n    }\n    Shim.symbolAwareKeys = symbolAwareKeys;\n    function getOwnPropertyDescriptor(o, prop) {\n        if (Symbol_1.isSymbol(prop)) {\n            return Object.getOwnPropertyDescriptor(o, prop);\n        }\n        else {\n            return Object.getOwnPropertyDescriptor(o, prop);\n        }\n    }\n    Shim.getOwnPropertyDescriptor = getOwnPropertyDescriptor;\n    function values(o) {\n        return exports.keys(o).map(function (key) { return o[key]; });\n    }\n    Shim.values = values;\n    function entries(o) {\n        return exports.keys(o).map(function (key) { return [key, o[key]]; });\n    }\n    Shim.entries = entries;\n})(Shim || (Shim = {}));\n/**\n * Determines whether two values are the same value.\n *\n * @param value1 The first value to compare\n * @param value2 The second value to compare\n * @return true if the values are the same; false otherwise\n */\nexports.is = 'is' in Object\n    ? Object.is\n    : Shim.is;\n/**\n * Detect if there is native support for Symbol properties in Object\n */\nvar hasGetOwnPropertySymbols = has_1.default('es6-symbol') && 'getOwnPropertySymbols' in Object;\n/**\n * Returns an array of own properties who key is a symbol\n *\n * @param o The object to return the properties for\n */\nexports.getOwnPropertySymbols = hasGetOwnPropertySymbols\n    ? Object.getOwnPropertySymbols\n    : Shim.getOwnPropertySymbols;\n/**\n * Returns an array of own properties who key is a string\n *\n * @param o The object to return the properties for\n */\n/* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n * when there is no support for symbols */\nexports.getOwnPropertyNames = hasGetOwnPropertySymbols\n    ? Object.getOwnPropertyNames\n    : Shim.getOwnPropertyNames;\n/**\n * Returns the names of the enumerable properties and methods of an object.\n * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n */\n/* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n * when there is no support for symbols */\nexports.keys = hasGetOwnPropertySymbols\n    ? Object.keys\n    : Shim.symbolAwareKeys;\n/**\n * Returns the values of the enumerable properties and methods of an object.\n * @param o Object that contains the properties and methods.\n */\nexports.values = 'values' in Object\n    ? Object.values\n    : Shim.values;\n/**\n * Returns the keys and values of the enumerable properties and methods of an object. Each entry will be returned as an\n * array holding the [key, value].\n * @param o Object that contains the properties and methods.\n */\nexports.entries = 'entries' in Object\n    ? Object.entries\n    : Shim.entries;\nexports.getOwnPropertyDescriptor = hasGetOwnPropertySymbols\n    ? Object.getOwnPropertyDescriptor\n    : Shim.getOwnPropertyDescriptor;\nfunction getOwnPropertyDescriptorsWrapper(o) {\n    var descriptors = exports.getOwnPropertyNames(o).reduce(function (descriptors, key) {\n        descriptors[key] = exports.getOwnPropertyDescriptor(o, key);\n        return descriptors;\n    }, {});\n    exports.getOwnPropertySymbols(o).forEach(function (sym) {\n        descriptors[sym] = exports.getOwnPropertyDescriptor(o, sym);\n    });\n    return descriptors;\n}\n/* Return descriptors for enumerable and non enumerable properties on an object */\nexports.getOwnPropertyDescriptors = 'getOwnPropertyDescriptors' in Object\n    ? Object.getOwnPropertyDescriptors\n    : getOwnPropertyDescriptorsWrapper;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/object.js\n// module id = 30\n// module chunks = 0","\"use strict\";\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar compose_1 = require(\"../compose\");\n/**\n * A reference to a function that always returns a promise which resolves to false\n */\nfunction noop() {\n    return Promise_1.default.resolve(false);\n}\n/**\n * A reference to a function that throws, used to replace the `own()` method after\n * destruction\n */\nfunction destroyed() {\n    throw new Error('Call made to destroyed method');\n}\n/**\n * A weak map for *owning* handles on instances\n */\nvar handlesWeakMap = new WeakMap_1.default();\n/**\n * A type guard that determines if the value is a Destroyable\n *\n * @param value The value to guard for\n */\nfunction isDestroyable(value) {\n    return Boolean(value && 'destroy' in value && typeof value.destroy === 'function');\n}\nexports.isDestroyable = isDestroyable;\n/**\n * A mixin which adds the concepts of being able to *destroy* handles which the instance\n * *owns*\n */\nvar createDestroyable = compose_1.default('Destroyable', {\n    own: function (handle) {\n        var handles = handlesWeakMap.get(this);\n        handles.push(handle);\n        return {\n            destroy: function () {\n                handles.splice(handles.indexOf(handle));\n                handle.destroy();\n            }\n        };\n    },\n    destroy: function () {\n        var _this = this;\n        return new Promise_1.default(function (resolve) {\n            handlesWeakMap.get(_this).forEach(function (handle) {\n                handle && handle.destroy && handle.destroy();\n            });\n            _this.destroy = noop;\n            _this.own = destroyed;\n            resolve(true);\n        });\n    }\n}, function (instance) {\n    handlesWeakMap.set(instance, []);\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createDestroyable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/compose/bases/createDestroyable.js\n// module id = 31\n// module chunks = 0","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\"use strict\";\nvar global_1 = require(\"./support/global\");\nvar queue_1 = require(\"./support/queue\");\nvar iterator_1 = require(\"./iterator\");\nrequire(\"./Symbol\");\nvar decorators_1 = require(\"./support/decorators\");\nvar Shim;\n(function (Shim) {\n    /**\n     * Returns true if a given value has a `then` method.\n     * @param {any} value The value to check if is Thenable\n     * @returns {is Thenable<T>} A type guard if the value is thenable\n     */\n    function isThenable(value) {\n        return value && typeof value.then === 'function';\n    }\n    Shim.isThenable = isThenable;\n    /**\n     * Promise is a partial implementation of the ES2015 Promise specification. It relies on Promise to do some safety\n     * checks such as verifying that a Promise isn't resolved with itself. This class is exported for testability, and is\n     * not intended to be used directly.\n     *\n     * @borrows Promise.all as Promise.all\n     * @borrows Promise.race as Promise.race\n     * @borrows Promise.reject as Promise.reject\n     * @borrows Promise.resolve as Promise.resolve\n     * @borrows Promise#catch as Promise#catch\n     * @borrows Promise#then as Promise#then\n     */\n    var Promise = (function () {\n        /**\n         * Creates a new Promise.\n         *\n         * @constructor\n         *\n         * @param executor\n         * The executor function is called immediately when the Promise is instantiated. It is responsible for\n         * starting the asynchronous operation when it is invoked.\n         *\n         * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n         * successfully, or the `reject` function when the operation fails.\n         */\n        function Promise(executor) {\n            var _this = this;\n            /**\n             * The current state of this promise.\n             */\n            this.state = 1 /* Pending */;\n            this[Symbol.toStringTag] = 'Promise';\n            /**\n             * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n             */\n            var isChained = false;\n            /**\n             * Whether or not this promise is in a resolved state.\n             */\n            var isResolved = function () {\n                return _this.state !== 1 /* Pending */ || isChained;\n            };\n            /**\n             * Callbacks that should be invoked once the asynchronous operation has completed.\n             */\n            var callbacks = [];\n            /**\n             * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n             * enqueues callbacks for execution on the next event loop turn.\n             */\n            var whenFinished = function (callback) {\n                if (callbacks) {\n                    callbacks.push(callback);\n                }\n            };\n            /**\n             * Settles this promise.\n             *\n             * @param newState The resolved state for this promise.\n             * @param {T|any} value The resolved value for this promise.\n             */\n            var settle = function (newState, value) {\n                // A promise can only be settled once.\n                if (_this.state !== 1 /* Pending */) {\n                    return;\n                }\n                _this.state = newState;\n                _this.resolvedValue = value;\n                whenFinished = queue_1.queueMicroTask;\n                // Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n                // wait an extra turn.\n                if (callbacks && callbacks.length > 0) {\n                    queue_1.queueMicroTask(function () {\n                        if (callbacks) {\n                            var count = callbacks.length;\n                            for (var i = 0; i < count; ++i) {\n                                callbacks[i].call(null);\n                            }\n                            callbacks = null;\n                        }\n                    });\n                }\n            };\n            /**\n             * Resolves this promise.\n             *\n             * @param newState The resolved state for this promise.\n             * @param {T|any} value The resolved value for this promise.\n             */\n            var resolve = function (newState, value) {\n                if (isResolved()) {\n                    return;\n                }\n                if (isThenable(value)) {\n                    value.then(settle.bind(null, 0 /* Fulfilled */), settle.bind(null, 2 /* Rejected */));\n                    isChained = true;\n                }\n                else {\n                    settle(newState, value);\n                }\n            };\n            this.then = function (onFulfilled, onRejected) {\n                return new Promise(function (resolve, reject) {\n                    // whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n                    // promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n                    // event loop.\n                    whenFinished(function () {\n                        var callback = _this.state === 2 /* Rejected */ ? onRejected : onFulfilled;\n                        if (typeof callback === 'function') {\n                            try {\n                                resolve(callback(_this.resolvedValue));\n                            }\n                            catch (error) {\n                                reject(error);\n                            }\n                        }\n                        else if (_this.state === 2 /* Rejected */) {\n                            reject(_this.resolvedValue);\n                        }\n                        else {\n                            resolve(_this.resolvedValue);\n                        }\n                    });\n                });\n            };\n            try {\n                executor(resolve.bind(null, 0 /* Fulfilled */), resolve.bind(null, 2 /* Rejected */));\n            }\n            catch (error) {\n                settle(2 /* Rejected */, error);\n            }\n        }\n        Promise.all = function (iterable) {\n            return new this(function (resolve, reject) {\n                var values = [];\n                var complete = 0;\n                var total = 0;\n                var populating = true;\n                function fulfill(index, value) {\n                    values[index] = value;\n                    ++complete;\n                    finish();\n                }\n                function finish() {\n                    if (populating || complete < total) {\n                        return;\n                    }\n                    resolve(values);\n                }\n                function processItem(index, item) {\n                    ++total;\n                    if (isThenable(item)) {\n                        // If an item Promise rejects, this Promise is immediately rejected with the item\n                        // Promise's rejection error.\n                        item.then(fulfill.bind(null, index), reject);\n                    }\n                    else {\n                        Promise.resolve(item).then(fulfill.bind(null, index));\n                    }\n                }\n                var i = 0;\n                iterator_1.forOf(iterable, function (value) {\n                    processItem(i, value);\n                    i++;\n                });\n                populating = false;\n                finish();\n            });\n        };\n        Promise.race = function (iterable) {\n            return new this(function (resolve, reject) {\n                iterator_1.forOf(iterable, function (item) {\n                    if (item instanceof Promise) {\n                        // If a Promise item rejects, this Promise is immediately rejected with the item\n                        // Promise's rejection error.\n                        item.then(resolve, reject);\n                    }\n                    else {\n                        Promise.resolve(item).then(resolve);\n                    }\n                });\n            });\n        };\n        Promise.reject = function (reason) {\n            return new this(function (resolve, reject) {\n                reject(reason);\n            });\n        };\n        Promise.resolve = function (value) {\n            return new this(function (resolve) {\n                resolve(value);\n            });\n        };\n        Promise.prototype.catch = function (onRejected) {\n            return this.then(undefined, onRejected);\n        };\n        return Promise;\n    }());\n    Shim.Promise = Promise;\n})(Shim || (Shim = {}));\nvar Promise = (function () {\n    /**\n     * Creates a new Promise.\n     *\n     * @constructor\n     *\n     * @param executor\n     * The executor function is called immediately when the Promise is instantiated. It is responsible for\n     * starting the asynchronous operation when it is invoked.\n     *\n     * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n     * successfully, or the `reject` function when the operation fails.\n     */\n    /* istanbul ignore next */\n    function Promise(executor) {\n    }\n    /**\n     * Converts an iterable object containing promises into a single promise that resolves to a new iterable object\n     * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the\n     * iterable. Iterable values that are not promises are converted to promises using Promise.resolve.\n     *\n     * @example\n     * Promise.all([ Promise.resolve('foo'), 'bar' ]).then(function (value) {\n     *     value[0] === 'foo'; // true\n     *     value[1] === 'bar'; // true\n     * });\n     *\n     * @example\n     * Promise.all({\n     *     foo: Promise.resolve('foo'),\n     *     bar: 'bar'\n     * }).then((value) => {\n     *     value.foo === 'foo'; // true\n     *     value.bar === 'bar'; // true\n     * });\n     */\n    /* istanbul ignore next */\n    Promise.all = function (iterable) {\n        throw new Error();\n    };\n    ;\n    /**\n     * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of\n     * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in\n     * the iterable that are not Promises are converted to Promises with Promise.resolve.\n     *\n     * @example\n     * Promise.race([ Promise.resolve('foo'), Promise.resolve('bar') ]).then((value) => {\n     *     value === 'foo'; // true\n     * });\n     *\n     * @example\n     * Promise.race({\n     *     foo: Promise.resolve('foo'),\n     *     bar: Promise.resolve('bar')\n     * }).then((value) => {\n     *     value === 'foo'; // true\n     * });\n     */\n    /* istanbul ignore next */\n    Promise.race = function (iterable) {\n        throw new Error();\n    };\n    /**\n     * Creates a new promise that is rejected with the given error.\n     */\n    /* istanbul ignore next */\n    Promise.reject = function (reason) {\n        throw new Error();\n    };\n    /* istanbul ignore next */\n    Promise.resolve = function (value) {\n        throw new Error();\n    };\n    /* istanbul ignore next */\n    Promise.prototype.catch = function (onRejected) {\n        throw new Error();\n    };\n    /* istanbul ignore next */\n    Promise.prototype.then = function (onFulfilled, onRejected) {\n        throw new Error();\n    };\n    return Promise;\n}());\nPromise = __decorate([\n    decorators_1.hasClass('es6-promise', global_1.default.Promise, Shim.Promise)\n], Promise);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Promise;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/Promise.js\n// module id = 32\n// module chunks = 0","\"use strict\";\nvar global_1 = require(\"./global\");\nvar has_1 = require(\"./has\");\n/**\n * Executes a task\n * @param item The task to execute\n */\nfunction executeTask(item) {\n    if (item && item.isActive) {\n        item.callback();\n    }\n}\n/**\n * Get a handle to be able to remove an item from the queue\n */\nfunction getQueueHandle(item, destructor) {\n    return {\n        destroy: function () {\n            this.destroy = function () { };\n            if (item) {\n                item.isActive = false;\n            }\n            if (destructor) {\n                destructor();\n            }\n        }\n    };\n}\nvar microTasks = [];\nvar microTaskQueued = false;\nvar checkMicroTaskQueue = function () { };\n/**\n * Schedules a callback to the macrotask queue.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexports.queueTask = (function () {\n    var destructor;\n    var enqueue;\n    /* IE and Edge's setImmediate does not always resolve as a macro task, sometimes as a microtask */\n    if (has_1.default('postmessage')) {\n        var queue_1 = [];\n        addEventListener('message', function (event) {\n            // Confirm that the event was triggered by the current window and by this particular implementation.\n            if (event.source === global_1.default && event.data === 'dojo-queue-message') {\n                event.stopPropagation();\n                if (queue_1.length) {\n                    executeTask(queue_1.shift());\n                }\n            }\n        });\n        enqueue = function (item) {\n            queue_1.push(item);\n            postMessage('dojo-queue-message', '*');\n        };\n    }\n    else if (has_1.default('setimmediate')) {\n        destructor = clearImmediate;\n        enqueue = function (item) {\n            return setImmediate(executeTask.bind(null, item));\n        };\n    }\n    else {\n        destructor = clearTimeout;\n        enqueue = function (item) {\n            return setTimeout(executeTask.bind(null, item), 0);\n        };\n    }\n    function queueTask(callback) {\n        var item = {\n            isActive: true,\n            callback: callback\n        };\n        var id = enqueue(item);\n        return getQueueHandle(item, destructor && function () {\n            destructor(id);\n        });\n    }\n    ;\n    // TODO: Use aspect.before when it is available.\n    return has_1.default('microtasks') ? queueTask : function (callback) {\n        checkMicroTaskQueue();\n        return queueTask(callback);\n    };\n})();\ncheckMicroTaskQueue = !has_1.default('microtasks')\n    ? function () {\n        if (!microTaskQueued) {\n            microTaskQueued = true;\n            exports.queueTask(function () {\n                microTaskQueued = false;\n                if (microTasks.length) {\n                    var item = void 0;\n                    while (item = microTasks.shift()) {\n                        executeTask(item);\n                    }\n                }\n            });\n        }\n    } : checkMicroTaskQueue;\n/**\n * Schedules a callback to the microtask queue.\n *\n * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native\n * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask\n * registered with `queueTask` or `queueAnimationTask`.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexports.queueMicroTask = (function () {\n    var enqueue;\n    if (has_1.default('host-node')) {\n        enqueue = function (item) {\n            process.nextTick(executeTask.bind(null, item));\n        };\n    }\n    else if (has_1.default('es6-promise') && !has_1.default('setimmediate') && !has_1.default('host-node')) {\n        enqueue = function (item) {\n            global_1.default.Promise.resolve(item).then(executeTask);\n        };\n    }\n    else if (has_1.default('dom-mutationobserver')) {\n        /* tslint:disable-next-line:variable-name */\n        var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;\n        var node_1 = document.createElement('div');\n        var queue_2 = [];\n        var observer = new HostMutationObserver(function () {\n            while (queue_2.length > 0) {\n                var item = queue_2.shift();\n                if (item && item.isActive) {\n                    item.callback();\n                }\n            }\n        });\n        observer.observe(node_1, { attributes: true });\n        enqueue = function (item) {\n            queue_2.push(item);\n            node_1.setAttribute('queueStatus', '1');\n        };\n    }\n    else {\n        enqueue = function (item) {\n            checkMicroTaskQueue();\n            microTasks.push(item);\n        };\n    }\n    return function (callback) {\n        var item = {\n            isActive: true,\n            callback: callback\n        };\n        enqueue(item);\n        return getQueueHandle(item);\n    };\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/support/queue.js\n// module id = 33\n// module chunks = 0","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 34\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/setimmediate/setImmediate.js\n// module id = 35\n// module chunks = 0","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\"use strict\";\nvar ExtensiblePromise_1 = require(\"./ExtensiblePromise\");\n/**\n * A type guard that determines if `value` is a `Task`\n * @param value The value to guard\n */\nfunction isTask(value) {\n    return Boolean(value && typeof value.cancel === 'function' && Array.isArray(value.children) && isThenable(value));\n}\nexports.isTask = isTask;\n/**\n * Returns true if a given value has a `then` method.\n * @param {any} value The value to check if is Thenable\n * @returns {is Thenable<T>} A type guard if the value is thenable\n */\nfunction isThenable(value) {\n    return value && typeof value.then === 'function';\n}\nexports.isThenable = isThenable;\n/**\n * Task is an extension of Promise that supports cancellation and the Task#finally method.\n */\nvar Task = (function (_super) {\n    __extends(Task, _super);\n    /**\n     * @constructor\n     *\n     * Create a new task. Executor is run immediately. The canceler will be called when the task is canceled.\n     *\n     * @param executor Method that initiates some task\n     * @param canceler Method to call when the task is canceled\n     *\n     */\n    function Task(executor, canceler) {\n        var _this = this;\n        // we have to initialize these to avoid a compiler error of using them before they are initialized\n        var superResolve = function () { };\n        var superReject = function () { };\n        _this = _super.call(this, function (resolve, reject) {\n            superResolve = resolve;\n            superReject = reject;\n        }) || this;\n        _this._state = 1 /* Pending */;\n        _this.children = [];\n        _this.canceler = function () {\n            if (canceler) {\n                canceler();\n            }\n            _this._cancel();\n        };\n        // Don't let the Task resolve if it's been canceled\n        try {\n            executor(function (value) {\n                if (_this._state === 3 /* Canceled */) {\n                    return;\n                }\n                _this._state = 0 /* Fulfilled */;\n                superResolve(value);\n            }, function (reason) {\n                if (_this._state === 3 /* Canceled */) {\n                    return;\n                }\n                _this._state = 2 /* Rejected */;\n                superReject(reason);\n            });\n        }\n        catch (reason) {\n            _this._state = 2 /* Rejected */;\n            superReject(reason);\n        }\n        return _this;\n    }\n    /**\n     * Return a Task that resolves when one of the passed in objects have resolved\n     *\n     * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns {Task}\n     */\n    Task.race = function (iterable) {\n        return _super.race.call(this, iterable);\n    };\n    /**\n     * Return a rejected promise wrapped in a Task\n     *\n     * @param {Error?} reason    The reason for the rejection\n     * @returns {Task}\n     */\n    Task.reject = function (reason) {\n        return new this(function (resolve, reject) { return reject(reason); });\n    };\n    Task.resolve = function (value) {\n        return new this(function (resolve, reject) { return resolve(value); });\n    };\n    Task.all = function (iterable) {\n        return _super.all.call(this, iterable);\n    };\n    Object.defineProperty(Task.prototype, \"state\", {\n        get: function () {\n            return this._state;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Propagates cancellation down through a Task tree. The Task's state is immediately set to canceled. If a Thenable\n     * finally task was passed in, it is resolved before calling this Task's finally callback; otherwise, this Task's\n     * finally callback is immediately executed. `_cancel` is called for each child Task, passing in the value returned\n     * by this Task's finally callback or a Promise chain that will eventually resolve to that value.\n     */\n    Task.prototype._cancel = function (finallyTask) {\n        var _this = this;\n        this._state = 3 /* Canceled */;\n        var runFinally = function () {\n            try {\n                return _this._finally();\n            }\n            catch (error) {\n            }\n        };\n        if (this._finally) {\n            if (isThenable(finallyTask)) {\n                finallyTask = finallyTask.then(runFinally, runFinally);\n            }\n            else {\n                finallyTask = runFinally();\n            }\n        }\n        this.children.forEach(function (child) {\n            child._cancel(finallyTask);\n        });\n    };\n    /**\n     * Immediately cancels this task if it has not already resolved. This Task and any descendants are synchronously set\n     * to the Canceled state and any `finally` added downstream from the canceled Task are invoked.\n     */\n    Task.prototype.cancel = function () {\n        if (this._state === 1 /* Pending */) {\n            this.canceler();\n        }\n    };\n    Task.prototype.catch = function (onRejected) {\n        return this.then(undefined, onRejected);\n    };\n    /**\n     * Allows for cleanup actions to be performed after resolution of a Promise.\n     */\n    Task.prototype.finally = function (callback) {\n        // if this task is already canceled, call the task\n        if (this._state === 3 /* Canceled */) {\n            return Task.resolve(callback());\n        }\n        var task = this.then(function (value) { return Task.resolve(callback()).then(function () { return value; }); }, function (reason) { return Task.resolve(callback()).then(function () {\n            throw reason;\n        }); });\n        // Keep a reference to the callback; it will be called if the Task is canceled\n        task._finally = callback;\n        return task;\n    };\n    Task.prototype.then = function (onFulfilled, onRejected) {\n        var _this = this;\n        // FIXME\n        // tslint:disable-next-line:no-var-keyword\n        var task = _super.prototype.then.call(this, \n        // Don't call the onFulfilled or onRejected handlers if this Task is canceled\n        function (value) {\n            if (task._state === 3 /* Canceled */) {\n                return;\n            }\n            if (onFulfilled) {\n                return onFulfilled(value);\n            }\n            return value;\n        }, function (error) {\n            if (task._state === 3 /* Canceled */) {\n                return;\n            }\n            if (onRejected) {\n                return onRejected(error);\n            }\n            throw error;\n        });\n        task.canceler = function () {\n            // If task's parent (this) hasn't been resolved, cancel it; downward propagation will start at the first\n            // unresolved parent\n            if (_this._state === 1 /* Pending */) {\n                _this.cancel();\n            }\n            else {\n                task._cancel();\n            }\n        };\n        // Keep track of child Tasks for propogating cancelation back down the chain\n        this.children.push(task);\n        return task;\n    };\n    return Task;\n}(ExtensiblePromise_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Task;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/async/Task.js\n// module id = 36\n// module chunks = 0","\"use strict\";\nvar iterator_1 = require(\"@dojo/shim/iterator\");\nvar Promise_1 = require(\"@dojo/shim/Promise\");\n/**\n * Take a list of values, and if any are ExtensiblePromise objects, insert the wrapped Promise in its place,\n * otherwise use the original object. We use this to help use the native Promise methods like `all` and `race`.\n *\n * @param iterable    The list of objects to iterate over\n * @returns {any[]}    The list of objects, as an array, with ExtensiblePromises being replaced by Promises.\n */\nfunction unwrapPromises(iterable) {\n    var unwrapped = [];\n    iterator_1.forOf(iterable, function (item) {\n        unwrapped.push(item instanceof ExtensiblePromise ? item._promise : item);\n    });\n    return unwrapped;\n}\n/**\n * An extensible base to allow Promises to be extended in ES5. This class basically wraps a native Promise object,\n * giving an API like a native promise.\n */\nvar ExtensiblePromise = (function () {\n    /**\n     * Creates a new extended Promise.\n     *\n     * @constructor\n     *\n     * @param executor\n     * The executor function is called immediately when the Promise is instantiated. It is responsible for\n     * starting the asynchronous operation when it is invoked.\n     *\n     * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n     * successfully, or the `reject` function when the operation fails.\n     */\n    function ExtensiblePromise(executor) {\n        this._promise = new Promise_1.default(executor);\n    }\n    /**\n     * Return a rejected promise wrapped in an ExtensiblePromise\n     *\n     * @param {Error?} reason    The reason for the rejection\n     * @returns {ExtensiblePromise}\n     */\n    ExtensiblePromise.reject = function (reason) {\n        return new this(function (resolve, reject) { return reject(reason); });\n    };\n    ExtensiblePromise.resolve = function (value) {\n        return new this(function (resolve, reject) { return resolve(value); });\n    };\n    ExtensiblePromise.all = function (iterable) {\n        if (!iterator_1.isArrayLike(iterable) && !iterator_1.isIterable(iterable)) {\n            var promiseKeys_1 = Object.keys(iterable);\n            return new this(function (resolve, reject) {\n                Promise_1.default.all(promiseKeys_1.map(function (key) { return iterable[key]; })).then(function (promiseResults) {\n                    var returnValue = {};\n                    promiseResults.forEach(function (value, index) {\n                        returnValue[promiseKeys_1[index]] = value;\n                    });\n                    resolve(returnValue);\n                }, reject);\n            });\n        }\n        return new this(function (resolve, reject) {\n            Promise_1.default.all(unwrapPromises(iterable)).then(resolve, reject);\n        });\n    };\n    /**\n     * Return a ExtensiblePromise that resolves when one of the passed in objects have resolved\n     *\n     * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns {ExtensiblePromise}\n     */\n    ExtensiblePromise.race = function (iterable) {\n        return new this(function (resolve, reject) {\n            Promise_1.default.race(unwrapPromises(iterable)).then(resolve, reject);\n        });\n    };\n    ExtensiblePromise.prototype.catch = function (onRejected) {\n        return this.then(undefined, onRejected);\n    };\n    ExtensiblePromise.prototype.then = function (onFulfilled, onRejected) {\n        var _this = this;\n        var e = function (resolve, reject) {\n            function handler(rejected, valueOrError) {\n                var callback = rejected ? onRejected : onFulfilled;\n                if (typeof callback === 'function') {\n                    try {\n                        resolve(callback(valueOrError));\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                }\n                else if (rejected) {\n                    reject(valueOrError);\n                }\n                else {\n                    resolve(valueOrError);\n                }\n            }\n            _this._promise.then(handler.bind(null, false), handler.bind(null, true));\n        };\n        return new this.constructor(e);\n    };\n    return ExtensiblePromise;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ExtensiblePromise;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/async/ExtensiblePromise.js\n// module id = 37\n// module chunks = 0","\"use strict\";\nvar lang_1 = require(\"./lang\");\nfunction emit(target, event) {\n    if (target.dispatchEvent &&\n        ((target.ownerDocument && target.ownerDocument.createEvent) ||\n            (target.document && target.document.createEvent) ||\n            target.createEvent) /* matches document */) {\n        var nativeEvent = (target.ownerDocument || target.document || target).createEvent('HTMLEvents');\n        nativeEvent.initEvent(event.type, Boolean(event.bubbles), Boolean(event.cancelable));\n        for (var key in event) {\n            if (!(key in nativeEvent)) {\n                nativeEvent[key] = event[key];\n            }\n        }\n        return target.dispatchEvent(nativeEvent);\n    }\n    if (target.emit) {\n        if (target.removeListener) {\n            // Node.js EventEmitter\n            target.emit(event.type, event);\n            return false;\n        }\n        else if (target.on) {\n            // Dojo Evented or similar\n            target.emit(event);\n            return false;\n        }\n    }\n    throw new Error('Target must be an event emitter');\n}\nexports.emit = emit;\nfunction on(target, type, listener, capture) {\n    if (Array.isArray(type)) {\n        var handles = type.map(function (type) {\n            return on(target, type, listener, capture);\n        });\n        return lang_1.createCompositeHandle.apply(void 0, handles);\n    }\n    var callback = function () {\n        listener.apply(this, arguments);\n    };\n    // DOM EventTarget\n    if (target.addEventListener && target.removeEventListener) {\n        target.addEventListener(type, callback, capture);\n        return lang_1.createHandle(function () {\n            target.removeEventListener(type, callback, capture);\n        });\n    }\n    if (target.on) {\n        // EventEmitter\n        if (target.removeListener) {\n            target.on(type, callback);\n            return lang_1.createHandle(function () {\n                target.removeListener(type, callback);\n            });\n        }\n        else if (target.emit) {\n            return target.on(type, listener);\n        }\n    }\n    throw new TypeError('Unknown event emitter object');\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = on;\nfunction once(target, type, listener, capture) {\n    // FIXME\n    // tslint:disable-next-line:no-var-keyword\n    var handle = on(target, type, function () {\n        handle.destroy();\n        return listener.apply(this, arguments);\n    }, capture);\n    return handle;\n}\nexports.once = once;\nfunction pausable(target, type, listener, capture) {\n    var paused;\n    var handle = on(target, type, function () {\n        if (!paused) {\n            return listener.apply(this, arguments);\n        }\n    }, capture);\n    handle.pause = function () {\n        paused = true;\n    };\n    handle.resume = function () {\n        paused = false;\n    };\n    return handle;\n}\nexports.pausable = pausable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/on.js\n// module id = 38\n// module chunks = 0","\"use strict\";\nvar UrlSearchParams_1 = require(\"@dojo/core/UrlSearchParams\");\n/**\n * Parses a path\n * @param path The path to parse.\n * @return The search params, pathname segments, and whether it ended with a trailing slash.\n */\nfunction parse(path) {\n    var tokens = path.split(/([/?#])/).filter(Boolean);\n    var pathnameTokens = tokens;\n    var searchParams;\n    var searchStart = tokens.indexOf('?');\n    var hashStart = tokens.indexOf('#');\n    if (searchStart >= 0) {\n        if (hashStart >= 0) {\n            // Either `/foo?bar#baz` or `/foo#bar?baz`\n            pathnameTokens = tokens.slice(0, Math.min(searchStart, hashStart));\n            searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1, hashStart).join(''));\n        }\n        else {\n            // `/foo?bar`\n            pathnameTokens = tokens.slice(0, searchStart);\n            searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1).join(''));\n        }\n    }\n    else {\n        searchParams = new UrlSearchParams_1.default();\n        if (hashStart >= 0) {\n            // `/foo#bar`\n            pathnameTokens = tokens.slice(0, hashStart);\n        }\n    }\n    var segments = pathnameTokens.filter(function (t) { return t !== '/'; });\n    var trailingSlash = pathnameTokens[pathnameTokens.length - 1] === '/' && segments.length > 0;\n    return {\n        searchParams: searchParams,\n        segments: segments,\n        trailingSlash: trailingSlash\n    };\n}\nexports.parse = parse;\n/**\n * Determines whether a DeconstructedPath is a (partial) match for given pathname segments.\n * @param expectedSegments Part of a DeconstructedPath object.\n * @param segments Pathname segments as returned by `parse()`\n * @return A result object.\n */\nfunction match(_a, segments) {\n    var expectedSegments = _a.expectedSegments;\n    if (expectedSegments.length === 0) {\n        return {\n            hasRemaining: segments.length > 0,\n            offset: 0,\n            values: []\n        };\n    }\n    if (expectedSegments.length > segments.length) {\n        return null;\n    }\n    var isMatch = true;\n    var values = [];\n    for (var i = 0; isMatch && i < expectedSegments.length; i++) {\n        var value = segments[i];\n        var expected = expectedSegments[i];\n        if (isNamedSegment(expected)) {\n            values.push(value);\n        }\n        else if (expected.literal !== value) {\n            isMatch = false;\n        }\n    }\n    if (!isMatch) {\n        return null;\n    }\n    return {\n        hasRemaining: expectedSegments.length < segments.length,\n        offset: expectedSegments.length,\n        values: values\n    };\n}\nexports.match = match;\n/**\n * Determine whether the segment is a NamedSegment.\n *\n * @param segment The segment to be checked\n * @return true if the segment is a NamedSegment, false otherwise\n */\nfunction isNamedSegment(segment) {\n    return segment.name !== undefined;\n}\nexports.isNamedSegment = isNamedSegment;\n/**\n * Deconstruct a route path into its constituent parts.\n * @param path The path to deconstruct.\n * @return An object describing the path's constituent parts.\n */\nfunction deconstruct(path) {\n    var expectedSegments = [];\n    var parameters = [];\n    var searchParameters = [];\n    var trailingSlash = false;\n    var tokens = path.split(/([/{}?&])/).filter(Boolean);\n    var leadingSlash = tokens[0] === '/';\n    var i = 0;\n    var consume = function () { return tokens[i++]; };\n    var peek = function () { return tokens[i]; };\n    var inSearchComponent = false;\n    while (i < tokens.length) {\n        var t = consume();\n        switch (t) {\n            case '{': {\n                var name_1 = consume();\n                if (!name_1 || name_1 === '}') {\n                    throw new TypeError('Parameter must have a name');\n                }\n                // Reserve : for future use, e.g. including type data in the parameter declaration.\n                if (name_1 === '{' || name_1 === '&' || /:/.test(name_1)) {\n                    throw new TypeError('Parameter name must not contain \\'{\\', \\'&\\' or \\':\\'');\n                }\n                if (parameters.indexOf(name_1) !== -1 || searchParameters.indexOf(name_1) !== -1) {\n                    throw new TypeError(\"Parameter must have a unique name, got '\" + name_1 + \"'\");\n                }\n                var closing = consume();\n                if (!closing || closing !== '}') {\n                    throw new TypeError(\"Parameter name must be followed by '}', got '\" + closing + \"'\");\n                }\n                var separator = peek();\n                if (separator) {\n                    if (inSearchComponent) {\n                        if (separator !== '&') {\n                            throw new TypeError(\"Search parameter must be followed by '&', got '\" + separator + \"'\");\n                        }\n                    }\n                    else if (separator !== '/' && separator !== '?') {\n                        throw new TypeError(\"Parameter must be followed by '/' or '?', got '\" + separator + \"'\");\n                    }\n                }\n                if (inSearchComponent) {\n                    searchParameters.push(name_1);\n                }\n                else {\n                    parameters.push(name_1);\n                    expectedSegments.push(Object.freeze({ name: name_1 }));\n                }\n                break;\n            }\n            case '?':\n            case '/':\n                if (inSearchComponent) {\n                    throw new TypeError(\"Expected parameter in search component, got '\" + t + \"'\");\n                }\n                if (t === '?') {\n                    inSearchComponent = true;\n                    if (expectedSegments.length === 0) {\n                        throw new TypeError('Path must contain at least one segment');\n                    }\n                }\n                if (t === '/') {\n                    var next_1 = peek();\n                    if (next_1 === '/') {\n                        throw new TypeError('Path segment must not be empty');\n                    }\n                    if (expectedSegments.length > 0 && (!next_1 || next_1 === '?')) {\n                        trailingSlash = true;\n                    }\n                }\n                break;\n            case '&':\n                if (!inSearchComponent) {\n                    throw new TypeError('Path segment must not contain \\'&\\'');\n                }\n                var next = peek();\n                if (next === '&') {\n                    throw new TypeError('Expected parameter in search component, got \\'&\\'');\n                }\n                break;\n            default:\n                if (inSearchComponent) {\n                    throw new TypeError(\"Expected parameter in search component, got '\" + t + \"'\");\n                }\n                expectedSegments.push(Object.freeze({ literal: t }));\n        }\n    }\n    return Object.freeze({\n        expectedSegments: Object.freeze(expectedSegments),\n        leadingSlash: leadingSlash,\n        parameters: Object.freeze(parameters),\n        searchParameters: Object.freeze(searchParameters),\n        trailingSlash: trailingSlash\n    });\n}\nexports.deconstruct = deconstruct;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/routing/lib/path.js\n// module id = 39\n// module chunks = 0","\"use strict\";\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar createEvented_1 = require(\"@dojo/compose/bases/createEvented\");\nvar global_1 = require(\"@dojo/core/global\");\nvar on_1 = require(\"@dojo/core/on\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar privateStateMap = new WeakMap_1.default();\nvar createHashHistory = compose_1.default.mixin(createEvented_1.default, {\n    mixin: {\n        get current() {\n            return privateStateMap.get(this).current;\n        },\n        prefix: function (path) {\n            return \"#\" + path;\n        },\n        set: function (path) {\n            var privateState = privateStateMap.get(this);\n            if (privateState.current === path) {\n                return;\n            }\n            privateState.current = path;\n            privateState.browserLocation.hash = this.prefix(path);\n            this.emit({\n                type: 'change',\n                value: path\n            });\n        },\n        replace: function (path) {\n            var privateState = privateStateMap.get(this);\n            if (privateState.current === path) {\n                return;\n            }\n            privateState.current = path;\n            var _a = privateState.browserLocation, pathname = _a.pathname, search = _a.search;\n            privateState.browserLocation.replace(pathname + search + this.prefix(path));\n            this.emit({\n                type: 'change',\n                value: path\n            });\n        }\n    },\n    initialize: function (instance, _a) {\n        var window = (_a === void 0 ? { window: global_1.default } : _a).window;\n        var browserLocation = window.location;\n        var privateState = {\n            current: browserLocation.hash.slice(1),\n            browserLocation: browserLocation\n        };\n        privateStateMap.set(instance, privateState);\n        instance.own(on_1.default(window, 'hashchange', function () {\n            var path = browserLocation.hash.slice(1);\n            // Ignore hashchange for the current path. Guards against browsers firing hashchange when the history\n            // manager sets the hash.\n            if (path !== privateState.current) {\n                privateState.current = path;\n                instance.emit({\n                    type: 'change',\n                    value: path\n                });\n            }\n        }));\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createHashHistory;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/routing/history/createHashHistory.js\n// module id = 40\n// module chunks = 0","import { StoreDelta } from '@dojo/stores/store/mixins/createObservableStoreMixin';\nimport widgetStore from '../stores/widgetStore';\nimport todoStore from '../stores/todoStore';\nimport { Item } from '../stores/todoStore';\n\nexport const putTodo = function({ afterAll = [] }: StoreDelta<any>) {\n\tconst completedCount = afterAll.filter(({ completed }) => completed).length;\n\tconst activeCount = afterAll.length - completedCount;\n\tconst allCompleted = afterAll.length === completedCount;\n\n\treturn widgetStore.patch({ id: 'todo-app', todos: afterAll, activeCount, completedCount, allCompleted });\n};\n\nexport const setHierarchy = function (this: any, widgets: [ string, any ][]) {\n\twidgetStore.patch({ id: 'todo-app', widgets });\n};\n\nexport const filterAndView = function (this: any, filter: 'active' | 'all' | 'completed', view: 'list' | 'cards') {\n\tconst { state: { activeView = view, activeFilter = filter } = { } } = this;\n\twidgetStore.patch({ id: 'todo-app', activeView, activeFilter });\n};\n\nexport const showTodoDetails = function(todoId: string) {\n\treturn todoStore.get(todoId).then(( todo: Item) => {\n\t\twidgetStore.patch({ id: 'todo-details', todoDetails: todo }).then(() => {\n\t\t\tsetHierarchy([ [ 'main', {} ], [ 'todo-details', { id: 'todo-details', externalState: widgetStore } ] ]);\n\t\t});\n\t});\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions/widgetStoreActions.ts","import createObservableStore from './createObservableStore';\n\nexport default createObservableStore({\n\tdata: [\n\t\t{\n\t\t\tid: 'todo-app',\n\t\t\ttodo: '',\n\t\t\ttodos: [],\n\t\t\tcompletedCount: 0,\n\t\t\tactiveCount: 0,\n\t\t\tactiveFilter: 'all',\n\t\t\tactiveView: 'list',\n\t\t\tsearch: '',\n\t\t\twidgets: []\n\t\t},\n\t\t{\n\t\t\tid: 'todo-details',\n\t\t\ttodoDetails: undefined\n\t\t}\n\t]\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/stores/widgetStore.ts","import createStore, { CrudOptions, UpdateResults } from '@dojo/stores/store/createStore';\nimport createObservableStoreMixin, {\n\tObservableStore, ObservableStoreOptions\n} from '@dojo/stores/store/mixins/createObservableStoreMixin';\n\nexport type Store<T> = ObservableStore<T, CrudOptions, UpdateResults<T>>;\n\nexport type StoreFactory = <T, O extends CrudOptions, U extends UpdateResults<T>>(options?: ObservableStoreOptions<T, O>) => ObservableStore<T, O, U>;\n\nconst createObservableStore: StoreFactory = createStore.mixin(createObservableStoreMixin());\n\nexport default createObservableStore;\n\n\n\n// WEBPACK FOOTER //\n// ./src/stores/createObservableStore.ts","\"use strict\";\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar Map_1 = require(\"@dojo/shim/Map\");\nvar lang_1 = require(\"@dojo/core/lang\");\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar Observable_1 = require(\"@dojo/core/Observable\");\nvar createPatch_1 = require(\"../patch/createPatch\");\nvar createStoreObservable_1 = require(\"./createStoreObservable\");\nvar createInMemoryStorage_1 = require(\"../storage/createInMemoryStorage\");\nvar instanceStateMap = new WeakMap_1.default();\nfunction isPatchArray(patches) {\n    return isPatch(patches[0]);\n}\nfunction isPatch(patchObj) {\n    var patch = patchObj && patchObj.patch;\n    var id = patchObj && patchObj.id;\n    return typeof id === 'string' && patch && Array.isArray(patch.operations) && typeof patch.apply === 'function' &&\n        typeof patch.toString === 'function';\n}\nfunction createStoreObservable(storeResultsPromise) {\n    return createStoreObservable_1.default(new Observable_1.Observable(function subscribe(observer) {\n        storeResultsPromise\n            .then(function (results) {\n            observer.next(results);\n            observer.complete();\n        }, function (error) {\n            observer.error(error);\n        });\n    }), function (results) {\n        return results.successfulData;\n    });\n}\nvar createStore = compose_1.default({\n    get: function (ids) {\n        var state = instanceStateMap.get(this);\n        return state.initialAddPromise.then(function () {\n            if (Array.isArray(ids)) {\n                return state.storage.get(ids).then(function (items) { return items.filter(function (item) { return Boolean(item); }); });\n            }\n            else {\n                return state.storage.get([ids]).then(function (items) { return items[0]; });\n            }\n        });\n    },\n    add: function (items, options) {\n        var self = this;\n        var state = instanceStateMap.get(self);\n        var storeResultsPromise = state.initialAddPromise.then(function () {\n            return state.storage.add(Array.isArray(items) ? items : [items], options);\n        });\n        return createStoreObservable(storeResultsPromise);\n    },\n    put: function (items, options) {\n        var self = this;\n        var state = instanceStateMap.get(self);\n        var storeResultsPromise = state.initialAddPromise.then(function () {\n            return state.storage.put(Array.isArray(items) ? items : [items], options);\n        });\n        return createStoreObservable(storeResultsPromise);\n    },\n    patch: function (updates, options) {\n        var self = this;\n        var state = instanceStateMap.get(self);\n        var patchEntries = [];\n        if (Array.isArray(updates)) {\n            if (isPatchArray(updates)) {\n                patchEntries = updates;\n            }\n            else {\n                patchEntries = self.identify(updates).map(function (id, index) {\n                    return { id: id, patch: createPatch_1.diff(updates[index]) };\n                });\n            }\n        }\n        else if (updates instanceof Map_1.default) {\n            updates.forEach(function (value, key) {\n                patchEntries.push({\n                    id: key,\n                    patch: value\n                });\n            });\n        }\n        else if (isPatch(updates)) {\n            patchEntries = [updates];\n        }\n        else {\n            var dupe = lang_1.duplicate(updates);\n            var idInOptions = (options && options.id);\n            var id = idInOptions || dupe.id;\n            if (!idInOptions) {\n                delete dupe.id;\n            }\n            patchEntries = [{ id: id, patch: createPatch_1.diff(dupe) }];\n        }\n        var storeResultsPromise = state.initialAddPromise.then(function () {\n            return state.storage.patch(patchEntries);\n        });\n        return createStoreObservable(storeResultsPromise);\n    },\n    delete: function (ids) {\n        var self = this;\n        var state = instanceStateMap.get(self);\n        var storeResultsPromise = state.initialAddPromise.then(function () {\n            return state.storage.delete(Array.isArray(ids) ? ids : [ids]);\n        });\n        return createStoreObservable(storeResultsPromise);\n    },\n    fetch: function (query) {\n        var state = instanceStateMap.get(this);\n        var resolveTotalLength;\n        var rejectTotalLength;\n        var totalLength = new Promise_1.default(function (resolve, reject) {\n            resolveTotalLength = resolve;\n            rejectTotalLength = reject;\n        });\n        var fetchResult = state.initialAddPromise.then(function () {\n            var result = state.storage.fetch(query);\n            result.totalLength.then(resolveTotalLength, rejectTotalLength);\n            return result;\n        });\n        fetchResult.totalLength = fetchResult.dataLength = totalLength;\n        return fetchResult;\n    },\n    identify: function (items) {\n        var storage = instanceStateMap.get(this).storage;\n        if (Array.isArray(items)) {\n            return storage.identify(items);\n        }\n        else {\n            return storage.identify([items])[0];\n        }\n    },\n    createId: function () {\n        return instanceStateMap.get(this).storage.createId();\n    }\n}, function (instance, options) {\n    options = options || {};\n    var data = options.data;\n    options.data = undefined;\n    var instanceState = {\n        storage: options.storage || createInMemoryStorage_1.default(options),\n        initialAddPromise: Promise_1.default.resolve()\n    };\n    instanceStateMap.set(instance, instanceState);\n    if (data) {\n        instanceState.initialAddPromise = instance.add(data).catch(function (error) {\n            console.error(error);\n        });\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createStore;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/store/createStore.js\n// module id = 44\n// module chunks = 0","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\"use strict\";\nvar Observable_1 = require(\"@dojo/shim/Observable\");\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nfunction isSubscribable(object) {\n    return object && object.subscribe !== undefined;\n}\nvar Observable = (function (_super) {\n    __extends(Observable, _super);\n    function Observable() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Observable.of = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        return _super.of.apply(this, items);\n    };\n    Observable.from = function (item) {\n        return _super.from.call(this, item);\n    };\n    Observable.defer = function (deferFunction) {\n        return new Observable(function (observer) {\n            var trueObservable = deferFunction();\n            return trueObservable.subscribe({\n                next: function (value) {\n                    return observer.next(value);\n                },\n                error: function (errorValue) {\n                    return observer.error(errorValue);\n                },\n                complete: function (completeValue) {\n                    observer.complete(completeValue);\n                }\n            });\n        });\n    };\n    Observable.prototype.toPromise = function () {\n        var _this = this;\n        return new Promise_1.default(function (resolve, reject) {\n            _this.subscribe({\n                next: function (value) {\n                    resolve(value);\n                },\n                error: function (error) {\n                    reject(error);\n                }\n            });\n        });\n    };\n    Observable.prototype.map = function (mapFunction) {\n        var self = this;\n        if (typeof mapFunction !== 'function') {\n            throw new TypeError('Map parameter must be a function');\n        }\n        return new Observable(function (observer) {\n            self.subscribe({\n                next: function (value) {\n                    try {\n                        var result = mapFunction(value);\n                        return observer.next(result);\n                    }\n                    catch (e) {\n                        return observer.error(e);\n                    }\n                },\n                error: function (errorValue) {\n                    return observer.error(errorValue);\n                },\n                complete: function (completeValue) {\n                    return observer.complete(completeValue);\n                }\n            });\n        });\n    };\n    Observable.prototype.filter = function (filterFunction) {\n        var self = this;\n        if (typeof filterFunction !== 'function') {\n            throw new TypeError('Filter argument must be a function');\n        }\n        return new Observable(function (observer) {\n            self.subscribe({\n                next: function (value) {\n                    try {\n                        if (filterFunction(value)) {\n                            return observer.next(value);\n                        }\n                    }\n                    catch (e) {\n                        return observer.error(e);\n                    }\n                },\n                error: function (errorValue) {\n                    return observer.error(errorValue);\n                },\n                complete: function (completeValue) {\n                    return observer.complete(completeValue);\n                }\n            });\n        });\n    };\n    Observable.prototype.toArray = function () {\n        var self = this;\n        return new Observable(function (observer) {\n            var values = [];\n            self.subscribe({\n                next: function (value) {\n                    values.push(value);\n                },\n                error: function (errorValue) {\n                    return observer.error(errorValue);\n                },\n                complete: function (completeValue) {\n                    observer.next(values);\n                    observer.complete(completeValue);\n                }\n            });\n        });\n    };\n    Observable.prototype.mergeAll = function (concurrent) {\n        var self = this;\n        return new Observable(function (observer) {\n            var active = [];\n            var queue = [];\n            function checkForComplete() {\n                if (active.length === 0 && queue.length === 0) {\n                    observer.complete();\n                }\n                else if (queue.length > 0 && active.length < concurrent) {\n                    var item = queue.shift();\n                    if (isSubscribable(item)) {\n                        var itemIndex_1 = active.length;\n                        active.push(item);\n                        item.subscribe({\n                            next: function (value) {\n                                observer.next(value);\n                            },\n                            complete: function () {\n                                active.splice(itemIndex_1, 1);\n                                checkForComplete();\n                            }\n                        });\n                    }\n                    else {\n                        observer.next(item);\n                        checkForComplete();\n                    }\n                }\n            }\n            self.subscribe({\n                next: function (value) {\n                    queue.push(value);\n                },\n                complete: function () {\n                    checkForComplete();\n                }\n            });\n        });\n    };\n    return Observable;\n}(Observable_1.default));\nexports.Observable = Observable;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Observable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/Observable.js\n// module id = 45\n// module chunks = 0","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\"use strict\";\nvar iterator_1 = require(\"./iterator\");\nvar decorators_1 = require(\"./support/decorators\");\nvar global_1 = require(\"./support/global\");\nrequire(\"./Symbol\");\nvar Shim;\n(function (Shim) {\n    /*\n     * Decorator to mark a single method/property as non-enumerable. ES spec requires pretty much every\n     * method or property in Subscription, Observable, and SubscriptionObserver to be non-enumerable.\n     */\n    function nonEnumerable(target, key, descriptor) {\n        descriptor.enumerable = false;\n    }\n    /*\n     * Create a subscription observer for a given observer, and return the subscription.  The \"logic\" for Observerables\n     * is in here!\n     */\n    function startSubscription(executor, observer) {\n        var closed = false;\n        var cleanUp;\n        function unsubscribe() {\n            if (!closed) {\n                closed = true;\n                if (cleanUp) {\n                    cleanUp();\n                }\n            }\n        }\n        function start(subscriptionObserver) {\n            if (observer.start) {\n                observer.start(subscription);\n            }\n            if (closed) {\n                return;\n            }\n            try {\n                var result = executor(subscriptionObserver);\n                if (typeof result === 'function') {\n                    cleanUp = result;\n                }\n                else if (result && 'unsubscribe' in result) {\n                    cleanUp = result.unsubscribe;\n                }\n                else if (result !== undefined && result !== null) {\n                    throw new TypeError('Subscriber must return a callable or subscription');\n                }\n                if (closed) {\n                    if (cleanUp) {\n                        cleanUp();\n                    }\n                }\n            }\n            catch (e) {\n                error(e);\n            }\n        }\n        function next(value) {\n            if (closed) {\n                return;\n            }\n            var next = observer.next;\n            try {\n                if (typeof next === 'function') {\n                    return next(value);\n                }\n                else if (next !== undefined && next !== null) {\n                    throw new TypeError('Observer.next is not a function');\n                }\n            }\n            catch (e) {\n                error(e);\n            }\n        }\n        function error(errorValue) {\n            if (!closed) {\n                var cleanUpError = undefined;\n                try {\n                    unsubscribe();\n                }\n                catch (e) {\n                    cleanUpError = e;\n                }\n                var observerError = observer.error;\n                if (observerError !== undefined && observerError !== null) {\n                    if (typeof observerError === 'function') {\n                        var errorResult = observerError(errorValue);\n                        if (cleanUpError !== undefined) {\n                            throw cleanUpError;\n                        }\n                        return errorResult;\n                    }\n                    else {\n                        throw new TypeError('Observer.error is not a function');\n                    }\n                }\n                else if (observer.complete) {\n                    return observer.complete(errorValue);\n                }\n                else {\n                    throw errorValue;\n                }\n            }\n            else {\n                throw errorValue;\n            }\n        }\n        function complete(completeValue) {\n            if (!closed) {\n                var cleanUpError = undefined;\n                try {\n                    unsubscribe();\n                }\n                catch (e) {\n                    cleanUpError = e;\n                }\n                var observerComplete = observer.complete;\n                if (observerComplete !== undefined && observerComplete !== null) {\n                    if (typeof observerComplete === 'function') {\n                        var completeResult = observerComplete(completeValue);\n                        if (cleanUpError !== undefined) {\n                            throw cleanUpError;\n                        }\n                        return completeResult;\n                    }\n                    else {\n                        throw new TypeError('Observer.complete is not a function');\n                    }\n                }\n                else if (cleanUpError) {\n                    throw cleanUpError;\n                }\n            }\n        }\n        var subscription = Object.create(Object.create({}, {\n            'closed': {\n                enumerable: false,\n                configurable: true,\n                get: function () {\n                    return closed;\n                }\n            },\n            'unsubscribe': {\n                enumerable: false,\n                configurable: true,\n                writable: true,\n                value: unsubscribe\n            }\n        }));\n        var prototype = Object.create({}, {\n            'next': {\n                enumerable: false,\n                writable: true,\n                value: next,\n                configurable: true\n            },\n            'error': {\n                enumerable: false,\n                writable: true,\n                value: error,\n                configurable: true\n            },\n            'complete': {\n                enumerable: false,\n                writable: true,\n                value: complete,\n                configurable: true\n            },\n            'closed': {\n                enumerable: false,\n                configurable: true,\n                get: function () {\n                    return closed;\n                }\n            }\n        });\n        // create the SubscriptionObserver and kick things off\n        start(Object.create(prototype));\n        // the ONLY way to control the SubscriptionObserver is with the subscription or from a subscriber\n        return subscription;\n    }\n    var ShimObservable = (function () {\n        function ShimObservable(subscriber) {\n            if (typeof subscriber !== 'function') {\n                throw new TypeError('subscriber is not a function');\n            }\n            this._executor = subscriber;\n        }\n        ShimObservable.prototype[_a = Symbol.observable] = function () {\n            return this;\n        };\n        ShimObservable.prototype.subscribe = function (observerOrNext) {\n            var listeners = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                listeners[_i - 1] = arguments[_i];\n            }\n            var _a = listeners.slice(), onError = _a[0], onComplete = _a[1];\n            if (!observerOrNext || typeof observerOrNext === 'number' || typeof observerOrNext === 'string' || typeof observerOrNext === 'boolean') {\n                throw new TypeError('parameter must be a function or an observer');\n            }\n            var observer;\n            if (typeof observerOrNext === 'function') {\n                observer = {\n                    next: observerOrNext\n                };\n                if (typeof onError === 'function') {\n                    observer.error = onError;\n                }\n                if (typeof onComplete === 'function') {\n                    observer.complete = onComplete;\n                }\n            }\n            else {\n                observer = observerOrNext;\n            }\n            return startSubscription(this._executor, observer);\n        };\n        ShimObservable.of = function () {\n            var items = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                items[_i] = arguments[_i];\n            }\n            var constructor;\n            if (typeof this !== 'function') {\n                constructor = ShimObservable;\n            }\n            else {\n                constructor = this;\n            }\n            return new constructor(function (observer) {\n                iterator_1.forOf(items, function (o) {\n                    observer.next(o);\n                });\n                observer.complete();\n            });\n        };\n        ShimObservable.from = function (item) {\n            if (item === null || item === undefined) {\n                throw new TypeError('item cannot be null or undefined');\n            }\n            var constructor;\n            if (typeof this !== 'function') {\n                constructor = ShimObservable;\n            }\n            else {\n                constructor = this;\n            }\n            var observableSymbol = item[Symbol.observable];\n            if (observableSymbol !== undefined) {\n                if (typeof observableSymbol !== 'function') {\n                    throw new TypeError('Symbol.observable must be a function');\n                }\n                var result = observableSymbol.call(item);\n                if (result === undefined || result === null || typeof result === 'number' || typeof result === 'boolean' || typeof result === 'string') {\n                    throw new TypeError('Return value of Symbol.observable must be object');\n                }\n                if (result.constructor && result.constructor === this || result instanceof ShimObservable) {\n                    return result;\n                }\n                else if (result.subscribe) {\n                    return new constructor(result.subscribe);\n                }\n                else {\n                    if (constructor.of) {\n                        return constructor.of(result);\n                    }\n                    else {\n                        return ShimObservable.of(result);\n                    }\n                }\n            }\n            else if (iterator_1.isIterable(item) || iterator_1.isArrayLike(item)) {\n                return new constructor(function (observer) {\n                    iterator_1.forOf(item, function (o) {\n                        observer.next(o);\n                    });\n                    observer.complete();\n                });\n            }\n            else {\n                throw new TypeError('Parameter is neither Observable nor Iterable');\n            }\n        };\n        return ShimObservable;\n    }());\n    __decorate([\n        nonEnumerable\n    ], ShimObservable.prototype, _a, null);\n    __decorate([\n        nonEnumerable\n    ], ShimObservable.prototype, \"subscribe\", null);\n    __decorate([\n        nonEnumerable\n    ], ShimObservable, \"of\", null);\n    __decorate([\n        nonEnumerable\n    ], ShimObservable, \"from\", null);\n    Shim.ShimObservable = ShimObservable;\n    var _a;\n})(Shim || (Shim = {}));\nvar Observable = (function () {\n    /* istanbul ignore next */\n    /**\n     * Create a new observerable with a subscriber function. The subscriber function will get called with a\n     * SubscriptionObserver parameter for controlling the subscription.  I a function is returned, it will be\n     * run when the subscription is complete.\n     *\n     * @param {Subscriber<T>} subscriber    The subscription function to be called when observers are subscribed\n     *\n     * @example\n     * const source = new Observer<number>((observer) => {\n     *     observer.next(1);\n     *     observer.next(2);\n     *     observer.next(3);\n     * });\n     */\n    function Observable(subscriber) {\n    }\n    /* istanbul ignore next */\n    Observable.prototype.subscribe = function (observerOrNext, onError, onComplete) {\n        throw new Error();\n    };\n    /* istanbul ignore next */\n    /**\n     * Create an Observable from a list of values.\n     *\n     * @param {...T} items The values to be emitted\n     *\n     * @return {Observable<T>}    An Observable that will emit the specified values\n     *\n     * @example\n     *\n     * let source = Observable.of(1, 2, 3);\n     *\n     * // will emit three separate values, 1, 2, and 3.\n     */\n    Observable.of = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        throw new Error();\n    };\n    /* istanbul ignore next */\n    /**\n     * Create an Observable from another object. If the object is in itself Observable, the object will be returned.\n     * Otherwise, the value will be wrapped in an Observable. If the object is iterable, an Observable will be created\n     * that emits each item of the iterable.\n     *\n     * @param {Iterable<T> | ArrayLike<T> | ObservableObject} item The item to be turned into an Observable\n     *\n     * @return {Observable<T>}    An observable for the item you passed in\n     */\n    Observable.from = function (item) {\n        throw new Error();\n    };\n    /* istanbul ignore next */\n    Observable.prototype[Symbol.observable] = function () {\n        throw new Error();\n    };\n    return Observable;\n}());\nObservable = __decorate([\n    decorators_1.hasClass('es-observable', global_1.default.Observable, Shim.ShimObservable)\n], Observable);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Observable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/Observable.js\n// module id = 46\n// module chunks = 0","\"use strict\";\nvar utils_1 = require(\"../utils\");\nvar createOperation_1 = require(\"./createOperation\");\nvar createJsonPointer_1 = require(\"./createJsonPointer\");\nfunction _diff(to, from, startingPath) {\n    if (!utils_1.shouldRecurseInto(from) || !utils_1.shouldRecurseInto(to)) {\n        return [];\n    }\n    var path = startingPath || createJsonPointer_1.default();\n    var fromKeys = Object.keys(from);\n    var toKeys = Object.keys(to);\n    var operations = [];\n    fromKeys.forEach(function (key) {\n        if (!utils_1.isEqual(from[key], to[key])) {\n            if ((key in from) && !(key in to)) {\n                operations.push(createOperation_1.default(1 /* Remove */, path.push(key)));\n            }\n            else if (utils_1.shouldRecurseInto(from[key]) && utils_1.shouldRecurseInto(to[key])) {\n                operations.push.apply(operations, _diff(to[key], from[key], path.push(key)));\n            }\n            else {\n                operations.push(createOperation_1.default(2 /* Replace */, path.push(key), to[key], undefined, from[key]));\n            }\n        }\n    });\n    toKeys.forEach(function (key) {\n        if (!(key in from) && (key in to)) {\n            operations.push(createOperation_1.default(0 /* Add */, path.push(key), to[key]));\n        }\n    });\n    return operations;\n}\nfunction diff(to, from) {\n    if (from === void 0) { from = {}; }\n    return createPatch(_diff(to, from));\n}\nexports.diff = diff;\nfunction createPatch(operations) {\n    return {\n        operations: operations,\n        apply: function (target) {\n            return this.operations.reduce(function (prev, next) { return next.apply(prev); }, target);\n        },\n        toString: function () {\n            return '[' + this.operations.reduce(function (prev, next) {\n                if (prev) {\n                    return prev + ',' + next.toString();\n                }\n                else {\n                    return next.toString();\n                }\n            }, '') + ']';\n        }\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createPatch;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/patch/createPatch.js\n// module id = 47\n// module chunks = 0","\"use strict\";\nfunction shouldRecurseInto(value) {\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\nexports.shouldRecurseInto = shouldRecurseInto;\nfunction isEqual(a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return a.length === b.length && a.every(function (element, i) { return isEqual(element, b[i]); });\n    }\n    else if (shouldRecurseInto(a) && shouldRecurseInto(b)) {\n        var keysForA = Object.keys(a).sort();\n        var keysforB = Object.keys(b).sort();\n        return isEqual(keysForA, keysforB) && keysForA.every(function (key) { return isEqual(a[key], b[key]); });\n    }\n    else {\n        return a === b;\n    }\n}\nexports.isEqual = isEqual;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/utils.js\n// module id = 48\n// module chunks = 0","\"use strict\";\nvar utils_1 = require(\"../utils\");\nvar createJsonPointer_1 = require(\"./createJsonPointer\");\nfunction navigatePath(target, path) {\n    var currentPath = '';\n    var lastSegment = '';\n    var pathSegments = path.segments();\n    pathSegments.forEach(function (segment, index) {\n        currentPath += \"/\" + segment;\n        if (!target) {\n            throw new Error(\"Invalid path: \" + currentPath + \" doesn't exist in target\");\n        }\n        else if (index + 1 < pathSegments.length) {\n            target = target[segment];\n        }\n        else {\n            lastSegment = segment;\n        }\n    });\n    return {\n        object: target,\n        property: lastSegment\n    };\n}\nfunction add(target) {\n    var applyTo = navigatePath(target, this.path);\n    applyTo.object[applyTo.property] = this.value;\n    return target;\n}\nfunction remove(target) {\n    var applyTo = navigatePath(target, this.path);\n    delete applyTo.object[applyTo.property];\n    return target;\n}\nfunction replace(target) {\n    var applyTo = navigatePath(target, this.path);\n    if (!(applyTo.property in applyTo.object)) {\n        throw new Error(\"Cannot replace undefined path: \" + this.path.toString() + \" on object\");\n    }\n    applyTo.object[applyTo.property] = this.value;\n    return target;\n}\nfunction copyOrMove(from, to, target, toDelete) {\n    var moveFrom = navigatePath(target, from);\n    if (!(moveFrom.property in moveFrom.object)) {\n        throw new Error(\"Cannot move from undefined path: \" + from.toString() + \" on object\");\n    }\n    var applyTo = navigatePath(target, to);\n    applyTo.object[applyTo.property] = moveFrom.object[moveFrom.property];\n    if (toDelete) {\n        delete moveFrom.object[moveFrom.property];\n    }\n}\nfunction move(target) {\n    copyOrMove(this.from, this.path, target, true);\n    return target;\n}\nfunction copy(target) {\n    copyOrMove(this.from, this.path, target, false);\n    return target;\n}\nfunction test(target) {\n    var applyTo = navigatePath(target, this.path);\n    return utils_1.isEqual(applyTo.object[applyTo.property], this.value);\n}\nfunction getPath(path) {\n    if (Array.isArray(path)) {\n        return createJsonPointer_1.default.apply(void 0, path);\n    }\n    else {\n        return path;\n    }\n}\nfunction toString() {\n    var jsonObj = {};\n    jsonObj.op = this.op;\n    jsonObj.path = this.path.toString();\n    if (this.value) {\n        jsonObj.value = this.value;\n    }\n    if (this.from) {\n        jsonObj.from = this.from.toString();\n    }\n    return JSON.stringify(jsonObj);\n}\nfunction createOperation(type, path, value, from, oldValue) {\n    switch (type) {\n        case 0 /* Add */:\n            return {\n                op: 'add',\n                path: getPath(path),\n                value: value,\n                apply: add,\n                toString: toString\n            };\n        case 1 /* Remove */:\n            return {\n                op: 'remove',\n                path: getPath(path),\n                apply: remove,\n                toString: toString\n            };\n        case 2 /* Replace */:\n            return {\n                op: 'replace',\n                path: getPath(path),\n                value: value,\n                oldValue: oldValue,\n                apply: replace,\n                toString: toString\n            };\n        case 4 /* Move */:\n            if (!from) {\n                throw new Error('From value is required for Move operations');\n            }\n            return {\n                op: 'move',\n                path: getPath(path),\n                from: getPath(from),\n                apply: move,\n                toString: toString\n            };\n        case 3 /* Copy */:\n            if (!from) {\n                throw new Error('From value is required in Copy operation');\n            }\n            return {\n                op: 'copy',\n                path: getPath(path),\n                from: getPath(from),\n                apply: copy,\n                toString: toString\n            };\n        case 5 /* Test */:\n            return {\n                op: 'test',\n                path: getPath(path),\n                value: value,\n                apply: test,\n                toString: toString\n            };\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createOperation;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/patch/createOperation.js\n// module id = 49\n// module chunks = 0","\"use strict\";\nfunction navigate(path, target) {\n    return path.segments().reduce(function (prev, next) {\n        return prev ? prev[next] : prev;\n    }, target);\n}\nexports.navigate = navigate;\nfunction decode(segment) {\n    return segment.replace(/~1/g, '/').replace(/~0/g, '~');\n}\nfunction encode(segment) {\n    return segment.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\nfunction toString() {\n    var segments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        segments[_i] = arguments[_i];\n    }\n    return segments.reduce(function (prev, next) {\n        return prev + '/' + encode(next);\n    });\n}\nfunction createJsonPointer() {\n    var segments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        segments[_i] = arguments[_i];\n    }\n    return {\n        segments: function () {\n            return segments.map(function (segment) { return decode(segment); });\n        }, toString: function () {\n            return toString.apply(void 0, segments);\n        },\n        push: function (segment) {\n            return createJsonPointer.apply(void 0, segments.concat(segment));\n        },\n        pop: function () {\n            return createJsonPointer.apply(void 0, segments.slice(0, segments.length - 1));\n        }\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createJsonPointer;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/patch/createJsonPointer.js\n// module id = 50\n// module chunks = 0","\"use strict\";\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar global_1 = require(\"@dojo/core/global\");\nglobal_1.default.Rx = { config: { Promise: Promise_1.default } };\nfunction createStoreObservable(observable, transform) {\n    // Cast to any because the signatures of catch between the Observable and Promise interfaces are not\n    // compatible\n    var storeObservable = observable;\n    storeObservable.then = function (onFulfilled, onRejected) {\n        // Wrap in a shim promise because the interface that leaks through observable.toPromise is missing some\n        // properties on the shim(e.g. promise)\n        return Promise_1.default.resolve(observable.toPromise())\n            .then(transform)\n            .then(onFulfilled, onRejected);\n    };\n    storeObservable.catch = function (onRejected) {\n        return observable.toPromise().then(transform).then(undefined, onRejected);\n    };\n    return storeObservable;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createStoreObservable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/store/createStoreObservable.js\n// module id = 51\n// module chunks = 0","\"use strict\";\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar Map_1 = require(\"@dojo/shim/Map\");\nvar lang_1 = require(\"@dojo/core/lang\");\nvar uuid_1 = require(\"@dojo/core/uuid\");\nvar instanceStateMap = new WeakMap_1.default();\nfunction putSync(instance, items, options) {\n    var state = instanceStateMap.get(instance);\n    var ids = instance.identify(items);\n    var updatedItems = [];\n    var oldIndices = [];\n    var newIds = [];\n    var newItems = [];\n    ids.forEach(function (id, index) {\n        var oldIndex = state.index.get(id);\n        if (typeof oldIndex === 'undefined') {\n            newIds.push(id);\n            newItems.push(items[index]);\n        }\n        else {\n            updatedItems.push(items[index]);\n            oldIndices.push(oldIndex);\n        }\n    });\n    if (oldIndices.length && options && options.rejectOverwrite) {\n        throw Error('Objects already exist in store');\n    }\n    var data = state.data;\n    updatedItems.forEach(function (item, index) {\n        data[oldIndices[index]] = item;\n    });\n    newItems.forEach(function (item, index) {\n        state.index.set(newIds[index], data.push(item) - 1);\n    });\n    return {\n        successfulData: items,\n        type: 1 /* Put */\n    };\n}\nvar createInMemoryStorage = compose_1.default({\n    identify: function (items) {\n        var state = instanceStateMap.get(this);\n        var itemArray = Array.isArray(items) ? items : [items];\n        if (state.idProperty) {\n            var idProperty_1 = state.idProperty;\n            return itemArray.map(function (item) {\n                return item[idProperty_1];\n            });\n        }\n        else if (state.idFunction) {\n            return itemArray.map(state.idFunction);\n        }\n        else {\n            return itemArray.map(function (item) {\n                return item.id;\n            });\n        }\n    },\n    createId: function () {\n        return Promise_1.default.resolve(uuid_1.default());\n    },\n    fetch: function (query) {\n        var state = instanceStateMap.get(this);\n        var fullData = state.data;\n        var data = (query ? query.apply(fullData) : fullData).slice();\n        var returnPromise = state.returnsPromise.then(function () { return data; });\n        state.returnsPromise = returnPromise;\n        returnPromise.totalLength = returnPromise.dataLength = Promise_1.default.resolve(fullData.length);\n        return returnPromise;\n    },\n    get: function (ids) {\n        var state = instanceStateMap.get(this);\n        var data = state.data;\n        var objects = [];\n        return Promise_1.default.resolve(ids.reduce(function (prev, next) {\n            return state.index.has(next) ? prev.concat(data[state.index.get(next)]) : prev;\n        }, objects));\n    },\n    put: function (items, options) {\n        var state = instanceStateMap.get(this);\n        try {\n            var result_1 = putSync(this, items, options);\n            // Don't control the order operations are executed in, but make sure that the results\n            // resolve in the order they were actually executed in.\n            var returnPromise = state.returnsPromise.then(function () { return result_1; });\n            state.returnsPromise = returnPromise;\n            return returnPromise;\n        }\n        catch (error) {\n            return Promise_1.default.reject(error);\n        }\n    },\n    add: function (items, options) {\n        options = options || {};\n        var state = instanceStateMap.get(this);\n        if (typeof options.rejectOverwrite === 'undefined') {\n            options.rejectOverwrite = true;\n        }\n        try {\n            var result_2 = putSync(this, items, options);\n            // Don't control the order operations are executed in, but make sure that the results\n            // resolve in the order they were actually executed in.\n            var returnPromise = state.returnsPromise.then(function () {\n                result_2.type = 0 /* Add */;\n                return result_2;\n            });\n            state.returnsPromise = returnPromise;\n            return returnPromise;\n        }\n        catch (error) {\n            return Promise_1.default.reject(error);\n        }\n    },\n    delete: function (ids) {\n        var state = instanceStateMap.get(this);\n        var data = state.data;\n        var idsToRemove = ids.filter(function (id) {\n            return state.index.has(id);\n        });\n        var indices = idsToRemove\n            .map(function (id) {\n            return state.index.get(id);\n        })\n            .sort();\n        idsToRemove.forEach(function (id) {\n            state.index.delete(id);\n        });\n        indices.forEach(function (index, indexArrayIndex) {\n            return data.splice(index - indexArrayIndex, 1);\n        });\n        if (indices.length) {\n            var firstInvalidIndex_1 = indices[0];\n            var updateIndexForIds = this.identify(data.slice(firstInvalidIndex_1));\n            updateIndexForIds.forEach(function (id, index) {\n                state.index.set(id, index + firstInvalidIndex_1);\n            });\n        }\n        // Don't control the order operations are executed in, but make sure that the results\n        // resolve in the order they were actually executed in.\n        var returnPromise = state.returnsPromise.then(function () { return ({\n            successfulData: idsToRemove,\n            type: 3 /* Delete */\n        }); });\n        state.returnsPromise = returnPromise;\n        return returnPromise;\n    },\n    patch: function (updates) {\n        var state = instanceStateMap.get(this);\n        var data = state.data;\n        var filteredUpdates = updates.filter(function (update) {\n            return state.index.has(update.id);\n        });\n        var oldIndices = filteredUpdates.map(function (update) {\n            return state.index.get(update.id);\n        });\n        try {\n            var updatedItems_1 = filteredUpdates.map(function (update, index) {\n                var item = lang_1.duplicate(data[oldIndices[index]]);\n                var updatedItem = update.patch.apply(item);\n                data[oldIndices[index]] = updatedItem;\n                return updatedItem;\n            });\n            // Don't control the order operations are executed in, but make sure that the results\n            // resolve in the order they were actually executed in.\n            var returnsPromise = state.returnsPromise.then(function () { return ({\n                successfulData: updatedItems_1,\n                type: 2 /* Patch */\n            }); });\n            state.returnsPromise = returnsPromise;\n            return returnsPromise;\n        }\n        catch (error) {\n            return Promise_1.default.reject(error);\n        }\n    },\n    isUpdate: function (item) {\n        var state = instanceStateMap.get(this);\n        var id = this.identify([item])[0];\n        var isUpdate = state.index.has(id);\n        return Promise_1.default.resolve({\n            id: id,\n            item: item,\n            isUpdate: isUpdate\n        });\n    }\n}, function (instance, options) {\n    options = options || {};\n    instanceStateMap.set(instance, {\n        data: [],\n        index: new Map_1.default(),\n        idProperty: options.idProperty,\n        idFunction: options.idFunction,\n        returnsPromise: Promise_1.default.resolve()\n    });\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createInMemoryStorage;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/storage/createInMemoryStorage.js\n// module id = 52\n// module chunks = 0","\"use strict\";\n/**\n * Returns a v4 compliant UUID.\n *\n * @returns {string}\n */\nfunction uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = uuid;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/uuid.js\n// module id = 53\n// module chunks = 0","\"use strict\";\nvar createStore_1 = require(\"../createStore\");\nvar Observable_1 = require(\"@dojo/core/Observable\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar Map_1 = require(\"@dojo/shim/Map\");\nvar Set_1 = require(\"@dojo/shim/Set\");\nvar aspect_1 = require(\"@dojo/compose/aspect\");\nvar util_1 = require(\"@dojo/core/util\");\n/**\n * Combines several sequential deltas into a single delta.\n * It performs several checks to remove redundant data.\n * \t- Checks for repeated copies items with the same ID in\n * \tadds and updates, or just the same ID in deletes, and keeps\n * \tonly the last.\n * \t- Checks for deletes followed by adds or updates and replaces with a\n * \tsingle update\n * \t- Checks for adds followed by deletes and removes both\n * \t- Checks for updates followed by deletes and removes the update\n * @param instance The instance that can identify these items\n * @param currentUpdate The current store delta\n * @param newUpdate The new update to merge\n * @returns The merged delta\n */\nfunction mergeDeltas(instance, currentUpdate, newUpdate) {\n    /**\n     * Takes the last instance of an item repeated in the list\n     * @param items Added or updated items\n     * @returns The added or updated items with repeated items replaced by only the latest version of the item\n     */\n    function takeLastItem(items) {\n        var found = {};\n        var ids = instance.identify(items);\n        return items.reverse().filter(function (_, index) {\n            var id = ids[index];\n            var exists = Boolean(found[id]);\n            found[id] = true;\n            return !exists;\n        }).reverse();\n    }\n    /**\n     * Takes the last instance of an id repeated in the list\n     * @param ids IDs of deleted items\n     * @returns The list with duplicates removed\n     */\n    function takeLastId(ids) {\n        var found = {};\n        return ids.reverse().filter(function (id) {\n            var exists = Boolean(found[id]);\n            found[id] = true;\n            return !exists;\n        }).reverse();\n    }\n    /**\n     * Removes updates for items that were later deleted\n     * @param newDeletes Deletes from delta(s) after the updates\n     * @param oldUpdates Updates from delta(s) before the deletes\n     * @return The updates without updates for subsequently deleted items\n     */\n    function removeOutdatedItems(newDeletes, oldUpdates) {\n        var deletedIds = newDeletes.reduce(function (prev, next) {\n            prev.set(next, null);\n            return prev;\n        }, new Map_1.default());\n        var ids = instance.identify(oldUpdates);\n        return oldUpdates.filter(function (_, index) {\n            return !deletedIds.has(ids[index]);\n        });\n    }\n    /**\n     * Finds cases where an older update has an add, and a newer update has a delete, and removes\n     * both, since the net effect is that the operations are cancelled out\n     * @param newDeletes Deletes form delta(s) after the adds\n     * @param oldAdds Adds from delta(s) before the deletes\n     * @returns An object with the filtered adds and deletes\n     */\n    function removeCancellingUpdates(newDeletes, oldAdds) {\n        var deletedIds = newDeletes.reduce(function (prev, next) {\n            prev.set(next, null);\n            return prev;\n        }, new Map_1.default());\n        var ids = instance.identify(oldAdds);\n        var addIds = ids.reduce(function (prev, next) {\n            prev.set(next, null);\n            return prev;\n        }, new Map_1.default());\n        return {\n            oldAdds: oldAdds.filter(function (_, index) {\n                return !deletedIds.has(ids[index]);\n            }),\n            newDeletes: newDeletes.filter(function (id) { return !addIds.has(id); })\n        };\n    }\n    /**\n     * Finds places where an item was deleted and then added or updated, and removes the delete. If the item was added,\n     * the add is also replaced with an update since it should already exist in the collection receiving the updates,\n     * as it will never receive the delete\n     * @param oldDeletes - Deletes from delta(s) before the adds and updates\n     * @param newAdds - Adds from delta(s) after the deletes\n     * @param newUpdates - Updates from delta(s) after the deletes\n     * @returns An object containing the updated deletes, adds, and updates\n     */\n    function convertReplacementToUpdate(oldDeletes, newAdds, newUpdates) {\n        var deletes = oldDeletes.reduce(function (prev, next) {\n            prev.set(next, null);\n            return prev;\n        }, new Map_1.default());\n        var addIds = instance.identify(newAdds);\n        var updateIds = instance.identify(newUpdates);\n        var adds = addIds.concat(updateIds).reduce(function (prev, next) {\n            prev.set(next, null);\n            return prev;\n        }, new Map_1.default());\n        var updatedUpdates = newUpdates.slice();\n        return {\n            oldDeletes: oldDeletes.filter(function (id) { return !adds.has(id); }),\n            newAdds: newAdds.filter(function (item, index) {\n                var shouldKeep = !deletes.has(addIds[index]);\n                if (!shouldKeep) {\n                    // Always add it to the beginning, because it may have been updated as well, but the add\n                    // has to have come first.\n                    updatedUpdates.unshift(item);\n                }\n                return shouldKeep;\n            }),\n            newUpdates: updatedUpdates\n        };\n    }\n    var _a = convertReplacementToUpdate(currentUpdate.deletes, newUpdate.adds, newUpdate.updates), oldDeletes = _a.oldDeletes, newAdds = _a.newAdds, newUpdates = _a.newUpdates;\n    var oldUpdates = removeOutdatedItems(newUpdate.deletes, currentUpdate.updates);\n    var _b = removeCancellingUpdates(newUpdate.deletes, currentUpdate.adds), newDeletes = _b.newDeletes, oldAdds = _b.oldAdds;\n    return {\n        updates: takeLastItem(oldUpdates.concat(newUpdates)),\n        adds: takeLastItem(oldAdds.concat(newAdds)),\n        deletes: takeLastId(oldDeletes.concat(newDeletes)),\n        beforeAll: currentUpdate.beforeAll,\n        afterAll: newUpdate.afterAll\n    };\n}\nexports.mergeDeltas = mergeDeltas;\nvar instanceStateMap = new WeakMap_1.default();\n/**\n * Takes a collection of items and creates a new copy modified according to the provided updates. This can be used to\n * attempt to track updates in the local collection when fetching after each update is disabled.\n * @param store\n * @param state\n * @param data\n * @param update\n * @returns A new collection with the modifications specified by the update\n */\nfunction addUpdateDelete(store, state, data, update) {\n    var newData = data.slice();\n    update.adds.forEach(function (item) {\n        newData.push(item);\n    });\n    store.identify(update.updates).forEach(function (id, index) {\n        if (state.localIndex.has(id)) {\n            newData[state.localIndex.get(id)] = update.updates[index];\n        }\n        else {\n            newData.push(update.updates[index]);\n        }\n    });\n    update.deletes.sort().reverse().forEach(function (id) {\n        if (state.localIndex.has(id)) {\n            newData.splice(state.localIndex.get(id), 1);\n        }\n    });\n    return newData;\n}\n/**\n * Build a map of ids to indices for the provided collection. This requires that the array of IDs is either what\n * the index if for, or that the array of items the IDs represent is in the same order, which is already the case\n * if the IDs were generated using the Store's identify function.\n * @param ids - The IDS to build the index for\n * @returns An index mapping ids to indices\n */\nfunction buildIndex(ids) {\n    return ids.reduce(function (map, id, index) {\n        map.set(id, index);\n        return map;\n    }, new Map_1.default());\n}\nexports.buildIndex = buildIndex;\n/**\n * Merges the latest queued updates, updates the local data and index based on the latest data,\n * sends out updates to observers, and then removes observers that unsubscribed during the update process from the list\n * of observers. If after is provided, it is assumed that that is the latest data for the store, if it is not provided\n * the local data is updated according to the merged delta and that is used as the new local data.\n * @param store\n * @param after - Optional array of items containing the latest data for the store.\n */\nfunction sendUpdates(store, after) {\n    var state = instanceStateMap.get(store);\n    var storeDelta = state.queuedUpdate || {\n        updates: [],\n        adds: [],\n        deletes: [],\n        beforeAll: [],\n        afterAll: []\n    };\n    state.queuedUpdate = undefined;\n    after = after || addUpdateDelete(store, state, state.localData, storeDelta);\n    storeDelta.beforeAll = state.localData;\n    storeDelta.afterAll = after;\n    state.localData = after;\n    state.localIndex = buildIndex(store.identify(after));\n    state.observers.forEach(function (observer) {\n        observer.next({\n            updates: storeDelta.updates.slice(),\n            adds: storeDelta.adds.slice(),\n            deletes: storeDelta.deletes.slice(),\n            beforeAll: storeDelta.beforeAll.slice(),\n            afterAll: storeDelta.afterAll.slice()\n        });\n    });\n}\n/**\n * Determines whether this is a single observer or a set entry\n * @param observer\n * @returns {boolean}\n */\nfunction isObserverEntry(observer) {\n    return observer.observes instanceof Set_1.default;\n}\n/**\n * Determines whether this is a single observer or a set entry\n * @param observer\n * @returns {boolean}\n */\nfunction isObserver(observer) {\n    return !isObserverEntry(observer);\n}\n/**\n * Iterates through the provided items and/or IDs and notifies observers. If items is provided, then the\n * observers for that item, and the observers for sets of items that include that are updated. If items is null, then\n * these are delete notifications for observers of multiple items. In this case, no update is sent to individual\n * observers, and observers of sets receive `ItemUpdate` objects with the IDs of the deleted items and an undefined item\n *\n * @param items Items to send updates for, or null if these are delete notifications for item set observers\n * @param ids - IDs of the items, should be in the same order as items\n * @param state\n * @param store\n */\nfunction notifyItemObservers(items, ids, state, store) {\n    function notify(id, after) {\n        if (state.itemObservers.has(id)) {\n            state.itemObservers.get(id).map(function (observerOrEntry) {\n                if (isObserverEntry(observerOrEntry)) {\n                    return observerOrEntry.observer;\n                }\n                else {\n                    return null;\n                }\n            }).filter(function (observerEntry) {\n                return observerEntry;\n            }).forEach(function (observer) {\n                observer.next({\n                    item: after,\n                    id: id\n                });\n            });\n            if (after) {\n                state.itemObservers.get(id).map(function (observerOrEntry) {\n                    if (isObserver(observerOrEntry)) {\n                        return observerOrEntry;\n                    }\n                    else {\n                        return null;\n                    }\n                }).filter(function (observer) {\n                    return observer;\n                }).forEach(function (observer) {\n                    observer.next(after);\n                });\n            }\n        }\n    }\n    if (items) {\n        items.forEach(function (after, index) {\n            var id = ids[index] || store.identify(after);\n            notify(id, after);\n        });\n    }\n    else {\n        ids.forEach(function (id) {\n            notify(id, undefined);\n        });\n    }\n}\n/**\n * Queues the appropriate update and then either starts up a fetch or just triggers sending the updates depending\n * on the `fetchAroundUpdates` property\n * @param state\n * @param store\n * @param updates Updated items\n * @param adds Added items\n * @param deletes Deleted IDs\n */\nfunction sendUpdatesOrFetch(state, store, updates, adds, deletes) {\n    var newUpdate = {\n        updates: updates,\n        adds: adds,\n        deletes: deletes,\n        beforeAll: [],\n        afterAll: []\n    };\n    state.queuedUpdate = state.queuedUpdate ? mergeDeltas(store, state.queuedUpdate, newUpdate) : newUpdate;\n    if (state.fetchAroundUpdates) {\n        state.fetchAndSendUpdates(store);\n    }\n    else {\n        sendUpdates(store);\n    }\n}\nfunction createObservableStoreMixin() {\n    return {\n        mixin: {\n            observe: function (idOrIds) {\n                if (idOrIds) {\n                    var self_1 = this;\n                    var state_1 = instanceStateMap.get(self_1);\n                    if (Array.isArray(idOrIds)) {\n                        var ids_1 = idOrIds;\n                        var idSet_1 = new Set_1.default(ids_1);\n                        var observable = new Observable_1.Observable(function subscribe(observer) {\n                            var observerEntry = {\n                                observes: idSet_1,\n                                observer: observer\n                            };\n                            ids_1.forEach(function (id) {\n                                if (state_1.itemObservers.has(id)) {\n                                    state_1.itemObservers.get(id).push(observerEntry);\n                                }\n                                else {\n                                    state_1.itemObservers.set(id, [observerEntry]);\n                                }\n                            });\n                            var foundIds = new Set_1.default();\n                            observer.next = aspect_1.after(observer.next, function (result, itemUpdate) {\n                                foundIds.add(itemUpdate.id);\n                                return result;\n                            });\n                            self_1.get(ids_1).then(function (items) {\n                                if (foundIds.size !== ids_1.length) {\n                                    var retrievedIdSet_1 = new Set_1.default(self_1.identify(items));\n                                    var missingItemIds = ids_1.filter(function (id) { return !retrievedIdSet_1.has(id); });\n                                    if (retrievedIdSet_1.size !== idSet_1.size || missingItemIds.length) {\n                                        observer.error(new Error(\"ID(s) \\\"\" + missingItemIds + \"\\\" not found in store\"));\n                                    }\n                                    else {\n                                        items.forEach(function (item, index) { return observer.next({\n                                            item: item,\n                                            id: ids_1[index]\n                                        }); });\n                                    }\n                                }\n                            });\n                        });\n                        return observable;\n                    }\n                    else {\n                        var id_1 = idOrIds;\n                        return new Observable_1.Observable(function subscribe(observer) {\n                            self_1.get(id_1).then(function (item) {\n                                if (!item) {\n                                    observer.error(new Error(\"ID \\\"\" + id_1 + \"\\\" not found in store\"));\n                                }\n                                else {\n                                    if (state_1.itemObservers.has(id_1)) {\n                                        state_1.itemObservers.get(id_1).push(observer);\n                                    }\n                                    else {\n                                        state_1.itemObservers.set(id_1, [observer]);\n                                    }\n                                    observer.next(item);\n                                }\n                            });\n                        });\n                    }\n                }\n                else {\n                    return instanceStateMap.get(this).storeObservable;\n                }\n            }\n        },\n        aspectAdvice: {\n            after: {\n                /**\n                 * After fetching, sends updates if no query was used. If a custom query was used then the data retrieved\n                 * is not indicative of the local data and can't be used. We shouldn't apply the query locally because we\n                 * have no knowledge of the underlying storage implementation or the amount of data and it may be too much\n                 * data to retrieve or update in memory. If this is the initialFetch, don't update since that update\n                 * will be sent to each subscriber at the time of subscription. If we're not sending updates, still set\n                 * the local data and index to the newly retrieved data.\n                 * @param result\n                 * @param query\n                 * @returns {Promise<T[]>}\n                 */\n                fetch: function (result, query) {\n                    var _this = this;\n                    if (!query) {\n                        result.then(function (data) {\n                            var state = instanceStateMap.get(_this);\n                            if (result !== state.initialFetch) {\n                                sendUpdates(_this, data);\n                            }\n                            else {\n                                state.localData = data;\n                                state.localIndex = buildIndex(_this.identify(data));\n                            }\n                        }, \n                        // Ignore errors here, they should be handled by the caller not observers\n                        function () { });\n                    }\n                    return result;\n                },\n                /**\n                 * After the put is completed, notify the item observers, and then either queue a fetch to send updates\n                 * if fetchAroundUpdates is true, or just send updates if not.\n                 * @param result\n                 * @returns {StoreObservable<T, any>}\n                 */\n                put: function (result) {\n                    var _this = this;\n                    result.then(function (updatedItems) {\n                        var state = instanceStateMap.get(_this);\n                        notifyItemObservers(updatedItems, [], state, _this);\n                        sendUpdatesOrFetch(state, _this, updatedItems, [], []);\n                    }, \n                    // Ignore errors here, they should be handled by the caller not observers\n                    function () { });\n                    return result;\n                },\n                /**\n                 * After the patch is completed, notify the item observers, and then either queue a fetch to send updates\n                 * if fetchAroundUpdates is true, or just send updates if not.\n                 * @param result\n                 * @returns {StoreObservable<T, any>}\n                 */\n                patch: function (result) {\n                    var _this = this;\n                    result.then(function (updatedItems) {\n                        var state = instanceStateMap.get(_this);\n                        notifyItemObservers(updatedItems, [], state, _this);\n                        sendUpdatesOrFetch(state, _this, updatedItems, [], []);\n                    }, \n                    // Ignore errors here, they should be handled by the caller not observers\n                    function () { });\n                    return result;\n                },\n                /**\n                 * After the add is completed notify observers. If this is the initial add AND we are fetching around\n                 * updates, then the first update to subscribers will already contain this data, since the initial fetch\n                 * is performed after the initial add. In this case we do not need to send an update. We can tell this\n                 * is the first add because it'll be triggered in the createStore base before the state is created for\n                 * this instance in the mixin's initializer\n                 * @param result\n                 * @returns {StoreObservable<T, U>}\n                 */\n                add: function (result) {\n                    var _this = this;\n                    var isFirstAdd = !instanceStateMap.get(this);\n                    result.then(function (addedItems) {\n                        var state = instanceStateMap.get(_this);\n                        if (!isFirstAdd || !state.fetchAroundUpdates) {\n                            sendUpdatesOrFetch(state, _this, [], addedItems, []);\n                        }\n                    }, \n                    // Ignore errors here, they should be handled by the caller not observers\n                    function () { });\n                    return result;\n                },\n                /**\n                 * After the items are deleted, notify item set observers of the deletion of one of the items they are\n                 * observing, and then complete any observables that need to be completed.\n                 * Completing observables is dones as follows\n                 * \t- For observers of a single item, just complete the observer\n                 * \t- For observers of a set of items\n                 * \t\t- Remove the deleted ID of this item from the set of observed IDs\n                 * \t\t- If there are now no observed IDs for the set, complete the observable\n                 * \t- Remove the item observer entry for the deleted ID\n                 * @param result\n                 * @param ids\n                 * @returns {StoreObservable<string, any>}\n                 */\n                delete: function (result, ids) {\n                    var _this = this;\n                    result.then(function (deleted) {\n                        var state = instanceStateMap.get(_this);\n                        notifyItemObservers(null, deleted, state, _this);\n                        deleted.forEach(function (id) {\n                            if (state.itemObservers.has(id)) {\n                                state.itemObservers.get(id).forEach(function (observerOrEntry) {\n                                    if (isObserver(observerOrEntry)) {\n                                        observerOrEntry.complete();\n                                    }\n                                    else {\n                                        observerOrEntry.observes.delete(id);\n                                        if (!observerOrEntry.observes.size) {\n                                            observerOrEntry.observer.complete();\n                                        }\n                                    }\n                                });\n                                state.itemObservers.delete(id);\n                            }\n                        });\n                        sendUpdatesOrFetch(state, _this, [], [], deleted);\n                    }, \n                    // Ignore errors here, they should be handled by the caller not observers\n                    function () { });\n                    return result;\n                }\n            }\n        },\n        initialize: function (instance, options) {\n            options = options || {};\n            var itemObservers = new Map_1.default();\n            var storeObservable = new Observable_1.Observable(function (observer) {\n                var state = instanceStateMap.get(this);\n                state.observers.push(observer);\n                if (state.initialFetch) {\n                    state.initialFetch.then(function () {\n                        observer.next({\n                            updates: [],\n                            deletes: [],\n                            adds: [],\n                            beforeAll: [],\n                            afterAll: state.localData.slice()\n                        });\n                    });\n                }\n                else {\n                    observer.next({\n                        updates: [],\n                        deletes: [],\n                        adds: [],\n                        beforeAll: [],\n                        afterAll: state.localData.slice()\n                    });\n                }\n                return function () {\n                    function remove(observer) {\n                        state.observers.splice(state.observers.indexOf(observer), 1);\n                    }\n                    setTimeout(function () {\n                        remove(observer);\n                    });\n                };\n            }.bind(instance));\n            var state = {\n                fetchAroundUpdates: Boolean(options.fetchAroundUpdates),\n                fetchAndSendUpdates: util_1.debounce(function (store) {\n                    store.fetch();\n                }, options.fetchAroundUpdateDebounce || 20),\n                itemObservers: itemObservers,\n                observers: [],\n                storeObservable: storeObservable,\n                localData: [],\n                localIndex: new Map_1.default()\n            };\n            if (options.fetchAroundUpdates) {\n                state.initialFetch = instance.fetch();\n            }\n            instanceStateMap.set(instance, state);\n        }\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createObservableStoreMixin;\nexports.createObservableStore = createStore_1.default\n    .mixin(createObservableStoreMixin());\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/store/mixins/createObservableStoreMixin.js\n// module id = 54\n// module chunks = 0","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\"use strict\";\nvar decorators_1 = require(\"./support/decorators\");\nvar global_1 = require(\"./support/global\");\nvar iterator_1 = require(\"./iterator\");\nrequire(\"./Symbol\");\nvar Shim;\n(function (Shim) {\n    var Set = (function () {\n        function Set(iterable) {\n            var _this = this;\n            this._setData = [];\n            this[Symbol.toStringTag] = 'Set';\n            if (iterable) {\n                iterator_1.forOf(iterable, function (value) { return _this.add(value); });\n            }\n        }\n        ;\n        Set.prototype.add = function (value) {\n            if (this.has(value)) {\n                return this;\n            }\n            this._setData.push(value);\n            return this;\n        };\n        ;\n        Set.prototype.clear = function () {\n            this._setData.length = 0;\n        };\n        ;\n        Set.prototype.delete = function (value) {\n            var idx = this._setData.indexOf(value);\n            if (idx === -1) {\n                return false;\n            }\n            this._setData.splice(idx, 1);\n            return true;\n        };\n        ;\n        Set.prototype.entries = function () {\n            return new iterator_1.ShimIterator(this._setData.map(function (value) { return [value, value]; }));\n        };\n        ;\n        Set.prototype.forEach = function (callbackfn, thisArg) {\n            var iterator = this.values();\n            var result = iterator.next();\n            while (!result.done) {\n                callbackfn.call(thisArg, result.value, result.value, this);\n                result = iterator.next();\n            }\n        };\n        ;\n        Set.prototype.has = function (value) {\n            return this._setData.indexOf(value) > -1;\n        };\n        ;\n        Set.prototype.keys = function () {\n            return new iterator_1.ShimIterator(this._setData);\n        };\n        ;\n        Object.defineProperty(Set.prototype, \"size\", {\n            get: function () {\n                return this._setData.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Set.prototype.values = function () {\n            return new iterator_1.ShimIterator(this._setData);\n        };\n        ;\n        Set.prototype[Symbol.iterator] = function () {\n            return new iterator_1.ShimIterator(this._setData);\n        };\n        ;\n        return Set;\n    }());\n    Shim.Set = Set;\n})(Shim = exports.Shim || (exports.Shim = {}));\nvar Set = (function () {\n    /* istanbul ignore next */\n    function Set(iterable) {\n        /* istanbul ignore next */\n        this[Symbol.toStringTag] = 'Set';\n    }\n    ;\n    /* istanbul ignore next */\n    Set.prototype.add = function (value) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype.clear = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype.delete = function (value) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype.entries = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype.forEach = function (callbackfn, thisArg) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype.has = function (value) { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype.keys = function () { throw new Error('Abstract method'); };\n    ;\n    Object.defineProperty(Set.prototype, \"size\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error('Abstract method'); },\n        enumerable: true,\n        configurable: true\n    });\n    ;\n    /* istanbul ignore next */\n    Set.prototype.values = function () { throw new Error('Abstract method'); };\n    ;\n    /* istanbul ignore next */\n    Set.prototype[Symbol.iterator] = function () { throw new Error('Abstract method'); };\n    ;\n    return Set;\n}());\nSet = __decorate([\n    decorators_1.hasClass('es6-set', global_1.default.Set, Shim.Set)\n], Set);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Set;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/shim/Set.js\n// module id = 55\n// module chunks = 0","\"use strict\";\nvar lang_1 = require(\"./lang\");\n/**\n * Wraps a setTimeout call in a handle, allowing the timeout to be cleared by calling destroy.\n *\n * @param callback Callback to be called when the timeout elapses\n * @param delay Number of milliseconds to wait before calling the callback\n * @return Handle which can be destroyed to clear the timeout\n */\nfunction createTimer(callback, delay) {\n    var timerId = setTimeout(callback, delay);\n    return lang_1.createHandle(function () {\n        if (timerId) {\n            clearTimeout(timerId);\n            timerId = null;\n        }\n    });\n}\nexports.createTimer = createTimer;\n/**\n * Wraps a callback, returning a function which fires after no further calls are received over a set interval.\n *\n * @param callback Callback to wrap\n * @param delay Number of milliseconds to wait after any invocations before calling the original callback\n * @return Debounced function\n */\nfunction debounce(callback, delay) {\n    // node.d.ts clobbers setTimeout/clearTimeout with versions that return/receive NodeJS.Timer,\n    // but browsers return/receive a number\n    var timer;\n    return function () {\n        timer && clearTimeout(timer);\n        var context = this;\n        var args = arguments;\n        timer = setTimeout(function () {\n            callback.apply(context, args);\n            args = context = timer = null;\n        }, delay);\n    };\n}\nexports.debounce = debounce;\n/**\n * Wraps a callback, returning a function which fires at most once per set interval.\n *\n * @param callback Callback to wrap\n * @param delay Number of milliseconds to wait before allowing the original callback to be called again\n * @return Throttled function\n */\nfunction throttle(callback, delay) {\n    var ran;\n    return function () {\n        if (ran) {\n            return;\n        }\n        ran = true;\n        callback.apply(this, arguments);\n        setTimeout(function () {\n            ran = null;\n        }, delay);\n    };\n}\nexports.throttle = throttle;\n/**\n * Like throttle, but calls the callback at the end of each interval rather than the beginning.\n * Useful for e.g. resize or scroll events, when debounce would appear unresponsive.\n *\n * @param callback Callback to wrap\n * @param delay Number of milliseconds to wait before calling the original callback and allowing it to be called again\n * @return Throttled function\n */\nfunction throttleAfter(callback, delay) {\n    var ran;\n    return function () {\n        if (ran) {\n            return;\n        }\n        ran = true;\n        var context = this;\n        var args = arguments;\n        setTimeout(function () {\n            callback.apply(context, args);\n            args = context = ran = null;\n        }, delay);\n    };\n}\nexports.throttleAfter = throttleAfter;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/core/util.js\n// module id = 56\n// module chunks = 0","import createObservableStore, { Store } from './createObservableStore';\nimport { putTodo } from '../actions/widgetStoreActions';\n\nexport interface Item {\n\tid: string;\n\tlabel?: string;\n\tcompleted?: boolean;\n\tcreatedOn?: Date;\n\tediting: boolean;\n}\n\nconst todoStore: Store<Item> = createObservableStore({\n\tdata: <Item[]> [],\n\tfetchAroundUpdates: true\n});\n\nexport default todoStore;\n\nexport function bindActions() {\n\treturn todoStore\n\t\t.observe()\n\t\t.subscribe((options) => {\n\t\t\tputTodo(options);\n\t\t});\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/stores/todoStore.ts","import { DNode, Widget } from '@dojo/widgets/interfaces';\nimport createProjector from '@dojo/widgets/createProjector';\nimport externalState from '@dojo/widgets/mixins/externalState';\nimport { w } from '@dojo/widgets/d';\nimport createTodoDetails from './widgets/createTodoDetails';\nimport FactoryRegistry from '@dojo/widgets/FactoryRegistry';\nimport createHome from './widgets/createHome';\n\nconst widgetRegistry = new FactoryRegistry();\n\ninterface AppProperties {\n\twidgets: any;\n}\n\nwidgetRegistry.define('main', createHome);\nwidgetRegistry.define('todo-details', createTodoDetails);\n\nconst createApp = createProjector\n\t.mixin(externalState)\n\t.mixin({\n\t\tmixin: {\n\t\t\tregistry: widgetRegistry,\n\t\t\tgetChildrenNodes: function (this: Widget<AppProperties>): DNode[] {\n\t\t\t\tconst { widgets = [ [ 'main', {} ] ] } = this.state;\n\n\t\t\t\treturn widgets.map((widget: any) => {\n\t\t\t\t\treturn w(<any> widget[ 0 ], <any> { ...this.state, ...widget[ 1 ], id: <string> widget[ 0 ] });\n\t\t\t\t});\n\t\t\t},\n\t\t\tclasses: [ 'todoapp' ],\n\t\t\ttagName: 'section'\n\t\t}\n\t});\n\nexport default createApp;\n\n\n\n// WEBPACK FOOTER //\n// ./src/createApp.ts","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar createWidgetBase_1 = require(\"./createWidgetBase\");\nvar createProjectorMixin_1 = require(\"./mixins/createProjectorMixin\");\n/**\n * Projector Factory\n */\nvar createProjector = createWidgetBase_1.default\n    .mixin(createProjectorMixin_1.default);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createProjector;\n__export(require(\"./mixins/createProjectorMixin\"));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widgets/createProjector.js\n// module id = 59\n// module chunks = 0","\"use strict\";\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar createStateful_1 = require(\"@dojo/compose/bases/createStateful\");\nvar lang_1 = require(\"@dojo/core/lang\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar Map_1 = require(\"@dojo/shim/Map\");\nvar d_1 = require(\"./d\");\nvar FactoryRegistry_1 = require(\"./FactoryRegistry\");\nvar shallowPropertyComparisonMixin_1 = require(\"./mixins/shallowPropertyComparisonMixin\");\n/**\n * Internal state map for widget instances\n */\nvar widgetInternalStateMap = new WeakMap_1.default();\nfunction isWNode(child) {\n    return Boolean(child && child.factory !== undefined);\n}\nfunction getFromRegistry(instance, factoryLabel) {\n    if (instance.registry.has(factoryLabel)) {\n        return instance.registry.get(factoryLabel);\n    }\n    return d_1.registry.get(factoryLabel);\n}\nfunction dNodeToVNode(instance, dNode) {\n    var internalState = widgetInternalStateMap.get(instance);\n    if (typeof dNode === 'string' || dNode === null) {\n        return dNode;\n    }\n    if (isWNode(dNode)) {\n        var children = dNode.children, properties = dNode.properties;\n        var id = properties.id;\n        var factory = dNode.factory;\n        var child = void 0;\n        if (typeof factory === 'string') {\n            var item = getFromRegistry(instance, factory);\n            if (compose_1.isComposeFactory(item)) {\n                factory = item;\n            }\n            else {\n                if (item && !internalState.initializedFactoryMap.has(factory)) {\n                    var promise = item.then(function (factory) {\n                        instance.invalidate();\n                        return factory;\n                    });\n                    internalState.initializedFactoryMap.set(factory, promise);\n                }\n                return null;\n            }\n        }\n        var childrenMapKey = id || factory;\n        var cachedChild = internalState.historicChildrenMap.get(childrenMapKey);\n        if (cachedChild) {\n            child = cachedChild;\n            if (properties) {\n                child.setProperties(properties);\n            }\n        }\n        else {\n            child = factory({ properties: properties });\n            child.own(child.on('invalidated', function () {\n                instance.invalidate();\n            }));\n            internalState.historicChildrenMap.set(childrenMapKey, child);\n            instance.own(child);\n        }\n        if (!id && internalState.currentChildrenMap.has(factory)) {\n            var errorMsg = 'must provide unique keys when using the same widget factory multiple times';\n            console.error(errorMsg);\n            instance.emit({ type: 'error', target: instance, error: new Error(errorMsg) });\n        }\n        child.children = children;\n        internalState.currentChildrenMap.set(childrenMapKey, child);\n        return child.__render__();\n    }\n    dNode.children = dNode.children\n        .filter(function (child) { return child !== null; })\n        .map(function (child) {\n        return dNodeToVNode(instance, child);\n    });\n    return dNode.render({ bind: instance });\n}\nfunction manageDetachedChildren(instance) {\n    var internalState = widgetInternalStateMap.get(instance);\n    internalState.historicChildrenMap.forEach(function (child, key) {\n        if (!internalState.currentChildrenMap.has(key)) {\n            internalState.historicChildrenMap.delete(key);\n            child.destroy();\n        }\n    });\n    internalState.currentChildrenMap.clear();\n}\nfunction formatTagNameAndClasses(tagName, classes) {\n    if (classes.length) {\n        return tagName + \".\" + classes.join('.');\n    }\n    return tagName;\n}\nvar createWidget = createStateful_1.default\n    .mixin({\n    mixin: {\n        properties: {},\n        classes: [],\n        getNode: function () {\n            var tag = formatTagNameAndClasses(this.tagName, this.classes);\n            return d_1.v(tag, this.getNodeAttributes(), this.getChildrenNodes());\n        },\n        set children(children) {\n            var internalState = widgetInternalStateMap.get(this);\n            internalState.children = children;\n            this.emit({\n                type: 'widget:children',\n                target: this\n            });\n        },\n        get children() {\n            return widgetInternalStateMap.get(this).children;\n        },\n        getChildrenNodes: function () {\n            return this.children;\n        },\n        getNodeAttributes: function (overrides) {\n            var _this = this;\n            var props = {};\n            this.nodeAttributes.forEach(function (fn) {\n                var newProps = fn.call(_this);\n                if (newProps) {\n                    lang_1.assign(props, newProps);\n                }\n            });\n            return props;\n        },\n        invalidate: function () {\n            var internalState = widgetInternalStateMap.get(this);\n            internalState.dirty = true;\n            this.emit({\n                type: 'invalidated',\n                target: this\n            });\n        },\n        get id() {\n            return this.properties.id;\n        },\n        setProperties: function (properties) {\n            var internalState = widgetInternalStateMap.get(this);\n            var changedPropertyKeys = this.diffProperties(internalState.previousProperties, properties);\n            this.properties = this.assignProperties(internalState.previousProperties, properties, changedPropertyKeys);\n            if (changedPropertyKeys.length) {\n                this.emit({\n                    type: 'properties:changed',\n                    target: this,\n                    properties: this.properties,\n                    changedPropertyKeys: changedPropertyKeys\n                });\n            }\n            internalState.previousProperties = this.properties;\n        },\n        diffProperties: function (previousProperties, newProperties) {\n            return Object.keys(newProperties);\n        },\n        assignProperties: function (previousProperties, newProperties, changedPropertyKeys) {\n            return lang_1.assign({}, newProperties);\n        },\n        onPropertiesChanged: function (properties, changedPropertyKeys) {\n            var state = changedPropertyKeys.reduce(function (state, key) {\n                var property = properties[key];\n                if (!(typeof property === 'function')) {\n                    state[key] = property;\n                }\n                return state;\n            }, {});\n            this.setState(state);\n        },\n        nodeAttributes: [\n            function () {\n                var baseIdProp = this.state && this.state.id ? { 'data-widget-id': this.state.id } : {};\n                var _a = (this.state || {}).styles, styles = _a === void 0 ? {} : _a;\n                var classes = {};\n                var internalState = widgetInternalStateMap.get(this);\n                internalState.widgetClasses.forEach(function (c) { return classes[c] = false; });\n                if (this.state && this.state.classes) {\n                    this.state.classes.forEach(function (c) { return classes[c] = true; });\n                    internalState.widgetClasses = this.state.classes;\n                }\n                return lang_1.assign(baseIdProp, { key: this, classes: classes, styles: styles });\n            }\n        ],\n        __render__: function () {\n            var internalState = widgetInternalStateMap.get(this);\n            if (internalState.dirty || !internalState.cachedVNode) {\n                var widget = dNodeToVNode(this, this.getNode());\n                manageDetachedChildren(this);\n                if (widget) {\n                    internalState.cachedVNode = widget;\n                }\n                internalState.dirty = false;\n                return widget;\n            }\n            return internalState.cachedVNode;\n        },\n        get registry() {\n            return widgetInternalStateMap.get(this).factoryRegistry;\n        },\n        tagName: 'div'\n    },\n    initialize: function (instance, options) {\n        if (options === void 0) { options = {}; }\n        var tagName = options.tagName, _a = options.properties, properties = _a === void 0 ? {} : _a;\n        instance.tagName = tagName || instance.tagName;\n        widgetInternalStateMap.set(instance, {\n            dirty: true,\n            widgetClasses: [],\n            previousProperties: {},\n            factoryRegistry: new FactoryRegistry_1.default(),\n            initializedFactoryMap: new Map_1.default(),\n            historicChildrenMap: new Map_1.default(),\n            currentChildrenMap: new Map_1.default(),\n            children: []\n        });\n        instance.own(instance.on('properties:changed', function (evt) {\n            instance.onPropertiesChanged(evt.properties, evt.changedPropertyKeys);\n        }));\n        instance.own(instance.on('state:changed', function () {\n            instance.invalidate();\n        }));\n        instance.setProperties(properties);\n    }\n})\n    .mixin(shallowPropertyComparisonMixin_1.default);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createWidget;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widgets/createWidgetBase.js\n// module id = 60\n// module chunks = 0","\"use strict\";\nvar lang_1 = require(\"@dojo/core/lang\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar createEvented_1 = require(\"./createEvented\");\n/**\n * Private map of internal instance state.\n */\nvar instanceStateMap = new WeakMap_1.default();\n/**\n * State change event type\n */\nvar stateChangedEventType = 'state:changed';\n/**\n * Create an instance of a stateful object\n */\nvar createStateful = createEvented_1.default\n    .mixin({\n    className: 'Stateful',\n    mixin: {\n        get state() {\n            return instanceStateMap.get(this);\n        },\n        setState: function (value) {\n            var oldState = instanceStateMap.get(this);\n            var state = lang_1.deepAssign({}, oldState, value);\n            var eventObject = {\n                type: stateChangedEventType,\n                state: state,\n                target: this\n            };\n            instanceStateMap.set(this, state);\n            this.emit(eventObject);\n        }\n    },\n    initialize: function (instance) {\n        instanceStateMap.set(instance, Object.create(null));\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createStateful;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/compose/bases/createStateful.js\n// module id = 61\n// module chunks = 0","\"use strict\";\nvar lang_1 = require(\"@dojo/core/lang\");\nvar maquette_1 = require(\"maquette\");\nvar FactoryRegistry_1 = require(\"./FactoryRegistry\");\nexports.registry = new FactoryRegistry_1.default();\nfunction w(factory, properties, children) {\n    if (children === void 0) { children = []; }\n    return {\n        children: children,\n        factory: factory,\n        properties: properties\n    };\n}\nexports.w = w;\nfunction v(tag, propertiesOrChildren, children) {\n    if (propertiesOrChildren === void 0) { propertiesOrChildren = {}; }\n    if (children === void 0) { children = []; }\n    if (Array.isArray(propertiesOrChildren)) {\n        children = propertiesOrChildren;\n        propertiesOrChildren = {};\n    }\n    return {\n        children: children,\n        render: function (options) {\n            if (options === void 0) { options = {}; }\n            return maquette_1.h(tag, lang_1.assign(options, propertiesOrChildren), this.children);\n        }\n    };\n}\nexports.v = v;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widgets/d.js\n// module id = 62\n// module chunks = 0","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['exports'], factory);\n    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n        // CommonJS\n        factory(exports);\n    } else {\n        // Browser globals\n        factory(root.maquette = {});\n    }\n}(this, function (exports) {\n    'use strict';\n    ;\n    ;\n    ;\n    ;\n    var NAMESPACE_W3 = 'http://www.w3.org/';\n    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\n    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n    // Utilities\n    var emptyArray = [];\n    var extend = function (base, overrides) {\n        var result = {};\n        Object.keys(base).forEach(function (key) {\n            result[key] = base[key];\n        });\n        if (overrides) {\n            Object.keys(overrides).forEach(function (key) {\n                result[key] = overrides[key];\n            });\n        }\n        return result;\n    };\n    // Hyperscript helper functions\n    var same = function (vnode1, vnode2) {\n        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n            return false;\n        }\n        if (vnode1.properties && vnode2.properties) {\n            if (vnode1.properties.key !== vnode2.properties.key) {\n                return false;\n            }\n            return vnode1.properties.bind === vnode2.properties.bind;\n        }\n        return !vnode1.properties && !vnode2.properties;\n    };\n    var toTextVNode = function (data) {\n        return {\n            vnodeSelector: '',\n            properties: undefined,\n            children: undefined,\n            text: data.toString(),\n            domNode: null\n        };\n    };\n    var appendChildren = function (parentSelector, insertions, main) {\n        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\n            var item = insertions[i];\n            if (Array.isArray(item)) {\n                appendChildren(parentSelector, item, main);\n            } else {\n                if (item !== null && item !== undefined) {\n                    if (!item.hasOwnProperty('vnodeSelector')) {\n                        item = toTextVNode(item);\n                    }\n                    main.push(item);\n                }\n            }\n        }\n    };\n    // Render helper functions\n    var missingTransition = function () {\n        throw new Error('Provide a transitions object to the projectionOptions to do animations');\n    };\n    var DEFAULT_PROJECTION_OPTIONS = {\n        namespace: undefined,\n        eventHandlerInterceptor: undefined,\n        styleApplyer: function (domNode, styleName, value) {\n            // Provides a hook to add vendor prefixes for browsers that still need it.\n            domNode.style[styleName] = value;\n        },\n        transitions: {\n            enter: missingTransition,\n            exit: missingTransition\n        }\n    };\n    var applyDefaultProjectionOptions = function (projectorOptions) {\n        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n    };\n    var checkStyleValue = function (styleValue) {\n        if (typeof styleValue !== 'string') {\n            throw new Error('Style values must be strings');\n        }\n    };\n    var setProperties = function (domNode, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            /* tslint:disable:no-var-keyword: edge case */\n            var propValue = properties[propName];\n            /* tslint:enable:no-var-keyword */\n            if (propName === 'className') {\n                throw new Error('Property \"className\" is not supported, use \"class\".');\n            } else if (propName === 'class') {\n                propValue.split(/\\s+/).forEach(function (token) {\n                    return domNode.classList.add(token);\n                });\n            } else if (propName === 'classes') {\n                // object with string keys and boolean values\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    if (propValue[className]) {\n                        domNode.classList.add(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                // object with string keys and string (!) values\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var styleValue = propValue[styleName];\n                    if (styleValue) {\n                        checkStyleValue(styleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n                    }\n                }\n            } else if (propName === 'key') {\n                continue;\n            } else if (propValue === null || propValue === undefined) {\n                continue;\n            } else {\n                var type = typeof propValue;\n                if (type === 'function') {\n                    if (propName.lastIndexOf('on', 0) === 0) {\n                        if (eventHandlerInterceptor) {\n                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers\n                        }\n                        if (propName === 'oninput') {\n                            (function () {\n                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n                                var oldPropValue = propValue;\n                                propValue = function (evt) {\n                                    evt.target['oninput-value'] = evt.target.value;\n                                    // may be HTMLTextAreaElement as well\n                                    oldPropValue.apply(this, [evt]);\n                                };\n                            }());\n                        }\n                        domNode[propName] = propValue;\n                    }\n                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                    } else {\n                        domNode.setAttribute(propName, propValue);\n                    }\n                } else {\n                    domNode[propName] = propValue;\n                }\n            }\n        }\n    };\n    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var propertiesUpdated = false;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            // assuming that properties will be nullified instead of missing is by design\n            var propValue = properties[propName];\n            var previousValue = previousProperties[propName];\n            if (propName === 'class') {\n                if (previousValue !== propValue) {\n                    throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n                }\n            } else if (propName === 'classes') {\n                var classList = domNode.classList;\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    var on = !!propValue[className];\n                    var previousOn = !!previousValue[className];\n                    if (on === previousOn) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (on) {\n                        classList.add(className);\n                    } else {\n                        classList.remove(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var newStyleValue = propValue[styleName];\n                    var oldStyleValue = previousValue[styleName];\n                    if (newStyleValue === oldStyleValue) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (newStyleValue) {\n                        checkStyleValue(newStyleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n                    } else {\n                        projectionOptions.styleApplyer(domNode, styleName, '');\n                    }\n                }\n            } else {\n                if (!propValue && typeof previousValue === 'string') {\n                    propValue = '';\n                }\n                if (propName === 'value') {\n                    if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n                        domNode[propName] = propValue;\n                        // Reset the value, even if the virtual DOM did not change\n                        domNode['oninput-value'] = undefined;\n                    }\n                    // else do not update the domNode, otherwise the cursor position would be changed\n                    if (propValue !== previousValue) {\n                        propertiesUpdated = true;\n                    }\n                } else if (propValue !== previousValue) {\n                    var type = typeof propValue;\n                    if (type === 'function') {\n                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');\n                    }\n                    if (type === 'string' && propName !== 'innerHTML') {\n                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                        } else {\n                            domNode.setAttribute(propName, propValue);\n                        }\n                    } else {\n                        if (domNode[propName] !== propValue) {\n                            domNode[propName] = propValue;\n                        }\n                    }\n                    propertiesUpdated = true;\n                }\n            }\n        }\n        return propertiesUpdated;\n    };\n    var findIndexOfChild = function (children, sameAs, start) {\n        if (sameAs.vnodeSelector !== '') {\n            // Never scan for text-nodes\n            for (var i = start; i < children.length; i++) {\n                if (same(children[i], sameAs)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    var nodeAdded = function (vNode, transitions) {\n        if (vNode.properties) {\n            var enterAnimation = vNode.properties.enterAnimation;\n            if (enterAnimation) {\n                if (typeof enterAnimation === 'function') {\n                    enterAnimation(vNode.domNode, vNode.properties);\n                } else {\n                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n                }\n            }\n        }\n    };\n    var nodeToRemove = function (vNode, transitions) {\n        var domNode = vNode.domNode;\n        if (vNode.properties) {\n            var exitAnimation = vNode.properties.exitAnimation;\n            if (exitAnimation) {\n                domNode.style.pointerEvents = 'none';\n                var removeDomNode = function () {\n                    if (domNode.parentNode) {\n                        domNode.parentNode.removeChild(domNode);\n                    }\n                };\n                if (typeof exitAnimation === 'function') {\n                    exitAnimation(domNode, removeDomNode, vNode.properties);\n                    return;\n                } else {\n                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n                    return;\n                }\n            }\n        }\n        if (domNode.parentNode) {\n            domNode.parentNode.removeChild(domNode);\n        }\n    };\n    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n        var childNode = childNodes[indexToCheck];\n        if (childNode.vnodeSelector === '') {\n            return;    // Text nodes need not be distinguishable\n        }\n        var properties = childNode.properties;\n        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;\n        if (!key) {\n            for (var i = 0; i < childNodes.length; i++) {\n                if (i !== indexToCheck) {\n                    var node = childNodes[i];\n                    if (same(node, childNode)) {\n                        if (operation === 'added') {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n                        } else {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n                        }\n                    }\n                }\n            }\n        }\n    };\n    var createDom;\n    var updateDom;\n    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n        if (oldChildren === newChildren) {\n            return false;\n        }\n        oldChildren = oldChildren || emptyArray;\n        newChildren = newChildren || emptyArray;\n        var oldChildrenLength = oldChildren.length;\n        var newChildrenLength = newChildren.length;\n        var transitions = projectionOptions.transitions;\n        var oldIndex = 0;\n        var newIndex = 0;\n        var i;\n        var textUpdated = false;\n        while (newIndex < newChildrenLength) {\n            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n            var newChild = newChildren[newIndex];\n            if (oldChild !== undefined && same(oldChild, newChild)) {\n                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n                oldIndex++;\n            } else {\n                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n                if (findOldIndex >= 0) {\n                    // Remove preceding missing children\n                    for (i = oldIndex; i < findOldIndex; i++) {\n                        nodeToRemove(oldChildren[i], transitions);\n                        checkDistinguishable(oldChildren, i, vnode, 'removed');\n                    }\n                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n                    oldIndex = findOldIndex + 1;\n                } else {\n                    // New child\n                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n                    nodeAdded(newChild, transitions);\n                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\n                }\n            }\n            newIndex++;\n        }\n        if (oldChildrenLength > oldIndex) {\n            // Remove child fragments\n            for (i = oldIndex; i < oldChildrenLength; i++) {\n                nodeToRemove(oldChildren[i], transitions);\n                checkDistinguishable(oldChildren, i, vnode, 'removed');\n            }\n        }\n        return textUpdated;\n    };\n    var addChildren = function (domNode, children, projectionOptions) {\n        if (!children) {\n            return;\n        }\n        for (var i = 0; i < children.length; i++) {\n            createDom(children[i], domNode, undefined, projectionOptions);\n        }\n    };\n    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n        addChildren(domNode, vnode.children, projectionOptions);\n        // children before properties, needed for value property of <select>.\n        if (vnode.text) {\n            domNode.textContent = vnode.text;\n        }\n        setProperties(domNode, vnode.properties, projectionOptions);\n        if (vnode.properties && vnode.properties.afterCreate) {\n            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [\n                domNode,\n                projectionOptions,\n                vnode.vnodeSelector,\n                vnode.properties,\n                vnode.children\n            ]);\n        }\n    };\n    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n        var domNode, i, c, start = 0, type, found;\n        var vnodeSelector = vnode.vnodeSelector;\n        if (vnodeSelector === '') {\n            domNode = vnode.domNode = document.createTextNode(vnode.text);\n            if (insertBefore !== undefined) {\n                parentNode.insertBefore(domNode, insertBefore);\n            } else {\n                parentNode.appendChild(domNode);\n            }\n        } else {\n            for (i = 0; i <= vnodeSelector.length; ++i) {\n                c = vnodeSelector.charAt(i);\n                if (i === vnodeSelector.length || c === '.' || c === '#') {\n                    type = vnodeSelector.charAt(start - 1);\n                    found = vnodeSelector.slice(start, i);\n                    if (type === '.') {\n                        domNode.classList.add(found);\n                    } else if (type === '#') {\n                        domNode.id = found;\n                    } else {\n                        if (found === 'svg') {\n                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n                        }\n                        if (projectionOptions.namespace !== undefined) {\n                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n                        } else {\n                            domNode = vnode.domNode = document.createElement(found);\n                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {\n                                // IE8 and older don't support setting input type after the DOM Node has been added to the document\n                                domNode.setAttribute('type', vnode.properties.type);\n                            }\n                        }\n                        if (insertBefore !== undefined) {\n                            parentNode.insertBefore(domNode, insertBefore);\n                        } else {\n                            parentNode.appendChild(domNode);\n                        }\n                    }\n                    start = i + 1;\n                }\n            }\n            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n        }\n    };\n    updateDom = function (previous, vnode, projectionOptions) {\n        var domNode = previous.domNode;\n        var textUpdated = false;\n        if (previous === vnode) {\n            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette\n        }\n        var updated = false;\n        if (vnode.vnodeSelector === '') {\n            if (vnode.text !== previous.text) {\n                var newVNode = document.createTextNode(vnode.text);\n                domNode.parentNode.replaceChild(newVNode, domNode);\n                vnode.domNode = newVNode;\n                textUpdated = true;\n                return textUpdated;\n            }\n        } else {\n            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n            }\n            if (previous.text !== vnode.text) {\n                updated = true;\n                if (vnode.text === undefined) {\n                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably\n                } else {\n                    domNode.textContent = vnode.text;\n                }\n            }\n            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n            if (vnode.properties && vnode.properties.afterUpdate) {\n                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [\n                    domNode,\n                    projectionOptions,\n                    vnode.vnodeSelector,\n                    vnode.properties,\n                    vnode.children\n                ]);\n            }\n        }\n        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n        }\n        vnode.domNode = previous.domNode;\n        return textUpdated;\n    };\n    var createProjection = function (vnode, projectionOptions) {\n        return {\n            update: function (updatedVnode) {\n                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n                }\n                updateDom(vnode, updatedVnode, projectionOptions);\n                vnode = updatedVnode;\n            },\n            domNode: vnode.domNode\n        };\n    };\n    ;\n    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.\n    exports.h = function (selector) {\n        var properties = arguments[1];\n        if (typeof selector !== 'string') {\n            throw new Error();\n        }\n        var childIndex = 1;\n        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n            childIndex = 2;\n        } else {\n            // Optional properties argument was omitted\n            properties = undefined;\n        }\n        var text = undefined;\n        var children = undefined;\n        var argsLength = arguments.length;\n        // Recognize a common special case where there is only a single text node\n        if (argsLength === childIndex + 1) {\n            var onlyChild = arguments[childIndex];\n            if (typeof onlyChild === 'string') {\n                text = onlyChild;\n            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n                text = onlyChild[0];\n            }\n        }\n        if (text === undefined) {\n            children = [];\n            for (; childIndex < argsLength; childIndex++) {\n                var child = arguments[childIndex];\n                if (child === null || child === undefined) {\n                    continue;\n                } else if (Array.isArray(child)) {\n                    appendChildren(selector, child, children);\n                } else if (child.hasOwnProperty('vnodeSelector')) {\n                    children.push(child);\n                } else {\n                    children.push(toTextVNode(child));\n                }\n            }\n        }\n        return {\n            vnodeSelector: selector,\n            properties: properties,\n            children: children,\n            text: text === '' ? undefined : text,\n            domNode: null\n        };\n    };\n    /**\n * Contains simple low-level utility functions to manipulate the real DOM.\n */\n    exports.dom = {\n        /**\n     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n     * its [[Projection.domNode|domNode]] property.\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection.\n     * @returns The [[Projection]] which also contains the DOM Node that was created.\n     */\n        create: function (vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Appends a new childnode to the DOM which is generated from a [[VNode]].\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param parentNode - The parent node for the new childNode.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n     * @returns The [[Projection]] that was created.\n     */\n        append: function (parentNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, parentNode, undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Inserts a new DOM node which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param beforeNode - The node that the DOM Node is inserted before.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n     * NOTE: [[VNode]] objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        insertBefore: function (beforeNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n     * This means that the virtual DOM and the real DOM will have one overlapping element.\n     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n     * may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        merge: function (element, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            vnode.domNode = element;\n            initPropertiesAndChildren(element, vnode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        }\n    };\n    /**\n * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n * For more information, see [[CalculationCache]].\n *\n * @param <Result> The type of the value that is cached.\n */\n    exports.createCache = function () {\n        var cachedInputs = undefined;\n        var cachedOutcome = undefined;\n        var result = {\n            invalidate: function () {\n                cachedOutcome = undefined;\n                cachedInputs = undefined;\n            },\n            result: function (inputs, calculation) {\n                if (cachedInputs) {\n                    for (var i = 0; i < inputs.length; i++) {\n                        if (cachedInputs[i] !== inputs[i]) {\n                            cachedOutcome = undefined;\n                        }\n                    }\n                }\n                if (!cachedOutcome) {\n                    cachedOutcome = calculation();\n                    cachedInputs = inputs;\n                }\n                return cachedOutcome;\n            }\n        };\n        return result;\n    };\n    /**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n *\n * @param <Source>       The type of source items. A database-record for instance.\n * @param <Target>       The type of target items. A [[Component]] for instance.\n * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n *                       to the `callback` argument in `Array.map(callback)`.\n * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n */\n    exports.createMapping = function (getSourceKey, createResult, updateResult) {\n        var keys = [];\n        var results = [];\n        return {\n            results: results,\n            map: function (newSources) {\n                var newKeys = newSources.map(getSourceKey);\n                var oldTargets = results.slice();\n                var oldIndex = 0;\n                for (var i = 0; i < newSources.length; i++) {\n                    var source = newSources[i];\n                    var sourceKey = newKeys[i];\n                    if (sourceKey === keys[oldIndex]) {\n                        results[i] = oldTargets[oldIndex];\n                        updateResult(source, oldTargets[oldIndex], i);\n                        oldIndex++;\n                    } else {\n                        var found = false;\n                        for (var j = 1; j < keys.length + 1; j++) {\n                            var searchIndex = (oldIndex + j) % keys.length;\n                            if (keys[searchIndex] === sourceKey) {\n                                results[i] = oldTargets[searchIndex];\n                                updateResult(newSources[i], oldTargets[searchIndex], i);\n                                oldIndex = searchIndex + 1;\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            results[i] = createResult(source, i);\n                        }\n                    }\n                }\n                results.length = newSources.length;\n                keys = newKeys;\n            }\n        };\n    };\n    /**\n * Creates a [[Projector]] instance using the provided projectionOptions.\n *\n * For more information, see [[Projector]].\n *\n * @param projectionOptions   Options that influence how the DOM is rendered and updated.\n */\n    exports.createProjector = function (projectorOptions) {\n        var projector;\n        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n            return function () {\n                // intercept function calls (event handlers) to do a render afterwards.\n                projector.scheduleRender();\n                return eventHandler.apply(properties.bind || this, arguments);\n            };\n        };\n        var renderCompleted = true;\n        var scheduled;\n        var stopped = false;\n        var projections = [];\n        var renderFunctions = [];\n        // matches the projections array\n        var doRender = function () {\n            scheduled = undefined;\n            if (!renderCompleted) {\n                return;    // The last render threw an error, it should be logged in the browser console.\n            }\n            renderCompleted = false;\n            for (var i = 0; i < projections.length; i++) {\n                var updatedVnode = renderFunctions[i]();\n                projections[i].update(updatedVnode);\n            }\n            renderCompleted = true;\n        };\n        projector = {\n            renderNow: doRender,\n            scheduleRender: function () {\n                if (!scheduled && !stopped) {\n                    scheduled = requestAnimationFrame(doRender);\n                }\n            },\n            stop: function () {\n                if (scheduled) {\n                    cancelAnimationFrame(scheduled);\n                    scheduled = undefined;\n                }\n                stopped = true;\n            },\n            resume: function () {\n                stopped = false;\n                renderCompleted = true;\n                projector.scheduleRender();\n            },\n            append: function (parentNode, renderMaquetteFunction) {\n                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            insertBefore: function (beforeNode, renderMaquetteFunction) {\n                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            merge: function (domNode, renderMaquetteFunction) {\n                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            replace: function (domNode, renderMaquetteFunction) {\n                var vnode = renderMaquetteFunction();\n                createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n                domNode.parentNode.removeChild(domNode);\n                projections.push(createProjection(vnode, projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            detach: function (renderMaquetteFunction) {\n                for (var i = 0; i < renderFunctions.length; i++) {\n                    if (renderFunctions[i] === renderMaquetteFunction) {\n                        renderFunctions.splice(i, 1);\n                        return projections.splice(i, 1)[0];\n                    }\n                }\n                throw new Error('renderMaquetteFunction was not found');\n            }\n        };\n        return projector;\n    };\n}));\n//# sourceMappingURL=maquette.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/maquette/dist/maquette.js\n// module id = 63\n// module chunks = 0","\"use strict\";\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar Map_1 = require(\"@dojo/shim/Map\");\nvar FactoryRegistry = (function () {\n    function FactoryRegistry() {\n        this.registry = new Map_1.default();\n    }\n    FactoryRegistry.prototype.has = function (factoryLabel) {\n        return this.registry.has(factoryLabel);\n    };\n    FactoryRegistry.prototype.define = function (factoryLabel, registryItem) {\n        if (this.registry.has(factoryLabel)) {\n            throw new Error(\"factory has already been registered for '\" + factoryLabel + \"'\");\n        }\n        this.registry.set(factoryLabel, registryItem);\n    };\n    FactoryRegistry.prototype.get = function (factoryLabel) {\n        var _this = this;\n        if (!this.has(factoryLabel)) {\n            return null;\n        }\n        var item = this.registry.get(factoryLabel);\n        if (compose_1.isComposeFactory(item) || item instanceof Promise_1.default) {\n            return item;\n        }\n        var promise = item();\n        this.registry.set(factoryLabel, promise);\n        return promise.then(function (factory) {\n            _this.registry.set(factoryLabel, factory);\n            return factory;\n        }, function (error) {\n            throw error;\n        });\n    };\n    return FactoryRegistry;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = FactoryRegistry;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widgets/FactoryRegistry.js\n// module id = 64\n// module chunks = 0","\"use strict\";\nvar object_1 = require(\"@dojo/shim/object\");\nvar lang_1 = require(\"@dojo/core/lang\");\n/**\n * Determine if the value is an Object\n */\nfunction isObject(value) {\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n/**\n * Shallow comparison of all keys on the objects\n */\nfunction shallowCompare(from, to) {\n    return Object.keys(from).every(function (key) { return from[key] === to[key]; });\n}\n/**\n * Mixin that overrides the `diffProperties` method providing a shallow comparison of attributes.\n *\n * For Objects, values for all `keys` are compared against the equivalent `key` on the `previousProperties`\n * attribute using `===`. If the `key` does not exists on the `previousProperties` attribute it is considered unequal.\n *\n * For Arrays, each `item` is compared with the `item` in the equivalent `index` of the `previousProperties` attribute.\n * If the `item` is an `object` then the object comparison described above is applied otherwise a simple `===` is used.\n */\nvar shallowPropertyComparisonMixin = {\n    mixin: {\n        diffProperties: function (previousProperties, newProperties) {\n            var changedPropertyKeys = [];\n            object_1.entries(newProperties).forEach(function (_a) {\n                var key = _a[0], value = _a[1];\n                var isEqual = true;\n                if (previousProperties.hasOwnProperty(key)) {\n                    var previousValue_1 = previousProperties[key];\n                    if (Array.isArray(value) && Array.isArray(previousValue_1)) {\n                        if (value.length !== previousValue_1.length) {\n                            isEqual = false;\n                        }\n                        else {\n                            isEqual = value.every(function (item, index) {\n                                if (isObject(item)) {\n                                    return shallowCompare(item, previousValue_1[index]);\n                                }\n                                else {\n                                    return item === previousValue_1[index];\n                                }\n                            });\n                        }\n                    }\n                    else if (isObject(value) && isObject(previousValue_1)) {\n                        isEqual = shallowCompare(value, previousValue_1);\n                    }\n                    else {\n                        isEqual = value === previousValue_1;\n                    }\n                }\n                else {\n                    isEqual = false;\n                }\n                if (!isEqual) {\n                    changedPropertyKeys.push(key);\n                }\n            });\n            return changedPropertyKeys;\n        },\n        assignProperties: function (previousProperties, newProperties, changedPropertyKeys) {\n            return lang_1.deepAssign({}, newProperties);\n        }\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = shallowPropertyComparisonMixin;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widgets/mixins/shallowPropertyComparisonMixin.js\n// module id = 65\n// module chunks = 0","\"use strict\";\nvar global_1 = require(\"@dojo/core/global\");\nvar compose_1 = require(\"@dojo/compose/compose\");\nvar Promise_1 = require(\"@dojo/shim/Promise\");\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar maquette_1 = require(\"maquette\");\n/**\n * Represents the state of the projector\n */\nvar ProjectorState;\n(function (ProjectorState) {\n    ProjectorState[ProjectorState[\"Attached\"] = 1] = \"Attached\";\n    ProjectorState[ProjectorState[\"Detached\"] = 2] = \"Detached\";\n})(ProjectorState = exports.ProjectorState || (exports.ProjectorState = {}));\n/**\n * Attach type for the projector\n */\nvar AttachType;\n(function (AttachType) {\n    AttachType[AttachType[\"Append\"] = 1] = \"Append\";\n    AttachType[AttachType[\"Merge\"] = 2] = \"Merge\";\n    AttachType[AttachType[\"Replace\"] = 3] = \"Replace\";\n})(AttachType = exports.AttachType || (exports.AttachType = {}));\n/**\n * Private state map keyed by instance.\n */\nvar projectorDataMap = new WeakMap_1.default();\n/**\n * Schedules a render.\n */\nfunction scheduleRender(event) {\n    var projector = event.target;\n    var projectorData = projectorDataMap.get(projector);\n    if (projectorData.state === ProjectorState.Attached) {\n        projector.emit({\n            type: 'render:scheduled',\n            target: projector\n        });\n        projectorData.projector.scheduleRender();\n    }\n}\nfunction attach(instance, _a) {\n    var type = _a.type;\n    var projectorData = projectorDataMap.get(instance);\n    var render = instance.__render__.bind(instance);\n    if (projectorData.state === ProjectorState.Attached) {\n        return projectorData.attachPromise || Promise_1.default.resolve({});\n    }\n    projectorData.state = ProjectorState.Attached;\n    projectorData.attachHandle = instance.own({\n        destroy: function () {\n            if (projectorData.state === ProjectorState.Attached) {\n                projectorData.projector.stop();\n                projectorData.projector.detach(render);\n                projectorData.state = ProjectorState.Detached;\n            }\n            projectorData.attachHandle = { destroy: function () { } };\n        }\n    });\n    projectorData.attachPromise = new Promise_1.default(function (resolve, reject) {\n        projectorData.afterCreate = function () {\n            instance.emit({\n                type: 'projector:attached',\n                target: instance\n            });\n            resolve(projectorData.attachHandle);\n        };\n    });\n    switch (type) {\n        case AttachType.Append:\n            projectorData.projector.append(projectorData.root, render);\n            break;\n        case AttachType.Merge:\n            projectorData.projector.merge(projectorData.root, render);\n            break;\n        case AttachType.Replace:\n            projectorData.projector.replace(projectorData.root, render);\n            break;\n    }\n    return projectorData.attachPromise;\n}\nvar createProjectorMixin = compose_1.default({\n    append: function () {\n        var options = {\n            type: AttachType.Append\n        };\n        return attach(this, options);\n    },\n    merge: function () {\n        var options = {\n            type: AttachType.Merge\n        };\n        return attach(this, options);\n    },\n    replace: function () {\n        var options = {\n            type: AttachType.Replace\n        };\n        return attach(this, options);\n    },\n    set root(root) {\n        var projectorData = projectorDataMap.get(this);\n        if (projectorData.state === ProjectorState.Attached) {\n            throw new Error('Projector already attached, cannot change root element');\n        }\n        projectorData.root = root;\n    },\n    get root() {\n        var projectorData = projectorDataMap.get(this);\n        return projectorData && projectorData.root;\n    },\n    get projector() {\n        return projectorDataMap.get(this).projector;\n    },\n    get projectorState() {\n        var projectorData = projectorDataMap.get(this);\n        return projectorData && projectorData.state;\n    }\n}).mixin({\n    mixin: {\n        nodeAttributes: [\n            function () {\n                var afterCreate = projectorDataMap.get(this).afterCreate;\n                return { afterCreate: afterCreate };\n            }\n        ]\n    },\n    aspectAdvice: {\n        after: {\n            __render__: function (result) {\n                if (typeof result === 'string' || result === null) {\n                    throw new Error('Must provide a VNode at the root of a projector');\n                }\n                return result;\n            }\n        }\n    }\n}).mixin({\n    initialize: function (instance, options) {\n        if (options === void 0) { options = {}; }\n        var _a = options.root, root = _a === void 0 ? document.body : _a, _b = options.cssTransitions, cssTransitions = _b === void 0 ? false : _b;\n        var maquetteProjectorOptions = {};\n        if (cssTransitions) {\n            if (global_1.default.cssTransitions) {\n                maquetteProjectorOptions.transitions = global_1.default.cssTransitions;\n            }\n            else {\n                throw new Error('Unable to create projector with css transitions enabled. Is the \\'css-transition.js\\' script loaded in the page?');\n            }\n        }\n        instance.own(instance.on('widget:children', instance.invalidate));\n        instance.own(instance.on('invalidated', scheduleRender));\n        var projector = maquette_1.createProjector(maquetteProjectorOptions);\n        projectorDataMap.set(instance, {\n            projector: projector,\n            root: root,\n            state: ProjectorState.Detached\n        });\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createProjectorMixin;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widgets/mixins/createProjectorMixin.js\n// module id = 66\n// module chunks = 0","\"use strict\";\nvar WeakMap_1 = require(\"@dojo/shim/WeakMap\");\nvar array_1 = require(\"@dojo/shim/array\");\nvar lang_1 = require(\"@dojo/core/lang\");\nvar createEvented_1 = require(\"@dojo/compose/bases/createEvented\");\n/**\n * Private map for external state.\n */\nvar internalStateMap = new WeakMap_1.default();\n/**\n * state changed event type\n */\nvar stateChangedEventType = 'state:changed';\nfunction replaceState(instance, state) {\n    var internalState = internalStateMap.get(instance);\n    internalState.state = state;\n    var eventObject = {\n        type: stateChangedEventType,\n        state: state,\n        target: instance\n    };\n    instance.emit(eventObject);\n}\nfunction onPropertiesChanged(instance, properties, changedPropertyKeys) {\n    var internalState = internalStateMap.get(instance);\n    if (internalState) {\n        if (array_1.includes(changedPropertyKeys, 'externalState') || array_1.includes(changedPropertyKeys, 'id')) {\n            internalState.handle.destroy();\n        }\n    }\n    instance.observe();\n}\n/**\n * ExternalState Factory\n */\nvar externalStateFactory = createEvented_1.default.mixin({\n    className: 'ExternalStateMixin',\n    mixin: {\n        get state() {\n            return internalStateMap.get(this).state;\n        },\n        observe: function () {\n            var _this = this;\n            var internalState = internalStateMap.get(this);\n            var _a = this.properties, id = _a.id, externalState = _a.externalState;\n            if (!id || !externalState) {\n                throw new Error('id and externalState are required to observe state');\n            }\n            if (internalState) {\n                if (internalState.id === id) {\n                    return;\n                }\n                throw new Error('Unable to observe state for a different id');\n            }\n            var subscription = externalState\n                .observe(id)\n                .subscribe(function (state) {\n                replaceState(_this, state);\n            }, function (err) {\n                throw err;\n            });\n            var handle = {\n                destroy: function () {\n                    subscription.unsubscribe();\n                    internalStateMap.delete(_this);\n                }\n            };\n            internalStateMap.set(this, { id: id, handle: handle, state: Object.create(null) });\n            this.own(handle);\n        },\n        setState: function (newState) {\n            var _this = this;\n            var _a = this.properties, externalState = _a.externalState, id = _a.id;\n            externalState.patch(lang_1.assign({ id: id }, newState))\n                .then(function () { return externalState.get(id); })\n                .then(function (state) {\n                replaceState(_this, state);\n            });\n        }\n    },\n    initialize: function (instance) {\n        instance.own(instance.on('properties:changed', function (evt) {\n            onPropertiesChanged(instance, evt.properties, evt.changedPropertyKeys);\n        }));\n        instance.observe();\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = externalStateFactory;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widgets/mixins/externalState.js\n// module id = 67\n// module chunks = 0","import createWidgetBase from '@dojo/widgets/createWidgetBase';\nimport { Widget, WidgetState, DNode } from '@dojo/widgets/interfaces';\nimport { v, w } from '@dojo/widgets/d';\nimport router, { mainRoute } from '../routes';\nimport { Item } from '../stores/todoStore';\nimport createFocusableTextInput from './createFocusableTextInput';\nimport createCheckboxInput from './createCheckboxInput';\nimport { updateTodo } from '../actions/todoStoreActions';\nimport { FocusableTextInput } from './createFocusableTextInput';\nimport createFormattedDate from './createFormattedDate';\nimport externalStateMixin from '@dojo/widgets/mixins/externalState';\n\ninterface TodoDetailsProperties {\n\ttodoDetails: Item;\n\tactiveFilter: string;\n\tactiveView: string;\n}\n\nexport type TodoDetailsState = WidgetState & TodoDetailsProperties;\nexport type TodoDetails = Widget<TodoDetailsProperties>;\n\nconst createFocusableTextArea = createFocusableTextInput.mixin({\n\tmixin: {\n\t\ttagName: 'textarea'\n\t}\n});\n\ninterface EventHandler {\n\t(event: any): void;\n}\n\nconst completedHandlers = new WeakMap<TodoDetails, EventHandler>();\nconst textUpdateHandlers = new WeakMap<TodoDetails, EventHandler>();\nconst closeHandlers = new WeakMap<TodoDetails, EventHandler>();\n\nconst createTodoDetails = createWidgetBase\n\t.mixin(externalStateMixin)\n\t.mixin({\n\t\tmixin: {\n\t\t\ttagName: 'div',\n\t\t\tclasses: [ 'todo-details' ],\n\n\t\t\tgetChildrenNodes(this: TodoDetails): DNode[] {\n\t\t\t\tconst { todoDetails } = this.state as TodoDetailsState;\n\n\t\t\t\tconst { label = '', completed = false, createdOn = new Date() } = todoDetails || {};\n\n\t\t\t\treturn [\n\t\t\t\t\tv('div.backdrop', {}),\n\t\t\t\t\tv('div.modal', {}, [\n\t\t\t\t\t\tv('div.close', {\n\t\t\t\t\t\t\tonclick: closeHandlers.get(this)\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tv('header', {}, [\n\t\t\t\t\t\t\tv('div.title', {}, [\n\t\t\t\t\t\t\t\t'Details'\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t]),\n\t\t\t\t\t\tv('section', {}, [\n\t\t\t\t\t\t\tw(createFocusableTextArea, {\n\t\t\t\t\t\t\t\tfocused: true,\n\t\t\t\t\t\t\t\tvalue: label,\n\t\t\t\t\t\t\t\tonInput: textUpdateHandlers.get(this)\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tv('div', {}, [\n\t\t\t\t\t\t\t\tv('div.last-updated', [\n\t\t\t\t\t\t\t\t\t'Created on ',\n\t\t\t\t\t\t\t\t\tw(createFormattedDate, {\n\t\t\t\t\t\t\t\t\t\tdate: createdOn\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\tw(createCheckboxInput, {\n\t\t\t\t\t\t\t\t\tclasses: [ 'toggle' ],\n\t\t\t\t\t\t\t\t\tchecked: completed,\n\t\t\t\t\t\t\t\t\tonChange: completedHandlers.get(this)\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t])\n\t\t\t\t\t])\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t}).mixin({\n\t\tinitialize(instance: TodoDetails) {\n\t\t\tconst { activeFilter: filter, activeView: view } = instance.state as TodoDetailsState;\n\n\t\t\tconst closeLink = router.link(mainRoute, {\n\t\t\t\tfilter,\n\t\t\t\tview\n\t\t\t});\n\n\t\t\tcompletedHandlers.set(instance, () => {\n\t\t\t\t(<any> instance.state).todoDetails.completed = !(<any> instance.state).todoDetails.completed;\n\t\t\t\tinstance.invalidate();\n\t\t\t});\n\n\t\t\ttextUpdateHandlers.set(instance, function (this: FocusableTextInput, event: any) {\n\t\t\t\t// this.value = event.target.value;\n\t\t\t\t(<any> instance.state).todoDetails.label = event.target.value;\n\t\t\t});\n\n\t\t\tcloseHandlers.set(instance, () => {\n\t\t\t\tupdateTodo((<any> instance.state).todoDetails).then(() => {\n\t\t\t\t\tdocument.location.href = closeLink;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t});\n\nexport default createTodoDetails;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoDetails.ts","import createFormFieldMixin, { FormFieldMixin } from '@dojo/widgets/mixins/createFormFieldMixin';\nimport createWidgetBase from '@dojo/widgets/createWidgetBase';\nimport { Widget, WidgetProperties } from '@dojo/widgets/interfaces';\nimport { VNodeProperties } from '@dojo/interfaces/vdom';\n\nexport interface FocusableTextProperties extends WidgetProperties {\n\tfocused?: boolean;\n\tplaceholder?: string;\n\tvalue?: string;\n\tonKeyUp?: (event?: KeyboardEvent) => void;\n\tonInput?: (event?: KeyboardEvent) => void;\n\tonBlur?: (event?: Event) => void;\n}\n\nexport type FocusableTextInput = Widget<FocusableTextProperties> & FormFieldMixin<string, WidgetProperties> & {\n\tonKeyUp: (event?: KeyboardEvent) => void;\n\tonInput: (event?: KeyboardEvent) => void;\n\tonBlur: (event?: Event) => void;\n\tafterCreate: (element: HTMLInputElement) => void;\n}\n\nconst createFocusableTextInput = createWidgetBase\n\t.mixin(createFormFieldMixin)\n\t.mixin({\n\t\tmixin: {\n\t\t\ttagName: 'input',\n\t\t\ttype: 'text',\n\n\t\t\tonBlur(this: FocusableTextInput, event?: Event) {\n\t\t\t\tthis.properties.onBlur && this.properties.onBlur(event);\n\t\t\t},\n\t\t\tonInput(this: FocusableTextInput, event?: KeyboardEvent) {\n\t\t\t\tthis.properties.onInput && this.properties.onInput(event);\n\t\t\t},\n\t\t\tonKeyUp(this: FocusableTextInput, event?: KeyboardEvent) {\n\t\t\t\tthis.properties.onKeyUp && this.properties.onKeyUp(event);\n\t\t\t},\n\n\t\t\tafterCreate(this: FocusableTextInput, element: HTMLInputElement) {\n\t\t\t\tconst focused = this.properties.focused;\n\t\t\t\tif (focused) {\n\t\t\t\t\tsetTimeout(() => element.focus(), 0);\n\t\t\t\t}\n\t\t\t\telse if (!focused && document.activeElement === element) {\n\t\t\t\t\telement.blur();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: FocusableTextInput): VNodeProperties {\n\t\t\t\t\tconst { onKeyUp: onkeyup, onBlur: onblur, afterCreate, onInput: oninput } = this;\n\t\t\t\t\tconst { placeholder, value = '' } = this.properties;\n\n\t\t\t\t\treturn { placeholder, innerHTML: value, value, afterCreate, onkeyup, onblur, oninput };\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\nexport default createFocusableTextInput;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createFocusableTextInput.ts","\"use strict\";\nvar createStateful_1 = require(\"@dojo/compose/bases/createStateful\");\nvar createCancelableEvent_1 = require(\"@dojo/compose/bases/createCancelableEvent\");\nvar lang_1 = require(\"@dojo/core/lang\");\nfunction valueReplacer(key, value) {\n    if (value instanceof RegExp) {\n        return (\"__RegExp(\" + value.toString() + \")\");\n    }\n    return value;\n}\nfunction valueReviver(key, value) {\n    if (value.toString().indexOf('__RegExp(') === 0) {\n        var _a = value.match(/__RegExp\\(([^\\)]*)\\)/), regExpStr = _a[1];\n        var _b = regExpStr.match(/^\\/(.*?)\\/([gimy]*)$/), regExp = _b[1], flags = _b[2];\n        return new RegExp(regExp, flags);\n    }\n    return value;\n}\n/**\n * Internal function to convert a state value to a string\n * @param value The value to be converted\n */\nfunction valueToString(value) {\n    return value\n        ? Array.isArray(value) || typeof value === 'object'\n            ? JSON.stringify(value, valueReplacer) : String(value)\n        : value === 0\n            ? '0' : value === false\n            ? 'false' : '';\n}\nexports.valueToString = valueToString;\n/**\n * Internal function to convert a string to the likely more complex value stored in\n * state\n * @param str The string to convert to a state value\n */\nfunction stringToValue(str) {\n    try {\n        var value = JSON.parse(str, valueReviver);\n        return value;\n    }\n    catch (e) {\n        if (/^(\\-|\\+)?([0-9]+(\\.[0-9]+)?|Infinity)$/.test(str)) {\n            return Number(str);\n        }\n        if (str) {\n            return str;\n        }\n        return undefined;\n    }\n}\nexports.stringToValue = stringToValue;\nvar createFormMixin = createStateful_1.default\n    .mixin({\n    mixin: {\n        get value() {\n            return valueToString(this.state.value);\n        },\n        set value(value) {\n            if (value !== this.state.value) {\n                var event_1 = lang_1.assign(createCancelableEvent_1.default({\n                    type: 'valuechange',\n                    target: this\n                }), {\n                    oldValue: valueToString(this.state.value),\n                    value: value\n                });\n                this.emit(event_1);\n                if (!event_1.defaultPrevented) {\n                    this.setState({ value: stringToValue(event_1.value) });\n                }\n            }\n        },\n        nodeAttributes: [\n            function () {\n                var _a = this, type = _a.type, value = _a.value, state = _a.state;\n                var disabled = state.disabled, name = state.name;\n                return { type: type, value: value, name: name, disabled: Boolean(disabled) };\n            }\n        ]\n    },\n    initialize: function (instance, _a) {\n        var _b = _a === void 0 ? {} : _a, value = _b.value, type = _b.type;\n        if (value) {\n            instance.setState({ value: value });\n        }\n        if (type) {\n            instance.type = type;\n        }\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createFormMixin;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widgets/mixins/createFormFieldMixin.js\n// module id = 70\n// module chunks = 0","\"use strict\";\n/**\n * A simple factory that creates an event object which can be cancelled\n *\n * @param options The options for the event\n */\nfunction createCancelableEvent(options) {\n    var type = options.type, target = options.target;\n    var event = Object.defineProperties({}, {\n        type: { value: type, enumerable: true },\n        target: { value: target, enumerable: true },\n        cancelable: { value: true, enumerable: true },\n        defaultPrevented: { value: false, enumerable: true, configurable: true },\n        preventDefault: { value: function () {\n                Object.defineProperty(event, 'defaultPrevented', { value: true, enumerable: true });\n            }, enumerable: true }\n    });\n    return event;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createCancelableEvent;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/compose/bases/createCancelableEvent.js\n// module id = 71\n// module chunks = 0","import createWidgetBase from '@dojo/widgets/createWidgetBase';\nimport { Widget, WidgetProperties } from '@dojo/widgets/interfaces';\nimport createFormFieldMixin, { FormFieldMixin } from '@dojo/widgets/mixins/createFormFieldMixin';\nimport { VNodeProperties } from '@dojo/interfaces/vdom';\n\nexport interface CheckboxInputProperties extends WidgetProperties {\n\tchecked: boolean;\n\tonChange?: (event?: Event) => void;\n}\n\nexport type CheckboxInput = Widget<CheckboxInputProperties> & FormFieldMixin<string, CheckboxInputProperties> & {\n\tonChange: (event?: Event) => void;\n};\n\nconst createCheckboxInput = createWidgetBase\n\t.mixin(createFormFieldMixin)\n\t.mixin({\n\t\tmixin: {\n\t\t\ttagName: 'input',\n\t\t\ttype: 'checkbox',\n\t\t\tonChange(this: CheckboxInput, event?: Event) {\n\t\t\t\tthis.properties.onChange && this.properties.onChange(event);\n\t\t\t},\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: CheckboxInput): VNodeProperties {\n\t\t\t\t\tconst { onChange: onchange } = this;\n\t\t\t\t\tconst { checked } = this.state;\n\n\t\t\t\t\treturn checked !== undefined ? { checked, onchange } : { onchange };\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\nexport default createCheckboxInput;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createCheckboxInput.ts","import todoStore, { Item } from '../stores/todoStore';\nimport createFilter from '@dojo/stores/query/createFilter';\nimport { assign } from '@dojo/core/lang';\n\nlet id = 0;\n\nexport const addTodo = function({ label, completed }: { label: string, completed: boolean }) {\n\treturn todoStore.add({ id: `${id++}`, label, completed, createdOn: new Date(), editing: false });\n};\n\nexport const deleteTodo = function({ id }: { id: string }) {\n\treturn todoStore.delete(id);\n};\n\nexport const deleteCompleted = function() {\n\treturn todoStore.fetch(createFilter<Item>().equalTo('completed', true))\n\t\t.then((items: Item[]) => todoStore.identify(items))\n\t\t.then((ids: string[]) => todoStore.delete(ids));\n};\n\nexport const toggleAll = function({ checked: completed }: { checked: boolean }) {\n\treturn todoStore.fetch()\n\t\t.then((items: Item[]) => {\n\t\t\treturn items.map((item) => {\n\t\t\t\treturn assign({}, item, <any> { completed });\n\t\t\t});\n\t\t})\n\t\t.then((items) => todoStore.patch(items));\n};\n\nexport const updateTodo = function(item: Item) {\n\treturn todoStore.patch(item);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions/todoStoreActions.ts","\"use strict\";\nvar createJsonPointer_1 = require(\"../patch/createJsonPointer\");\nvar utils_1 = require(\"../utils\");\nfunction isBooleanOp(op) {\n    return op === 0 /* And */ || op === 1 /* Or */;\n}\nfunction isFilter(filterOrFunction) {\n    return typeof filterOrFunction !== 'function' && filterOrFunction.apply;\n}\nfunction createFilterOrReturnOp(descriptorOrOp) {\n    if (isBooleanOp(descriptorOrOp)) {\n        return descriptorOrOp;\n    }\n    else {\n        return createComparator(descriptorOrOp.filterType, descriptorOrOp.value, descriptorOrOp.path);\n    }\n}\nfunction createFilter(filterDescriptors, serializer) {\n    var filters = [];\n    if (filterDescriptors) {\n        if (Array.isArray(filterDescriptors)) {\n            filters = filterDescriptors.map(function (descriptorChainMember) {\n                if (Array.isArray(descriptorChainMember)) {\n                    return createFilter(descriptorChainMember);\n                }\n                else {\n                    return createFilterOrReturnOp(descriptorChainMember);\n                }\n            });\n        }\n        else {\n            filters.push(createComparator(filterDescriptors.filterType, filterDescriptors.value, filterDescriptors.path));\n        }\n    }\n    return createFilterHelper(filters, serializer || serializeFilter);\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createFilter;\nfunction createFilterHelper(filters, serializer) {\n    // Small helpers to abstract common operations for building comparator filters\n    // The main helper delegates to the factory, adding and AND operation before the next filter,\n    // because by default each filter in a chain will be ANDed with the previous.\n    function comparatorFilterHelper(filterType, value, path) {\n        path = path || createJsonPointer_1.default();\n        var needsOperator = filters.length > 0 &&\n            ((filters[filters.length - 1] !== 0 /* And */ && filters[filters.length - 1] !== 1) /* Or */);\n        var newFilters = needsOperator ? filters.concat([0 /* And */, createComparator(filterType, value, path)]) : filters.concat([createComparator(filterType, value, path)]);\n        return createFilterHelper(newFilters, serializer);\n    }\n    var filter = {\n        test: function (item) {\n            return applyFilterChain(item, filters);\n        },\n        filterType: 12 /* Compound */,\n        apply: function (data) {\n            return data.filter(this.test);\n        },\n        filterChain: filters,\n        toString: function (filterSerializer) {\n            return (filterSerializer || serializer)(this);\n        },\n        and: function (newFilter) {\n            var newFilters = [];\n            if (newFilter) {\n                newFilters.push(this, 0 /* And */, newFilter);\n            }\n            else if (filters.length) {\n                newFilters.push.apply(newFilters, filters.concat([0 /* And */]));\n            }\n            return createFilterHelper(newFilters, serializer);\n        },\n        or: function (newFilter) {\n            var newFilters = [];\n            if (newFilter) {\n                newFilters.push(this, 1 /* Or */, newFilter);\n            }\n            else if (filters.length) {\n                newFilters.push.apply(newFilters, filters.concat([1 /* Or */]));\n            }\n            return createFilterHelper(newFilters, serializer);\n        },\n        lessThan: function (path, value) {\n            return comparatorFilterHelper(0 /* LessThan */, value, path);\n        },\n        lessThanOrEqualTo: function (path, value) {\n            return comparatorFilterHelper(8 /* LessThanOrEqualTo */, value, path);\n        },\n        greaterThan: function (path, value) {\n            return comparatorFilterHelper(1 /* GreaterThan */, value, path);\n        },\n        greaterThanOrEqualTo: function (path, value) {\n            return comparatorFilterHelper(9 /* GreaterThanOrEqualTo */, value, path);\n        },\n        matches: function (path, value) {\n            return comparatorFilterHelper(10 /* Matches */, value, path);\n        },\n        'in': function (path, value) {\n            return comparatorFilterHelper(4 /* In */, value, path);\n        },\n        contains: function (path, value) {\n            return comparatorFilterHelper(5 /* Contains */, value, path);\n        },\n        equalTo: function (path, value) {\n            return comparatorFilterHelper(2 /* EqualTo */, value, path);\n        },\n        deepEqualTo: function (path, value) {\n            return comparatorFilterHelper(3 /* DeepEqualTo */, value, path);\n        },\n        notEqualTo: function (path, value) {\n            return comparatorFilterHelper(6 /* NotEqualTo */, value, path);\n        },\n        notDeepEqualTo: function (path, value) {\n            return comparatorFilterHelper(7 /* NotDeepEqualTo */, value, path);\n        },\n        custom: function (test) {\n            return comparatorFilterHelper(11 /* Custom */, test);\n        },\n        queryType: 0 /* Filter */,\n        incremental: true\n    };\n    return filter;\n}\nfunction applyFilterChain(item, filterChain) {\n    var ordFilterSections = [];\n    var startOfSlice = 0;\n    // Ands have higher precedence, so split into chains of\n    // ands between ors.\n    filterChain.forEach(function (chainMember, i) {\n        if (chainMember === 1 /* Or */) {\n            ordFilterSections.push(filterChain.slice(startOfSlice, i));\n            startOfSlice = i + 1;\n        }\n    });\n    if (startOfSlice < filterChain.length) {\n        ordFilterSections.push(filterChain.slice(startOfSlice, filterChain.length));\n    }\n    // These sections are or'd together so only\n    // one has to pass\n    return ordFilterSections.some(function (filterChain) {\n        // The individual filters are and'd together, so if any\n        // fails the whole section fails\n        return filterChain.every(function (filterOrAnd) {\n            if (isFilter(filterOrAnd)) {\n                return filterOrAnd.test(item);\n            }\n            else {\n                return true;\n            }\n        });\n    });\n}\nfunction createComparator(operator, value, path) {\n    path = typeof path === 'string' ? createJsonPointer_1.default(path) : path;\n    var test;\n    var filterType = operator;\n    var operatorString;\n    switch (operator) {\n        case 0 /* LessThan */:\n            test = function (property) {\n                return property < value;\n            };\n            operatorString = 'lt';\n            break;\n        case 8 /* LessThanOrEqualTo */:\n            test = function (property) {\n                return property <= value;\n            };\n            operatorString = 'lte';\n            break;\n        case 1 /* GreaterThan */:\n            test = function (property) {\n                return property > value;\n            };\n            operatorString = 'gt';\n            break;\n        case 9 /* GreaterThanOrEqualTo */:\n            test = function (property) {\n                return property >= value;\n            };\n            operatorString = 'gte';\n            break;\n        case 2 /* EqualTo */:\n            test = function (property) {\n                return property === value;\n            };\n            operatorString = 'eq';\n            break;\n        case 6 /* NotEqualTo */:\n            test = function (property) {\n                return property !== value;\n            };\n            operatorString = 'ne';\n            break;\n        case 3 /* DeepEqualTo */:\n            test = function (property) {\n                return utils_1.isEqual(property, value);\n            };\n            operatorString = 'eq';\n            break;\n        case 7 /* NotDeepEqualTo */:\n            test = function (property) {\n                return !utils_1.isEqual(property, value);\n            };\n            operatorString = 'ne';\n            break;\n        case 5 /* Contains */:\n            test = function (propertyOrItem) {\n                if (Array.isArray(propertyOrItem)) {\n                    return propertyOrItem.indexOf(value) > -1;\n                }\n                else {\n                    return propertyOrItem && Boolean(propertyOrItem[value]);\n                }\n            };\n            operatorString = 'contains';\n            break;\n        case 4 /* In */:\n            test = function (propertyOrItem) {\n                return Array.isArray(value) && value.indexOf(propertyOrItem) > -1;\n            };\n            operatorString = 'in';\n            break;\n        case 10 /* Matches */:\n            test = function (property) {\n                return value.test(property);\n            };\n            break;\n        case 11 /* Custom */:\n            test = value;\n            break;\n    }\n    return {\n        test: function (item) {\n            var propertyValue = createJsonPointer_1.navigate(path, item);\n            return test(propertyValue);\n        },\n        apply: function (data) {\n            return data.filter(this.test);\n        },\n        toString: function () {\n            if (!operatorString) {\n                throw Error('Cannot parse this filter type to an RQL query string');\n            }\n            return operatorString + \"(\" + path.toString() + \", \" + JSON.stringify(value) + \")\";\n        },\n        path: path,\n        value: value,\n        filterType: filterType,\n        queryType: 0 /* Filter */\n    };\n}\n//// Default serialization function\nfunction serializeFilter(filter) {\n    var operator = '&';\n    if (filter.filterChain && filter.filterChain.length > 0) {\n        return filter.filterChain.reduce(function (prev, next) {\n            if (isFilter(next)) {\n                var start = next.filterChain ? '(' : '';\n                var end = next.filterChain ? ')' : '';\n                return prev + (prev ? operator : '') + (prev ? start : '') + next.toString() + (prev ? end : '');\n            }\n            else if (next === 0 /* And */) {\n                operator = '&';\n                return prev;\n            }\n            else {\n                operator = '|';\n                return prev;\n            }\n        }, '');\n    }\n    else {\n        return '';\n    }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/stores/query/createFilter.js\n// module id = 74\n// module chunks = 0","import { Widget } from '@dojo/widgets/interfaces';\nimport { VNodeProperties } from '@dojo/interfaces/vdom';\nimport createWidgetBase from '@dojo/widgets/createWidgetBase';\nimport { padStart } from '@dojo/shim/string';\n\ninterface FormattedDateProperties {\n\tdate: Date;\n}\n\nexport type FormattedDate = Widget<FormattedDateProperties>;\n\nconst createFormattedDate = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'span',\n\t\tnodeAttributes: [\n\t\t\tfunction (this: FormattedDate): VNodeProperties {\n\t\t\t\tconst { date = new Date() } = this.state;\n\t\t\t\tlet hours = date.getHours();\n\t\t\t\tconst minutes = String(date.getMinutes());\n\t\t\t\tlet suffix = 'am';\n\n\t\t\t\tif (hours >= 12) {\n\t\t\t\t\tsuffix = 'pm';\n\n\t\t\t\t\thours = hours % 12;\n\t\t\t\t\tif (!hours) {\n\t\t\t\t\t\thours = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tinnerHTML: `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()} at ${hours}:${padStart(minutes, 2, '0')}${suffix}`\n\t\t\t\t};\n\t\t\t}\n\t\t]\n\t}\n});\n\nexport default createFormattedDate;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createFormattedDate.ts","import createWidgetBase from '@dojo/widgets/createWidgetBase';\nimport { Widget, DNode, WidgetProperties } from '@dojo/widgets/interfaces';\nimport { todoInput } from '../actions/userActions';\nimport createTodoFooter from './createTodoFooter';\nimport { v, w } from '@dojo/widgets/d';\nimport createTitle from './createTitle';\nimport createFocusableTextInput from './createFocusableTextInput';\nimport createMainSection from './createMainSection';\n\nconst createHome = createWidgetBase.mixin({\n\tmixin: {\n\t\tgetChildrenNodes: function (this: Widget<WidgetProperties>): DNode[] {\n\t\t\tconst { properties } = this;\n\t\t\tconst { todo, todos = [] } = <any> properties;\n\t\t\tconst newTodoOptions: WidgetProperties = {\n\t\t\t\tid: 'new-todo',\n\t\t\t\tclasses: [ 'new-todo' ],\n\t\t\t\tfocused: true,\n\t\t\t\tvalue: todo ? todo : '',\n\t\t\t\tplaceholder: 'What needs to be done?',\n\t\t\t\tonKeyUp: todoInput.bind(this)\n\t\t\t};\n\n\t\t\treturn [\n\t\t\t\tv('header', {}, [\n\t\t\t\t\tw(createTitle, { id: 'title', label: 'todos' }),\n\t\t\t\t\tw(createFocusableTextInput, newTodoOptions)\n\t\t\t\t]),\n\t\t\t\tw(createMainSection, { ...properties, id: 'main-section' }),\n\t\t\t\ttodos.length ? w(createTodoFooter, { ...properties, id: 'todo-footer' }) : null\n\t\t\t];\n\t\t},\n\t\ttagName: 'div'\n\t}\n});\n\nexport default createHome;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createHome.ts","import { assign } from '@dojo/core/lang';\nimport widgetStore from '../stores/widgetStore';\nimport { addTodo, deleteCompleted, deleteTodo, toggleAll, updateTodo } from './todoStoreActions';\nimport router, { todoViewRoute } from '../routes';\nimport { Item } from '../stores/todoStore';\n\ninterface FormEvent extends Event {\n\ttarget: HTMLInputElement;\n}\n\ninterface FormInputEvent extends KeyboardEvent {\n\ttarget: HTMLInputElement;\n}\n\nexport const todoInput = function (this: any, { which, target: { value: label } }: FormInputEvent) {\n\tif (which === 13 && label) {\n\t\taddTodo({ label, completed: false });\n\t\twidgetStore.patch({ id: 'todo-app', todo: '' });\n\t\tthis.invalidate();\n\t}\n};\n\nfunction toggleEditing(todos: Item[], todoId: string, editing: boolean): Item[] {\n\treturn todos\n\t\t.filter((todo) => todo.id === todoId)\n\t\t.map((todo: Item) => {\n\t\t\ttodo.editing = editing;\n\t\t\treturn todo;\n\t\t});\n}\n\nexport const todoEdit = function (this: any, event: KeyboardEvent) {\n\tconst { state: { id } } = this;\n\tif (event.type === 'keypress' && event.which !== 13 && event.which !== 32) {\n\t\treturn;\n\t}\n\twidgetStore.get('todo-app').then((todoListState: any) => {\n\t\tconst link = router.link(todoViewRoute, {\n\t\t\tfilter: todoListState.activeFilter,\n\t\t\tview: todoListState.activeView,\n\t\t\ttodoId: id\n\t\t});\n\t\tdocument.location.href = link;\n\t});\n};\n\nexport const todoEditInput = function (this: any, event: FormInputEvent) {\n\tconst { state } = this;\n\tif (event.which === 13) {\n\t\ttodoSave.call(this, event);\n\t}\n\telse if (event.which === 27) {\n\t\twidgetStore.get('todo-app').then((todoListState: any) => {\n\t\t\tconst { todos } = todoListState;\n\t\t\ttodoListState.todos = toggleEditing(todos, state.id, false);\n\t\t\twidgetStore.patch({ id: 'todo-app', todoListState });\n\t\t});\n\t}\n};\n\nexport const todoSave = function (this: any, event: FormInputEvent) {\n\tconst { state } = this;\n\tif (!event.target.value) {\n\t\tdeleteTodo(state);\n\t}\n\telse {\n\t\tupdateTodo(assign(state, { label: event.target.value, editing: false }));\n\t}\n};\n\nexport const todoRemove = function (this: any) {\n\tconst { state } = this;\n\tdeleteTodo({ id: state.id });\n};\n\nexport const todoToggleComplete = function (this: any) {\n\tconst { properties } = this;\n\tupdateTodo({ id: properties.todoId, completed: !properties.completed, editing: false });\n};\n\nexport const todoToggleAll = function (event: FormEvent) {\n\ttoggleAll({ checked: event.target.checked });\n};\n\nexport const clearCompleted = function () {\n\tdeleteCompleted();\n};\n\nexport const updateSearch = function (this: any, searchQuery: string) {\n\twidgetStore.get('todo-app').then((todoListState: any) => {\n\t\ttodoListState.search = searchQuery;\n\n\t\twidgetStore.patch({ id: 'todo-app', todoListState });\n\t});\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions/userActions.ts","import { Widget, DNode, WidgetProperties } from '@dojo/widgets/interfaces';\nimport createWidgetBase from '@dojo/widgets/createWidgetBase';\nimport { v, w } from '@dojo/widgets/d';\nimport createButton from '@dojo/widgets/components/button/createButton';\nimport { clearCompleted } from '../actions/userActions';\nimport createTodoFilter from './createTodoFilter';\nimport createViewChooser from './createViewChooser';\n\ninterface TodoFooterProperties {\n\tactiveView: string;\n\tactiveFilter: string;\n\tactiveCount: number;\n\tcompletedCount: number;\n}\n\nexport type TodoFooter = Widget<TodoFooterProperties>;\n\nconst createTodoFooter = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'footer',\n\t\tclasses: [ 'footer' ],\n\t\tgetChildrenNodes: function (this: TodoFooter): (DNode | null)[] {\n\t\t\tconst { activeCount, activeFilter, completedCount, activeView } = this.properties;\n\t\t\tconst countLabel = activeCount === 1 ? 'item' : 'items';\n\n\t\t\treturn [\n\t\t\t\tv('span', { 'class': 'todo-count' }, [\n\t\t\t\t\tv('strong', [ activeCount + ' ' ]),\n\t\t\t\t\tv('span', [ countLabel + ' left' ])\n\t\t\t\t]),\n\t\t\t\tw(createTodoFilter, {\n\t\t\t\t\tclasses: [ 'filters' ],\n\t\t\t\t\tactiveFilter,\n\t\t\t\t\tactiveView\n\t\t\t\t}),\n\t\t\t\tw(createViewChooser, {\n\t\t\t\t\tactiveView,\n\t\t\t\t\tactiveFilter\n\t\t\t\t}),\n\t\t\t\tcompletedCount ? w(createButton, <WidgetProperties> {\n\t\t\t\t\t\tlabel: 'Clear completed',\n\t\t\t\t\t\tclasses: [ 'clear-completed' ],\n\t\t\t\t\t\tonClick: clearCompleted.bind(this)\n\t\t\t\t\t}) : null\n\t\t\t];\n\t\t}\n\t}\n});\n\nexport default createTodoFooter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoFooter.ts","\"use strict\";\nvar createWidgetBase_1 = require(\"../../createWidgetBase\");\nvar createFormFieldMixin_1 = require(\"../../mixins/createFormFieldMixin\");\nvar createButton = createWidgetBase_1.default\n    .mixin(createFormFieldMixin_1.default)\n    .mixin({\n    mixin: {\n        onClick: function (event) {\n            this.properties.onClick && this.properties.onClick(event);\n        },\n        nodeAttributes: [\n            function () {\n                return { innerHTML: this.properties.label, onclick: this.onClick };\n            }\n        ],\n        tagName: 'button',\n        type: 'button'\n    }\n});\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = createButton;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@dojo/widgets/components/button/createButton.js\n// module id = 79\n// module chunks = 0","import { Widget, DNode } from '@dojo/widgets/interfaces';\nimport createWidgetBase from '@dojo/widgets/createWidgetBase';\nimport { v }  from '@dojo/widgets/d';\nimport router, { mainRoute } from '../routes';\n\ninterface TodoFilterProperties {\n\tactiveFilter: string;\n\tactiveView: string;\n}\n\ntype TodoFilter = Widget<TodoFilterProperties>;\n\nfunction createFilterItems(activeFilter: string, activeView: string): DNode[] {\n\tconst filters = [ 'all', 'active', 'completed' ];\n\treturn filters.map((filterItem) => {\n\t\tconst label = filterItem[0].toUpperCase() + filterItem.substring(1);\n\t\treturn v('li', {}, [\n\t\t\tv('a', {\n\t\t\t\tinnerHTML: label,\n\t\t\t\thref: router.link(mainRoute, {\n\t\t\t\t\tfilter: filterItem,\n\t\t\t\t\tview: activeView\n\t\t\t\t}),\n\t\t\t\tclasses: {\n\t\t\t\t\tselected: activeFilter === filterItem\n\t\t\t\t}\n\t\t\t})\n\t\t]);\n\t});\n}\n\nconst createTodoFilter = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'ul',\n\t\tclasses: [ 'filters' ],\n\t\tgetChildrenNodes: function(this: TodoFilter): DNode[] {\n\t\t\tconst activeFilter = this.properties.activeFilter || '';\n\t\t\tconst activeView = this.properties.activeView || '';\n\n\t\t\treturn createFilterItems(activeFilter, activeView);\n\t\t}\n\t}\n});\n\nexport default createTodoFilter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoFilter.ts","import createWidgetBase from '@dojo/widgets/createWidgetBase';\nimport { Widget, DNode } from '@dojo/widgets/interfaces';\nimport { v } from '@dojo/widgets/d';\nimport router, { mainRoute } from '../routes';\n\ninterface ViewChooserProperties {\n\tactiveView: 'list' | 'cards';\n\tactiveFilter: string;\n}\n\nexport type TodoList = Widget<ViewChooserProperties>;\n\nconst createViewChooser = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'ul',\n\t\tclasses: [ 'view-chooser' ],\n\t\tgetChildrenNodes: function (this: TodoList): DNode[] {\n\t\t\tconst { activeView = 'list', activeFilter = 'all' } = this.state;\n\n\t\t\treturn [\n\t\t\t\tv('li.view-mode', {}, [\n\t\t\t\t\tv('a', {\n\t\t\t\t\t\thref: router.link(mainRoute, {\n\t\t\t\t\t\t\tfilter: activeFilter,\n\t\t\t\t\t\t\tview: 'list'\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tclasses: {\n\t\t\t\t\t\t\tlist: true,\n\t\t\t\t\t\t\tactive: activeView === 'list'\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t]),\n\t\t\t\tv('li.view-mode', {}, [\n\t\t\t\t\tv('a', {\n\t\t\t\t\t\thref: router.link(mainRoute, {\n\t\t\t\t\t\t\tfilter: activeFilter,\n\t\t\t\t\t\t\tview: 'cards'\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tclasses: {\n\t\t\t\t\t\t\tcards: true,\n\t\t\t\t\t\t\tactive: activeView === 'cards'\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t];\n\t\t}\n\t}\n});\n\nexport default createViewChooser;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createViewChooser.ts","import { Widget } from '@dojo/widgets/interfaces';\nimport { VNodeProperties } from '@dojo/interfaces/vdom';\nimport createWidgetBase from '@dojo/widgets/createWidgetBase';\n\ninterface TitleProperties {\n\tlabel: string;\n}\n\nconst createTitle = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'h1',\n\t\tnodeAttributes: [\n\t\t\tfunction (this: Widget<TitleProperties>): VNodeProperties {\n\t\t\t\treturn { innerHTML: this.properties.label };\n\t\t\t}\n\t\t]\n\t}\n});\n\nexport default createTitle;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTitle.ts","import { DNode, Widget, WidgetProperties } from '@dojo/widgets/interfaces';\nimport createWidgetBase from '@dojo/widgets/createWidgetBase';\nimport { w, v } from '@dojo/widgets/d';\n\nimport { todoToggleAll, updateSearch } from '../actions/userActions';\nimport createCheckboxInput from './createCheckboxInput';\nimport createTodoItemList from './createTodoItemList';\nimport createSearchInput from './createSearchInput';\nimport { CheckboxInputProperties } from './createCheckboxInput';\n\ninterface MainSectionProperties {\n\tallCompleted: boolean;\n}\n\nfunction searchHandler(event: any) {\n\tupdateSearch(event.target.value);\n}\n\nconst createMainSection = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'section',\n\t\tclasses: [ 'main' ],\n\t\tgetChildrenNodes: function (this: Widget<MainSectionProperties>): DNode[] {\n\t\t\tconst { properties } = <any> this;\n\t\t\tconst { todos = [] } = properties;\n\t\t\tconst checkBoxOptions: CheckboxInputProperties = {\n\t\t\t\tid: 'todo-toggle',\n\t\t\t\tchecked: properties.allCompleted,\n\t\t\t\tclasses: [ 'toggle-all' ],\n\t\t\t\tonChange: todoToggleAll\n\t\t\t};\n\n\t\t\tconst { activeView } = properties;\n\n\t\t\treturn <DNode[]> [\n\t\t\t\tw(createCheckboxInput, checkBoxOptions),\n\t\t\t\ttodos.length ? v('div.searchbar', {}, [\n\t\t\t\t\t\tv('span.icon', {}), w(createSearchInput, {\n\t\t\t\t\t\t\tplaceholder: 'Quick Filter',\n\t\t\t\t\t\t\tvalue: properties.search,\n\t\t\t\t\t\t\tonKeyUp: searchHandler\n\t\t\t\t\t\t})\n\t\t\t\t\t]) : null,\n\t\t\t\tw(createTodoItemList, <WidgetProperties> {\n\t\t\t\t\t...properties,\n\t\t\t\t\tid: `todo-item-${activeView === 'cards' ? 'cards' : 'list'}`\n\t\t\t\t})\n\t\t\t];\n\t\t}\n\t}\n});\n\nexport default createMainSection;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createMainSection.ts","import { Widget, DNode, WidgetProperties } from '@dojo/widgets/interfaces';\nimport createWidgetBase from '@dojo/widgets/createWidgetBase';\nimport { w, v } from '@dojo/widgets/d';\nimport { Item } from '../stores/todoStore';\nimport createTodoListItem from './createTodoListItem';\nimport createTodoCardItem from './createTodoCardItem';\nimport { VNodeProperties } from '@dojo/interfaces/vdom';\n\ntype TodoListProperties = {\n\tactiveFilter: string;\n\tactiveView: string;\n\ttodos: Item[];\n\tsearch: string;\n};\n\nexport type TodoList = Widget<TodoListProperties>;\n\nfunction filter(filterName: string, todo: Item): boolean {\n\tswitch (filterName) {\n\t\tcase 'completed':\n\t\t\treturn !!todo.completed;\n\t\tcase 'active':\n\t\t\treturn !todo.completed;\n\t\tdefault:\n\t\t\treturn true;\n\t}\n}\n\nfunction applySearch(searchQuery: string, todo: Item): boolean {\n\treturn searchQuery === '' || (todo.label || '').toLowerCase().indexOf(searchQuery) >= 0;\n}\n\nconst createTodoItemList = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'ul',\n\t\tclasses: [ 'todo-list' ],\n\t\tnodeAttributes: [\n\t\t\tfunction (this: TodoList): VNodeProperties {\n\t\t\t\tconst { activeView = 'list', todos = [] } = this.state;\n\n\t\t\t\treturn {\n\t\t\t\t\tclasses: {\n\t\t\t\t\t\t'card-list': activeView === 'cards',\n\t\t\t\t\t\t'empty': todos.length === 0\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t],\n\t\tgetChildrenNodes: function (this: TodoList): DNode[] {\n\t\t\tconst activeFilter = this.properties.activeFilter || '';\n\t\t\tconst todos = this.properties.todos || [];\n\t\t\tconst search = this.properties.search || '';\n\t\t\tconst activeView = this.properties.activeView || 'list';\n\n\t\t\treturn todos\n\t\t\t\t.filter((todo: Item) => filter(activeFilter, todo))\n\t\t\t\t.filter((todo: Item) => applySearch(search.toLowerCase(), todo))\n\t\t\t\t.map((todo: Item) => <DNode> w(activeView === 'cards' ? createTodoCardItem : createTodoListItem, <WidgetProperties> {\n\t\t\t\t\t...todo,\n\t\t\t\t\ttodoId: todo.id,\n\t\t\t\t\tid: todo.id\n\t\t\t\t}))\n\t\t\t\t.concat((activeView === 'cards' && todos.length) ? [\n\t\t\t\t\t\tv('li.empty-filler', {}),\n\t\t\t\t\t\tv('li.empty-filler', {})\n\t\t\t\t\t] : null);\n\t\t}\n\t}\n});\n\nexport default createTodoItemList;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoItemList.ts","import { Widget, DNode, WidgetProperties } from '@dojo/widgets/interfaces';\nimport { VNodeProperties } from '@dojo/interfaces/vdom';\nimport createWidgetBase from '@dojo/widgets/createWidgetBase';\nimport { v, w } from '@dojo/widgets/d';\nimport { TextInputProperties } from '@dojo/widgets/components/textinput/createTextInput';\nimport createButton from '@dojo/widgets/components/button/createButton';\nimport { todoEdit, todoEditInput, todoRemove, todoSave, todoToggleComplete } from '../actions/userActions';\nimport createCheckboxInput from './createCheckboxInput';\nimport createFocusableTextInput from './createFocusableTextInput';\n\nexport interface TodoItemProperties {\n\tid: string;\n\tlabel: string;\n\tediting: boolean;\n\tcompleted: boolean;\n}\n\nexport type TodoItem = Widget<TodoItemProperties>;\n\nexport interface LabelType extends WidgetProperties {\n\tlabel: string;\n\tonDoubleClick?: (event?: MouseEvent) => void;\n\tonKeyPress?: (event?: KeyboardEvent) => void;\n}\n\nexport type LabelWidget = Widget<LabelType> & {\n\tonDoubleClick?: (event?: MouseEvent) => void;\n\tonKeyPress?: (event?: KeyboardEvent) => void;\n}\n\nconst createLabel = createWidgetBase\n\t.mixin({\n\t\tmixin: {\n\t\t\ttagName: 'label',\n\t\t\tonDoubleClick(this: LabelWidget, event?: MouseEvent) {\n\t\t\t\tthis.properties.onDoubleClick && this.properties.onDoubleClick(event);\n\t\t\t},\n\n\t\t\tonKeyPress(this: LabelWidget, event?: KeyboardEvent) {\n\t\t\t\tthis.properties.onKeyPress && this.properties.onKeyPress(event);\n\t\t\t},\n\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: LabelWidget): VNodeProperties {\n\t\t\t\t\tconst { onDoubleClick: ondblclick, onKeyPress: onkeypress } = this;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinnerHTML: this.properties.label,\n\t\t\t\t\t\t'aria-describedby': 'edit-instructions',\n\t\t\t\t\t\ttabindex: '0',\n\t\t\t\t\t\tondblclick,\n\t\t\t\t\t\tonkeypress\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\nconst createTodoListItem = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'li',\n\t\tnodeAttributes: [\n\t\t\tfunction (this: TodoItem): VNodeProperties {\n\t\t\t\tconst { completed, editing } = this.properties;\n\t\t\t\treturn {\n\t\t\t\t\tclasses: { completed, editing, card: false }\n\t\t\t\t};\n\t\t\t}\n\t\t],\n\t\tgetChildrenNodes: function (this: TodoItem): (DNode | null)[] {\n\t\t\tconst state = this.properties;\n\t\t\tconst checked = state.completed;\n\t\t\tconst label = state.label;\n\t\t\tconst focused = state.editing;\n\t\t\tconst inputOptions: TextInputProperties = {\n\t\t\t\tvalue: label,\n\t\t\t\tonKeyPress: todoEditInput.bind(this),\n\t\t\t\tonBlur: todoSave,\n\t\t\t\tid: this.state.id,\n\t\t\t\tfocused,\n\t\t\t\tclasses: [ 'edit' ]\n\t\t\t};\n\t\t\treturn [\n\t\t\t\tv('div.view', {}, [\n\t\t\t\t\tw(createCheckboxInput, {\n\t\t\t\t\t\tid: 'checkbox' + this.state.id,\n\t\t\t\t\t\tclasses: [ 'toggle' ],\n\t\t\t\t\t\tchecked,\n\t\t\t\t\t\tonChange: todoToggleComplete.bind(this)\n\t\t\t\t\t}),\n\t\t\t\t\tw(createLabel, {\n\t\t\t\t\t\tid: 'label' + this.state.id,\n\t\t\t\t\t\tlabel,\n\t\t\t\t\t\tonKeyPress: todoEdit.bind(this),\n\t\t\t\t\t\tonDoubleClick: todoEdit.bind(this)\n\t\t\t\t\t}),\n\t\t\t\t\tw(createButton, <WidgetProperties> {\n\t\t\t\t\t\tid: 'button' + this.state.id,\n\t\t\t\t\t\tclasses: [ 'destroy' ],\n\t\t\t\t\t\tonClick: todoRemove.bind(this)\n\t\t\t\t\t})\n\t\t\t\t]),\n\t\t\t\tstate.editing ?\n\t\t\t\t\tw(createFocusableTextInput, inputOptions) : null\n\t\t\t];\n\t\t}\n\t}\n});\n\nexport default createTodoListItem;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoListItem.ts","import { Widget, DNode, WidgetProperties } from '@dojo/widgets/interfaces';\nimport { VNodeProperties } from '@dojo/interfaces/vdom';\nimport createWidgetBase from '@dojo/widgets/createWidgetBase';\nimport { v, w } from '@dojo/widgets/d';\nimport { TextInputProperties } from '@dojo/widgets/components/textinput/createTextInput';\nimport createButton from '@dojo/widgets/components/button/createButton';\nimport { todoEdit, todoEditInput, todoRemove, todoSave, todoToggleComplete } from '../actions/userActions';\nimport createCheckboxInput from './createCheckboxInput';\nimport createFocusableTextInput from './createFocusableTextInput';\nimport { TodoItem } from './createTodoListItem';\n\ninterface CardItemProperties {\n\tlabel: string;\n\tonDoubleClick?: (event?: MouseEvent) => void;\n\tonKeyPress?: (event?: KeyboardEvent) => void;\n}\n\nexport interface LabelWidget {\n\tonDoubleClick?: (event?: MouseEvent) => void;\n\tonKeyPress?: (event?: KeyboardEvent) => void;\n}\n\nconst createLabel = createWidgetBase\n\t.mixin({\n\t\tmixin: {\n\t\t\ttagName: 'label',\n\n\t\t\tonDoubleClick(this: Widget<CardItemProperties>, event?: MouseEvent) {\n\t\t\t\tthis.properties.onDoubleClick && this.properties.onDoubleClick(event);\n\t\t\t},\n\n\t\t\tonKeyPress(this: Widget<CardItemProperties>, event?: KeyboardEvent) {\n\t\t\t\tthis.properties.onKeyPress && this.properties.onKeyPress(event);\n\t\t\t},\n\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: Widget<CardItemProperties> & LabelWidget): VNodeProperties {\n\t\t\t\t\tconst { onDoubleClick: ondblclick, onKeyPress: onkeypress }  = this;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinnerHTML: this.properties.label,\n\t\t\t\t\t\t'aria-describedby': 'edit-instructions',\n\t\t\t\t\t\ttabindex: '0',\n\t\t\t\t\t\tondblclick,\n\t\t\t\t\t\tonkeypress\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\nconst createTodoCardItem = createWidgetBase.mixin({\n\tmixin: {\n\t\ttagName: 'li',\n\t\tnodeAttributes: [\n\t\t\tfunction (this: TodoItem): VNodeProperties {\n\t\t\t\tconst { completed, editing } = this.state;\n\t\t\t\treturn {\n\t\t\t\t\tclasses: { completed, editing, card: true }\n\t\t\t\t};\n\t\t\t}\n\t\t],\n\t\tgetChildrenNodes: function (this: TodoItem): (DNode | null)[] {\n\t\t\tconst state = this.properties;\n\t\t\tconst checked = state.completed;\n\t\t\tconst label = state.label;\n\t\t\tconst focused = state.editing;\n\n\t\t\tconst inputOptions: TextInputProperties = {\n\t\t\t\tvalue: label,\n\t\t\t\tid: state.id,\n\t\t\t\tfocused,\n\t\t\t\tclasses: [ 'edit' ],\n\t\t\t\tonBlur: todoSave.bind(this),\n\t\t\t\tonKeyPress: todoEditInput.bind(this)\n\t\t\t};\n\t\t\treturn [\n\t\t\t\tv('div.view', {}, [\n\t\t\t\t\tv('div.header', {}, [\n\t\t\t\t\t\tw(createCheckboxInput, {\n\t\t\t\t\t\t\tid: 'check' + state.id,\n\t\t\t\t\t\t\tclasses: [ 'toggle' ],\n\t\t\t\t\t\t\tchecked,\n\t\t\t\t\t\t\tonChange: todoToggleComplete.bind(this)\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tw(createButton, <WidgetProperties> {\n\t\t\t\t\t\t\tid: 'button' + state.id,\n\t\t\t\t\t\t\tclasses: [ 'destroy' ],\n\t\t\t\t\t\t\tonClick: todoRemove.bind(this)\n\t\t\t\t\t\t})\n\t\t\t\t\t]),\n\t\t\t\t\tw(createLabel, {\n\t\t\t\t\t\tid: 'label' + state.id,\n\t\t\t\t\t\tlabel,\n\t\t\t\t\t\tonDoubleClick: todoEdit.bind(this),\n\t\t\t\t\t\tonKeyPress: todoEdit.bind(this)\n\t\t\t\t\t})\n\t\t\t\t]),\n\t\t\t\tstate.editing ?\n\t\t\t\t\tw(createFocusableTextInput, inputOptions) : null\n\t\t\t];\n\t\t}\n\t}\n});\n\nexport default createTodoCardItem;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoCardItem.ts","import { VNodeProperties } from '@dojo/interfaces/vdom';\nimport createWidget from '@dojo/widgets/createWidgetBase';\nimport { WidgetProperties, Widget } from '@dojo/widgets/interfaces';\nimport createFormFieldMixin from '@dojo/widgets/mixins/createFormFieldMixin';\n\nexport interface SearchInputProperties extends WidgetProperties {\n\tonKeyUp?: (event?: KeyboardEvent) => void;\n}\n\nexport type SearchInput = Widget<SearchInputProperties> & {\n\tonKeyUp?: (event?: KeyboardEvent) => void;\n}\n\nconst createSearchInput = createWidget\n\t.mixin(createFormFieldMixin)\n\t.mixin({\n\t\tmixin: {\n\t\t\tclasses: [ 'search' ],\n\t\t\ttagName: 'input',\n\t\t\ttype: 'text',\n\t\t\tonKeyUp(this: SearchInput, event?: KeyboardEvent) {\n\t\t\t\tthis.properties.onKeyUp && this.properties.onKeyUp(event);\n\t\t\t},\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: SearchInput): VNodeProperties {\n\t\t\t\t\tconst { onKeyUp: onkeyup } = this;\n\t\t\t\t\tconst { placeholder = '' } = this.properties;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tonkeyup\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\nexport default createSearchInput;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createSearchInput.ts"],"sourceRoot":""}